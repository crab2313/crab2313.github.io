<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>crab2313's blog</title><link>/</link><description>Recent content on crab2313's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 17 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>MESA源码分析：EGL</title><link>/post/mesa-egl/</link><pubDate>Mon, 17 Jan 2022 00:00:00 +0000</pubDate><guid>/post/mesa-egl/</guid><description>本文尝试分析EGL与MESA相关的实现，这也是我第一次尝试涉及MESA相关的代码。 本文的目的是记录我对我感兴趣的点的分析： MESA是如何实现</description></item><item><title>MESA源码分析：GBM的使用与实现</title><link>/post/mesa-gbm/</link><pubDate>Mon, 15 Nov 2021 00:00:00 +0000</pubDate><guid>/post/mesa-gbm/</guid><description>这次我感觉我能看懂GBM了，本文对GBM的实现和用法进行分析。 我们先从原理上对GBM进行推导。GBM的本质：硬件无关的显存申请与管理。为什么</description></item><item><title>Linux在RISC-V平台下的模块实现</title><link>/post/kernel-module/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate><guid>/post/kernel-module/</guid><description>因为上次碰到了模块ABI改变导致的模块加载异常问题，虽然通过分析发现了问题，也认为解决方法是模块跟着ABI走，重新编译，但是认为模块的实现还</description></item><item><title>Linux内核在RISC-V平台下的static key机制</title><link>/post/static-key/</link><pubDate>Wed, 09 Jun 2021 00:00:00 +0000</pubDate><guid>/post/static-key/</guid><description>这两天在邮件列表中看到了使用static key对内核hot path进行优化的补丁，突然有了兴趣看看内核的底层实现。原理不多说，很容易懂，细节</description></item><item><title>Linux内核在RISC-V架构下的spinlock实现</title><link>/post/riscv-spinlock/</link><pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate><guid>/post/riscv-spinlock/</guid><description>本文分析linux内核下对于spinlock的实现，具体到RISC-V体系结构。由于RISC-V体系结构下目前只是简单的实现了一个基于TAS</description></item><item><title>In Place Huffman算法分析</title><link>/post/in-place-huffman/</link><pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate><guid>/post/in-place-huffman/</guid><description>In Place Huffman算法 paper网上下不到，不过找到了一份C语言实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35</description></item><item><title>Linux内核中ARP协议的实现</title><link>/post/arp/</link><pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate><guid>/post/arp/</guid><description>本文对内核中ARP协议相关的事件进行分析。本文是原先分析文档的整理，后续会进行相应复习与补足。 初始化 1 2 3 4 5 6 7 8 9 10 11 void __init arp_init(void) { neigh_table_init(NEIGH_ARP_TABLE, &amp;amp;arp_tbl); dev_add_pack(&amp;amp;arp_packet_type); arp_proc_init(); #ifdef</description></item><item><title>DRM框架分析（四）：Atomic KMS</title><link>/post/drm-atomic-kms/</link><pubDate>Wed, 31 Mar 2021 00:00:00 +0000</pubDate><guid>/post/drm-atomic-kms/</guid><description>首先Atomic Mode Setting（后续简称A-KMS）是DRM子系统最近的一次比较大的改动，其目的是填补当前API的不足。由于原先的API不</description></item><item><title>DRM框架分析（一）：简介</title><link>/post/drm-intro/</link><pubDate>Sun, 28 Mar 2021 00:00:00 +0000</pubDate><guid>/post/drm-intro/</guid><description>真的没有想到真的有人能看到这篇东西，所以我准备抽出时间把这个东西整理完。本文是我阅读内核DRM子系统的一些随笔，其目的是记录我对内核代码的阅</description></item><item><title>DRM框架分析（三）：显存管理</title><link>/post/drm-vram/</link><pubDate>Sun, 28 Mar 2021 00:00:00 +0000</pubDate><guid>/post/drm-vram/</guid><description>GEM GEM与TTM之间的关系 TTM是内核最初的DRM显存管理器，其设计思想是试图为所有的显卡驱动提供一个公共的API。TTM后面被认为是失败的</description></item><item><title>DRM框架分析（二）：KMS</title><link>/post/drm-legacy-kms/</link><pubDate>Fri, 26 Mar 2021 00:00:00 +0000</pubDate><guid>/post/drm-legacy-kms/</guid><description>KMS全称是Kernel Mode Setting，这里的mode是指显示控制器的mode，详见下面对drm_mode的分析。与KMS相对应的是Use</description></item><item><title>路线指引</title><link>/post/roadmap/</link><pubDate>Tue, 16 Mar 2021 00:00:00 +0000</pubDate><guid>/post/roadmap/</guid><description>今天和大佬面谈，收获非常大。我觉得我有必要立即记录下来，形成日后的学习路线。首先大佬指出了我自身的不足： 没有做自己的东西。也就是说，我所有的</description></item><item><title>Linux内核组播包接收流程分析</title><link>/post/multicast/</link><pubDate>Mon, 08 Mar 2021 00:00:00 +0000</pubDate><guid>/post/multicast/</guid><description>本文直接分析组播接收的流程细节。由于工作需要，暂且分析2.6.32内核的相关细节，并将分析文档记录于此。 驱动层 TCP/IP协议栈是典型的ti</description></item><item><title>Clutter代码分析</title><link>/post/clutter/</link><pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate><guid>/post/clutter/</guid><description>本文尝试分析Clutter代码实现，其目的是获取调试Mutter代码bug的能力。Clutter的基本知识可以从网络获取，后面会贴一些基础文</description></item><item><title>Mutter实现分析：Atomic Modesetting</title><link>/post/mutter-a-kms/</link><pubDate>Tue, 29 Sep 2020 00:00:00 +0000</pubDate><guid>/post/mutter-a-kms/</guid><description>首先注意一个名字上的区分，一开始看代码的人可能会对命名有疑惑。在Jonas的设计中，整个KMS相关代码分为两个上下文：main和impl。m</description></item><item><title>Mutter窗口管理器实现分析</title><link>/post/mutter/</link><pubDate>Sun, 27 Sep 2020 00:00:00 +0000</pubDate><guid>/post/mutter/</guid><description>本文是我对理解Mutter运行机制以及Linux的DRM子系统的一次尝试。之前的尝试似乎由于种种原因没有进行下去，而我最近深受GNOME下各</description></item><item><title>Linux内核在RISC-V架构下的内存屏障与原子操作</title><link>/post/riscv-atomic-barrier-bitops/</link><pubDate>Fri, 14 Aug 2020 00:00:00 +0000</pubDate><guid>/post/riscv-atomic-barrier-bitops/</guid><description>内存一致性模型是一个体系结构中至关重要的一部分，本质上为软件与硬件之间的契约。软件开发人员可以从内存一致性模型中得知硬件进行内存操作时可能的</description></item><item><title>Linux内核在RISC-V架构下的setup_arch与异常处理</title><link>/post/riscv-setup-arch-exception/</link><pubDate>Wed, 05 Aug 2020 00:00:00 +0000</pubDate><guid>/post/riscv-setup-arch-exception/</guid><description>在分析完Linux内核在RISC-V架构下的启动流程后，我们分析Linux下与RISC-V相关的架构相关实现。很明显，这类知识都是非常零散的</description></item><item><title>Linux内核在RISC-V架构下的构建与启动</title><link>/post/riscv-build-and-boot/</link><pubDate>Sat, 25 Jul 2020 00:00:00 +0000</pubDate><guid>/post/riscv-build-and-boot/</guid><description>本文分析RISC-V的linux移植是如何完成的，并给出具体的入手方法，希望对后来者有所启发。RISC-V是一个比较新的体系结构，截至目前已</description></item><item><title>TTM内存分配器分析</title><link>/post/ttm/</link><pubDate>Sun, 26 Apr 2020 00:00:00 +0000</pubDate><guid>/post/ttm/</guid><description>TTM 本文结合QXL内的实现分析内核DRM框架中提供的TTM内存管理器。 BO BO是Buffer Object的缩写，与Buffer是有区别的。个人理</description></item><item><title>SMMU内核驱动分析</title><link>/post/smmu/</link><pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate><guid>/post/smmu/</guid><description>IOMMU核心框架层 IOMMU核心框架是管理IOMMU设备的一个通用框架，IOMMU设备通过实现特定的回调函数并将自身注册到IOMMU核心框</description></item><item><title>PCI驱动框架分析</title><link>/post/pci/</link><pubDate>Wed, 19 Feb 2020 00:00:00 +0000</pubDate><guid>/post/pci/</guid><description>PCI 分析流程： 硬件文档 PCI框架核心层 PCI框架热插拔 vfio iommu vfio接口层与用户态使用cloud-hypervisor 一共十一万行代码。 从ACP</description></item><item><title>kdump工作机制分析</title><link>/post/kdump/</link><pubDate>Fri, 22 Nov 2019 00:00:00 +0000</pubDate><guid>/post/kdump/</guid><description>kdumpctl kdumpctl是一个shell脚本，用于查看当前kdump的状态和进行kdump相关操作。kdumpctl的入口是main函数，从中可以</description></item><item><title>Linux设备模型：bus与driver</title><link>/post/bus-and-driver/</link><pubDate>Sat, 28 Apr 2018 00:00:00 +0000</pubDate><guid>/post/bus-and-driver/</guid><description>bus &amp;amp; driver bus core的实现在driver/base/bus.c中，初始化过程由buses_init函数实现，函数中创建了两个kset：bus_k</description></item><item><title>Linux设备模型：kobject与uevent</title><link>/post/kobject-and-uevent/</link><pubDate>Sat, 28 Apr 2018 00:00:00 +0000</pubDate><guid>/post/kobject-and-uevent/</guid><description>kobject 1 2 3 4 5 6 7 struct kobj_type { void (*release)(struct kobject *kobj); const struct sysfs_ops *sysfs_ops; struct attribute **default_attrs; const struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj); const void *(*namespace)(struct kobject *kobj); }; 1 2 3 4 5 6 7 8 struct kobj_ns_type_operations { enum kobj_ns_type type; bool (*current_may_mount)(void); void *(*grab_current_ns)(void); const void *(*netlink_ns)(struct sock *sk); const void *(*initial_ns)(void); void (*drop_ns)(void *); }; 1 2 3 4 5 6</description></item><item><title>USB Hub驱动分析</title><link>/post/usb-hub/</link><pubDate>Tue, 27 Feb 2018 00:00:00 +0000</pubDate><guid>/post/usb-hub/</guid><description>USB hub框架分析 USB hub框架是usbcore模块里的一个大头5000行代码（5分之一）。同时，USB hub本身在USB协议中又是一个非常重要</description></item><item><title>inode权限检查</title><link>/post/inode-permission/</link><pubDate>Sun, 07 Jan 2018 00:00:00 +0000</pubDate><guid>/post/inode-permission/</guid><description>inode_permission函数 inode_permission函数用于对inode进行权限检查，我们传给其一个mask参数，这个参数是</description></item><item><title>eventfd在内核中的实现</title><link>/post/eventfd/</link><pubDate>Tue, 19 Dec 2017 00:00:00 +0000</pubDate><guid>/post/eventfd/</guid><description>eventfd是一个利用匿名文件描述符实现“等待/通知”通信机制的一种方式。它比较方便的一点是，eventfd不仅可以实现用户态与用户态之间</description></item><item><title>Floyd循环检测算法</title><link>/post/floyd-cycle-detection/</link><pubDate>Mon, 25 Apr 2016 00:00:00 +0000</pubDate><guid>/post/floyd-cycle-detection/</guid><description>循环检测问题 在研究抽象代数的时候，很多教材都是从欧拉研究的循环群入手的，比如这本《Advanced Modern Algebra》。 当然，直接讨论数学有些</description></item></channel></rss>