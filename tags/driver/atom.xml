<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>crab2313&#x27;s blog - driver</title>
	<link href="https://crab2313.github.io/tags/driver/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://crab2313.github.io"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2018-04-28T00:00:00+00:00</updated>
	<id>https://crab2313.github.io/tags/driver/atom.xml</id>
	<entry xml:lang="en">
		<title>Linux设备模型：bus与driver</title>
		<published>2018-04-28T00:00:00+00:00</published>
		<updated>2018-04-28T00:00:00+00:00</updated>
		<link href="https://crab2313.github.io/bus-and-driver/" type="text/html"/>
		<id>https://crab2313.github.io/bus-and-driver/</id>
		<content type="html">&lt;h1 id=&quot;bus-driver&quot;&gt;bus &amp;amp; driver&lt;&#x2F;h1&gt;
&lt;p&gt;bus core的实现在&lt;code&gt;driver&#x2F;base&#x2F;bus.c&lt;&#x2F;code&gt;中，初始化过程由buses_init函数实现，函数中创建了两个kset：bus_kset（name为bus）和system_kset（name为system）。初始化过程这么简单的话bus注册的工作应该就会比较复杂了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;subsys-private&quot;&gt;subsys_private&lt;&#x2F;h2&gt;
&lt;p&gt;为了隐藏bus core内部的状态，每个bus_type都保存一个指向subsys_private结构体的指针，这个数据结构只能由bus core中进行操作。其中subsys即为表示该bus的kset，subsys中还将放置另外两个kset，即结构体中的devices_kset和drivers_kset，很明显这两个kset用于存放驱动和设备。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;subsys_private {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kset subsys;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kset *devices_kset;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; list_head interfaces;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; mutex mutex;

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kset *drivers_kset;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; klist klist_devices;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; klist klist_drivers;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; blocking_notifier_head bus_notifier;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drivers_autoprobe:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;bus_type *bus;

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kset glue_dirs;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;class *class;
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;bus-register&quot;&gt;bus_register&lt;&#x2F;h2&gt;
&lt;p&gt;这个函数应该是bus core最广为人知的入口了，可以将一个bus_type注册到内核的bus子系统中。抛开大部分内存申请等常规初始化过程不谈，函数中首先创建了一个subsys_private对象，并将其的指针保存到bus-&amp;gt;p中。随即将bus-&amp;gt;p-&amp;gt;kobj的name设置为bus-&amp;gt;name，并将这个kset加入到前面提到的bus_kset中。顺便一提表示一个bus的kset使用bus_ktype作为其类型，后面详细说明。&lt;&#x2F;p&gt;
&lt;p&gt;接下来函数调用kset_create_and_add创建devices_kset和drivers_kset，并将其加入表示bus的kset。在做完以上工作后，函数向表示该bus的kset中加入了三个属性：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;uevent&lt;&#x2F;li&gt;
&lt;li&gt;drivers_autoprobe&lt;&#x2F;li&gt;
&lt;li&gt;drivers_probe&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;而传入bus_register的bus_type-&amp;gt;bus_group也会被当作attribue_group注册到bus对应的sysfs文件夹中。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;busde-san-ge-shu-xing&quot;&gt;bus的三个属性&lt;&#x2F;h2&gt;
&lt;p&gt;前面提到表示bus的kset中加入了三个属性，这里列出他们的定义：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;BUS_ATTR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(uevent, S_IWUSR, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, bus_uevent_store);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;BUS_ATTR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(drivers_probe, S_IWUSR, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, store_drivers_probe);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;BUS_ATTR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(drivers_autoprobe, S_IWUSR | S_IRUGO,
                show_drivers_autoprobe, store_drivers_autoprobe);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这三个属性会作为文件存在于sysfs中。首先drivers_autoprobe是比较好理解的，subsystem_private中保存了一个drivers_autoprobe值，如果为true则进行驱动与设备的自动匹配。向sysfs中一个bus对应文件夹下的drivers_autoprobe写入1或者0则可以改变它的值。&lt;&#x2F;p&gt;
&lt;p&gt;uevent则作为一个调试uevent的接口，通过向该文件写入对应的信息，内核可以调用kobject_synth_uevent函数生成对应的uevent事件。可以直接使用echo进行该操作，而写入字符串的格式如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ACTION [UUID] [KEY1=VALUE1] [KEY2=VALUE2] ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里写入的环境变量会以SYNTH_ARG_KEY=VALUE的形式出现在uevent信息中。最后一个drivers_probe属性可以让总线重新为一个没有匹配到驱动的设备进行驱动匹配。将想要进行匹配的设备名写入到drivers_probe即可进行该操作。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;subsys-system-register&quot;&gt;subsys_system_register&lt;&#x2F;h2&gt;
&lt;p&gt;文档里说这个接口不要在新代码中用，接口本身只做兼容性用途。前面提到了一个system_ket，这里需要提一下它是如何初始化的：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        system_kset = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kset_create_and_add&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;system&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &amp;amp;devices_kset-&amp;gt;kobj);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以猜到devices_kset应该&lt;code&gt;&#x2F;sys&#x2F;devices&lt;&#x2F;code&gt;文件夹，也就是说system_ket的路径为&lt;code&gt;&#x2F;sys&#x2F;devices&#x2F;system&lt;&#x2F;code&gt;。首先函数注册了一个假设备，名字与传入的bus_type一致，然后将这个设备的parent设置成system_kset.kobj，并将bus_type-&amp;gt;dev_root设置刚才注册的那个假设备。总线新注册设备时会将其parent设置成dev_root，因此使用subsys_system_register函数注册的总线（子系统）会被放到&lt;code&gt;&#x2F;sys&#x2F;devices&#x2F;system&#x2F;&amp;lt;bus-name&amp;gt;&#x2F;&lt;&#x2F;code&gt;底下。我们常见的子系统有clocksource，cpu，memory等等。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bustong-zhi-ji-zhi&quot;&gt;bus通知机制&lt;&#x2F;h2&gt;
&lt;p&gt;subsys_private中有一个bus_notifier，他是一个blocking_notifier。内核各个子系统之间为了高效进行信息传递使用注册监听机制，称作notifier。这里使用的是blocking_notifier，其特点是发送事件是可以阻塞。当然，bus core负责事件的发送，所以我们最多进行事件的监听。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bus-add-device&quot;&gt;bus_add_device&lt;&#x2F;h2&gt;
&lt;p&gt;一个bus从逻辑上来讲是要管理设备和驱动的，所以应该提供对应的接口将总线或者驱动加入到bus中来。但是事实上，bus_add_device并没有被export出来，也就是说内核模块是不能调用这个函数的。&lt;&#x2F;p&gt;
&lt;p&gt;每个设备在创建时都应将其bus指针设置成其对应的bus_type，所以函数第一步做的就是将其bus_type取出来。接下来所作大部分是sysfs相关的处理：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;调用device_add_groups将bus-&amp;gt;dev_groups加入到设备中去，翻译成白话就是在设备对应的sysfs文件夹中加入总线自己定义的一些属性。&lt;&#x2F;li&gt;
&lt;li&gt;调用sysfs_create_link创建从设备到bus-&amp;gt;p-&amp;gt;devices_kset的符号连接，也就是在sysfs中建立从设备文件夹到bus&#x2F;devices文件夹下的符号连接。&lt;&#x2F;li&gt;
&lt;li&gt;调用sysfs_create_link在设备文件夹内创建一个名为subsystem的符号连接，该链接指向bus文件夹。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;最后将设备挂入bus维护的设备列表中。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bus-add-driver&quot;&gt;bus_add_driver&lt;&#x2F;h2&gt;
&lt;p&gt;类似于device，driver也有一个bus指针指向它应该属于的bus_type。传进来的device_driver本身没有kobject，bus_add_driver会创建一个嵌入了kobject的driver_private结构体并将其保存在device_driver中。很明显，这个被创建的kobject的kset指针需要被设置成bus-&amp;gt;p-&amp;gt;drivers_kset，即其注册入sysfs时会被放入&lt;code&gt;&#x2F;sys&#x2F;bus&#x2F;&amp;lt;bus-name&amp;gt;&#x2F;drivers&#x2F;&lt;&#x2F;code&gt;文件夹中。&lt;&#x2F;p&gt;
&lt;p&gt;如果bus的drivers_autoprobe为true，则bus_add_driver会尝试进行设备匹配。与bus设备一样，driver也被加入了uevent属性，也就是driver对应的文件夹下也有uevent文件，向其写人对应的命令也能触发uevent事件。类似于device，bus-&amp;gt;drv_groups保存的attribute_group向该bus中的driver追加了bus预先设置好的属性。&lt;&#x2F;p&gt;
&lt;p&gt;如果device_driver里的suppress_bind_attrs不为true，则bus_add_driver应该向其追加两个属性：bind和unbind。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;DRIVER_ATTR_WO&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(unbind);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;DRIVER_ATTR_WO&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(bind);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个文件的作用是相反的：将设备名写入在一个driver文件夹下的unbind文件时，会使driver释放掉该设备，bind文件则会使driver试图匹配该设备。最后可以看一下这一行：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;module_add_driver&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(drv-&amp;gt;owner, drv);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;该函数的主要作用为更新引用计数，并创建两个符号链接：driver文件夹下的module，&lt;code&gt;&amp;lt;module&amp;gt;&#x2F;drivers&#x2F;&lt;&#x2F;code&gt;文件夹下的driver。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;driver-register&quot;&gt;driver_register&lt;&#x2F;h2&gt;
&lt;p&gt;这个函数其实没有做什么事情，大部分工作都由bus承担了。函数首先调用driver_find查找bus上是否已经有了同名驱动，如果有则报错退出。接下来调用bus_add_driver将其注册到bus中去。如果device_driver-&amp;gt;groups不为NULL，则将其添加到自身的属性中。最后触发一个ADD类型的uevent事件。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Linux设备模型：kobject与uevent</title>
		<published>2018-04-28T00:00:00+00:00</published>
		<updated>2018-04-28T00:00:00+00:00</updated>
		<link href="https://crab2313.github.io/kobject-and-uevent/" type="text/html"/>
		<id>https://crab2313.github.io/kobject-and-uevent/</id>
		<content type="html">&lt;h1 id=&quot;kobject&quot;&gt;kobject&lt;&#x2F;h1&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kobj_type {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*release)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kobject *kobj);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;sysfs_ops *sysfs_ops;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;attribute **default_attrs;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kobj_ns_type_operations *(*child_ns_type)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kobject *kobj);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*(*namespace)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kobject *kobj);
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kobj_ns_type_operations {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;enum&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kobj_ns_type type;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*current_may_mount)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*(*grab_current_ns)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*(*netlink_ns)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; sock *sk);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*(*initial_ns)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*drop_ns)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*);
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kobject {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const char              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*name;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; list_head        entry;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kobject          *parent;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kset             *kset;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kobj_type        *ktype;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kernfs_node      *sd; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* sysfs directory entry *&#x2F;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kref             kref;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#ifdef&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; CONFIG_DEBUG_KOBJECT_RELEASE
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; delayed_work     release;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#endif
        unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; state_initialized:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; state_in_sysfs:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; state_add_uevent_sent:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; state_remove_uevent_sent:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; uevent_suppress:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;kobject-init&quot;&gt;kobject_init&lt;&#x2F;h2&gt;
&lt;p&gt;初始化时必须传入一个ktype参数，否则无法成功初始化，这个是必然的，每个嵌入kobject的结构体必须在引用计数变为0的时候必须使用ktype中保存的release函数指针进行销毁。kobj中保存了一个state_initialized字段，用以标记该kobject是初始化过的，从这里也能看出申请完kobject结构体之后必须将其全部写零。接下来初始化kobj-&amp;gt;kref作为引用计数，初始化kobj-&amp;gt;entry（这个list_head用于将kobject保存到一个kset中）。最后可以看到kobject还有三个字段用于标记其状态：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;state_in_sysfs&lt;&#x2F;li&gt;
&lt;li&gt;state_add_uevent_sent&lt;&#x2F;li&gt;
&lt;li&gt;state_remove_uevent_sent&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;从名字中即可看出其表示的含义，后两个状态表示对应的uevent事件是否已经发送给用户态。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;kobject-add&quot;&gt;kobject_add&lt;&#x2F;h2&gt;
&lt;p&gt;函数首先检查state_initialized字段，即kobject是否已经通过kobject_init进行初始化。随后设置kobject的name和parent，并确认name不为空。该函数用于将kobject注册到内核中，如果kobject的kset字段已经被设置，则将这个kobject加入到那个kset中。函数最后调用create_dir函数创建kobject对应于sysfs中的文件夹，如果创建成功，则将state_in_sysfs设置为1。&lt;&#x2F;p&gt;
&lt;p&gt;随后来看create_dir函数，首先可以看到函数开头调用了kobject_namespace函数，从这里立即可以看出kobject是namespace-aware的。kboject_namespace的实现如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;kobject_namespace&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kobject *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kobj&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kobj_ns_type_operations *ns_ops = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kobj_ns_ops&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(kobj);

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(!ns_ops || ns_ops-&amp;gt;type == KOBJ_NS_TYPE_NONE)
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kobj-&amp;gt;ktype-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;namespace&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(kobj);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;也就是说，如果kset的kobj_type中的kobj_ns_type_operations-&amp;gt;type不为KOBJ_NS_TYPE_NONE（目前应该只有一个KOB_NS_TYPE_NET）的话就用kobject-&amp;gt;kobj_type中的namespace回调函数给出的namespace标签创建sysfs中对应的文件夹：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        error = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sysfs_create_dir_ns&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(kobj, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kobject_namespace&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(kobj));
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;并利用kobject-&amp;gt;kobj_type-&amp;gt;attributes中保存的属性创建文件夹中的文件，这里具体的实现需要参考sysfs文件系统的实现。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;kobject-get-path&quot;&gt;kobject_get_path&lt;&#x2F;h2&gt;
&lt;p&gt;很明显该函数返回该kobject的path，从代码中可以看出path是指在该kobject所在的树形结构中，从该kobject到树的根节点所经过的路径。函数实现比较简单，首先是遍历一遍树到根结点，计算出整个字符串所占用的空间。然后申请这个字符串，然后再次向上遍历树至根结点，依次从后向前填充每个kobject节点的名字，并以斜杠（“&#x2F;”）作为间隔。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;kobject-release&quot;&gt;kobject_release&lt;&#x2F;h2&gt;
&lt;p&gt;该函数将kobject所占用的系统资源删除。需要注意的是，这个函数并不仅仅释放kboject占用的内存，而是释放嵌入kobject的结构体占用的内存和系统资源。每个kobject的kobj_type-&amp;gt;release不能为NULL，否则kobject的无法在其以用计数为0时释放内存。然后函数首先检查state_add_uevent_sent是否为true，如果是则调用kobject_uevent发送其对应的REMOVE事件到用户态。如果state_in_sysfs为true，则表示该kobject还在sysfs中显示，需要调用kobject_del函数将其从树形结构中删除。最后调用release函数指针将被嵌入这个kobject的结构体删除，当然，不能忘记释放name占用的内存。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;kobject-create&quot;&gt;kobject_create&lt;&#x2F;h2&gt;
&lt;p&gt;该函数创建并初始化一个“动态”的kobject结构体对象。之所以说是动态的，是因为它们没有被嵌入到别的结构体中，而时独立存在的。所以kobject_create在创建kobject之后，给其了一个默认的release函数，即释放kobject本身所占用的内存。kobject_object创建的kobject对象是匿名的，且使用如下的kobj_type：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kobj_type dynamic_kobj_ktype = {
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;release        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= dynamic_kobj_release,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sysfs_ops      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &amp;amp;kobj_sysfs_ops,
};

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;dynamic_kobj_release&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kobject *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kobj&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pr_debug&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;kobject: (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%p&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;): &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, kobj, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;__func__&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kfree&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(kobj);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h1 id=&quot;uevent&quot;&gt;uevent&lt;&#x2F;h1&gt;
&lt;p&gt;uevent的实现可以在&lt;code&gt;lib&#x2F;kobject_uevent.c&lt;&#x2F;code&gt;文件中找到。我们首先注意到的是uevent依赖于网络子系统，如果内核没有开启CONFIG_NET选项，则uevent的很多功能都会受到影响。同时也能猜到uevent是namepsace-aware的，由于uevent依赖于netlink套接字向用户态发送uevent事件，所以每个net namespace都可以有自己独立的uevent事件。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ueventyu-netlink&quot;&gt;uevent与netlink&lt;&#x2F;h2&gt;
&lt;p&gt;uevent使用netlink套接字向用户态发送信息，而netlink是namespace-aware的，所以uevent的初始化必须对每个net namespace区分对待。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; pernet_operations uevent_net_ops = {
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;init   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= uevent_net_init,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;exit   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= uevent_net_exit,
};

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; __init &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;kobject_uevent_init&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;register_pernet_subsys&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;uevent_net_ops);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;register_pernet_subsys是注册net namespace初始化函数的标准方式，每当新的net namespace创建或者销毁的时候，这注册的函数指针就会执行。由于每个net namespace的netlink套接子都是相互独立的，uevent_net_init负责在每个net namepsace中注册对应的netlink套接字，并将其保存在一个列表中。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;uevent_sock {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; list_head list;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;sock *sk;
};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;LIST_HEAD&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(uevent_sock_list);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;ueventshi-jian-lei-xing&quot;&gt;uevent事件类型&lt;&#x2F;h2&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static const char &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*kobject_actions[] = {
        [KOBJ_ADD] =            &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;add&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
        [KOBJ_REMOVE] =         &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;remove&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
        [KOBJ_CHANGE] =         &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;change&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
        [KOBJ_MOVE] =           &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;move&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
        [KOBJ_ONLINE] =         &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;online&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
        [KOBJ_OFFLINE] =        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;offline&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
        [KOBJ_BIND] =           &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bind&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
        [KOBJ_UNBIND] =         &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;unbind&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;TODO: 从内核设备框架中找到以上事件类型的具体含义和触发方式&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ueventshi-jian-de-chuang-jian&quot;&gt;uevent事件的创建&lt;&#x2F;h2&gt;
&lt;p&gt;uevent事件包括以下三个信息：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;DEVPATH，即设备路径。该设备路径采用前面提到的kobject_get_path函数创建。&lt;&#x2F;li&gt;
&lt;li&gt;ACTION，即uevent事件表示的行为，如设备增加，设备删除等等。&lt;&#x2F;li&gt;
&lt;li&gt;环境变量，类似于进程的环境变量，用于携带其他额外的信息。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;uevent事件的创建由kobject_uevent_env的前半段完成，这里所说的创建是指收集向用户态发送uevent事件所需的全部信息这一过程。前面提到DEVPATH是由kobject_get_path函数从kobject树中创建，而显然ACTION应该是触发uevent事件代码段传入的参数，所以我们只需要看看环境变量是如何生成的。&lt;&#x2F;p&gt;
&lt;p&gt;从代码中直接可以看到每个uevent事件默认携带四个环境变量：ACTION，DEVPATH，SEQNUM和SUBSYSTEM。前面三个顾名思义，SUBSYSTEM比较费解。简而言之，SUBSYSTEM变量是事件目标kobject从kobject树向根结点方向找到的第一个kset的名字。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        top_kobj = kobj;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(!top_kobj-&amp;gt;kset &amp;amp;&amp;amp; top_kobj-&amp;gt;parent)
                top_kobj = top_kobj-&amp;gt;parent;

        kset = top_kobj-&amp;gt;kset;
        uevent_ops = kset-&amp;gt;uevent_ops;

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(uevent_ops &amp;amp;&amp;amp; uevent_ops-&amp;gt;name)
                subsystem = uevent_ops-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(kset, kobj);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;                subsystem = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kobject_name&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;kset-&amp;gt;kobj);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;也就是说内核默认将kset当作一个子系统中看待，kset中可以包含kset，也就是子系统中可以包含另一个子系统。还有一点比较有意思的是内核使用一个单独的uevent_seqnum作为uevent事件的序列号，使用uevent_sock_mutex互斥锁保护这一变量，这告诉我们以下两点：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;从用户态的视角来看，uevent事件的序列号并不是每次都加一的。这是因为uevent是namespace-aware的，并不是所有namespace都会收到。很明显这里说的是net namespace，一个net namespace下的进程并不能看到其他net namespace下的网卡，更不应该收到对应的uevent事件。&lt;&#x2F;li&gt;
&lt;li&gt;kobject_uevent和kobject_uevent_env函数必须在进程上下文调用，因为其内部使用了mutex。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;除了标准的环境变量之外，kobject_uevent_env还接收一个env_ext参数作为其他额外的环境变量。除此之外，kset（也就是kobject所属的SUBSYSTEM）中注册的uevent_ops-&amp;gt;uevent回调函数也可以添加自己的环境变量。函数会去掉UNBIND事件中的MODALIAS变量。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ueventshi-jian-de-fa-song&quot;&gt;uevent事件的发送&lt;&#x2F;h2&gt;
&lt;p&gt;kobject_uevent_env前半段收集完所有所需信息之后，将发送工作交由kobject_uevent_net_broadcast进行。这里首先列举以下kobject_uevent_env中会阻止uevent事件发送的几种情况：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;前面提到的SUBSYSTEM变量没找到，也就是触发uevent事件的kobject没有包含在任何一个kset中，这种情况视为错误，并返回EINVAL。&lt;&#x2F;li&gt;
&lt;li&gt;kobject-&amp;gt;suppress为true，表示这个kobject不应该触发任何uevent事件。&lt;&#x2F;li&gt;
&lt;li&gt;kset中注册的uevent_ops-&amp;gt;filter函数过滤掉了该kobject。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;kobject_uevent_net_broadcast正如你想的一样，向除了kobject所在的net namespace发送uevent事件，如果kobject没有关联的net namespace，则向全体发送。netlink套接字所用的skb_buff按照如下方法构造：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;                        size_t len = strlen(action_string) + strlen(devpath) + 2;
                        char *scratch;

                        skb = alloc_skb(len + env-&amp;gt;buflen, GFP_KERNEL);

                        scratch = skb_put(skb, len);
                        sprintf(scratch, &amp;quot;%s@%s&amp;quot;, action_string, devpath);

                        skb_put_data(skb, env-&amp;gt;buf, env-&amp;gt;buflen);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;因此，用户态收到的数据为如下形式：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ACTION@DEVPATH\0
ENV1=VALUE2\0
ENV2=VALUE2\0
......
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;</content>
	</entry>
	<entry xml:lang="en">
		<title>USB Hub驱动分析</title>
		<published>2018-02-27T00:00:00+00:00</published>
		<updated>2018-02-27T00:00:00+00:00</updated>
		<link href="https://crab2313.github.io/usb-hub/" type="text/html"/>
		<id>https://crab2313.github.io/usb-hub/</id>
		<content type="html">&lt;h1 id=&quot;usb-hubkuang-jia-fen-xi&quot;&gt;USB hub框架分析&lt;&#x2F;h1&gt;
&lt;p&gt;USB hub框架是usbcore模块里的一个大头5000行代码（5分之一）。同时，USB hub本身在USB协议中又是一个非常重要的组成部分，直接关系到USB的核心功能。理解USB hub框架对于理解usbcore模块至关重要。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;chu-shi-hua&quot;&gt;初始化&lt;&#x2F;h2&gt;
&lt;p&gt;USB hub框架随着USB子系统一起初始化，usb_init函数中直接调用usb_hub_init函数。usb_hub_init函数中只进行了两件事：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;注册hub_driver&lt;&#x2F;li&gt;
&lt;li&gt;申请一个名为hub_wq的workqueue&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;与usb_hub_init函数对应的usb_hub_cleanup函数做了相反的事情。在USB协议中，USB hub也是一个USB设备，也提供了所有USB设备都会提供的通用请求，除此之外也提供了Hub特定的请求。因此，自然而然应该将Hub看作普通USB设备，并提供对应的USB驱动，这样做可以简化实现。可以看到内核中也是这么做的：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; usb_driver hub_driver = {
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;=         &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;hub&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;probe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;=        hub_probe,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;disconnect &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;=   hub_disconnect,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;suspend &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;=      hub_suspend,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;resume &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;=       hub_resume,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;reset_resume &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= hub_reset_resume,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pre_reset &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;=    hub_pre_reset,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;post_reset &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;=   hub_post_reset,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;unlocked_ioctl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= hub_ioctl,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;id_table &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;=     hub_id_table,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;supports_autosuspend &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;hub_id_table中匹配了bDeviceClass或者bInterfaceClass为USB_CLASS_HUB的设备或者接口。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hub-irq&quot;&gt;hub_irq&lt;&#x2F;h2&gt;
&lt;p&gt;前面提到Hub初始化之后会激活对Status Change Endpoint的轮询操作，为此usb_hub-&amp;gt;urb指针保存了一个Interrupt类型的URB，并将其处理函数设置为hub_irq。也就是说，hub_irq函数的作用是处理该轮询结果。从协议中可以得知，每次轮询成功时返回的数据是一个记录着Hub及Hub上的所有Port状态改变的Bitmap。hub_irq的实现比较简单，主要流程如下：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;每次出现错误状态时增加错误计数器usb_hub-&amp;gt;nerror。计数器超过10之后，设置usb_hub-&amp;gt;error，清零错误计数器，并调用kick_hub_wq。&lt;&#x2F;li&gt;
&lt;li&gt;如果没有错误，则清零错误计数器，然后调用kick_hub_wq&lt;&#x2F;li&gt;
&lt;li&gt;如果usb_hub-&amp;gt;quiescing不为真，则重新提交该URB&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;事实上一旦usb_hub-&amp;gt;error不为0，则kick_hub_wq后续触发的hub_event函数中会对该Hub进行重置操作。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hub-event&quot;&gt;hub_event&lt;&#x2F;h2&gt;
&lt;p&gt;旧的内核中使用一个内核线程轮询读取Hub的状态，而新的内核中换成了前面提到的名为hub_wq的workqueue，该workqueue在USB子系统初始化的时候创建。内核使用hub_event函数轮询Hub的状态，为了向该函数传入参数，每个usb_hub结构体内都嵌入了work_struct（名为events），通过container_of获取对应的usb_hub。&lt;&#x2F;p&gt;
&lt;p&gt;该函数在做完简单的错误处理之后开始枚举PORT状态，枚举机制可以参考USB2.0协议文档中的11.12.3章节。简而言之，驱动程序在轮询Hub的Status Change Endpoint过程中，如果获取到有状态更新事件，那么就会调用kick_hub_wq函数将usb_hub-&amp;gt;events加入到hub_wq中。同一时刻只有一个usb_hub的events能放到hub_wq中，这跟Hub设备的事件通知机制有关，驱动在获取到Hub的事件更新之后，必须手动清除掉一个事件的状态更改位，已使Hub设备不再报告相同的事件。也就是说，没有处理完的事件在下次轮询的时候依然存在。&lt;&#x2F;p&gt;
&lt;p&gt;很显然根据Hub的规范，hub_event函数需要做的就是从Default Control Pipe中调用对应的请求获取Hub或者Port的状态信息，并清除对应的状态位。函数中当然不可能轮询所有的Port和Hub状态，这样做效率太低。事实上，每次轮询Status Change的时候，返回的数据是一个Bitmap，其中第0位置1表示Hub本生状态发生了改变，而后续的第n位置1表示第n个Port的状态发生了改变。如果你阅读Hub规范，则会发现hub_event函数承担的责任并仅仅是处理硬件状态的改变，还包括处理软件状态的改变（即软件控制信息的处理）。也就是说，如果内核需要更改Hub的状态，则会修改usb_hub中的状态，并调用kick_hub_wq函数。&lt;&#x2F;p&gt;
&lt;p&gt;从hub_irq函数中可以看到，内核将前面提到的Bitmap保存在usb_hub-&amp;gt;event_bits中，并调用kick_hub_wq。因此，hub_event函数可以通过这个bitmap来判断是否有硬件事件的发生。hub_event中调用port_event处理Port事件：如果一个Port的change_bits、event_bits、wakeup_bits中的对应位任意一位置一，则需要进行处理。port_event函数开头先清除了event_bits和wakeup_bits，看样子这两个标志仅仅起通知的作用。change_bits则被保存了下来，内核通过这一标志表示逻辑连接状态的改变。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        connect_change = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;test_bit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(port1, hub-&amp;gt;change_bits);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;clear_bit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(port1, hub-&amp;gt;event_bits);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;clear_bit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(port1, hub-&amp;gt;wakeup_bits);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;随后函数从Default Control Pipe读取Port相关的信息并进行处理。可以发现内核对大部分信息仅仅是作为调试信息记录下来，然后将其清除掉，已使下一次轮询时不再获取该信息，真正进行处理的信息不多。首先处理的是USB_PORT_STAT_C_CONNECTION，从名字上看得出是连接状态的改变，因此如果这个标志被发现的话意味着物理连接状态的改变，需要将connect_change直接置一。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(portchange &amp;amp; USB_PORT_STAT_C_CONNECTION) {
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;usb_clear_port_feature&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(hdev, port1, USB_PORT_FEAT_C_CONNECTION);
                connect_change = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
        }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其次就是处理远程唤醒和USB3.0的重置操作。最后如果connect_change为1的话（即Port的逻辑或者物理连接状态改变）则调用hub_port_connect_change函数进行处理。&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>
