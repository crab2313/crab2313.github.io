<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>crab2313&#x27;s blog - kernel</title>
	<link href="https://crab2313.github.io/tags/kernel/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://crab2313.github.io"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2021-03-26T00:00:00+00:00</updated>
	<id>https://crab2313.github.io/tags/kernel/atom.xml</id>
	<entry xml:lang="en">
		<title>DRM显示框架分析</title>
		<published>2021-03-26T00:00:00+00:00</published>
		<updated>2021-03-26T00:00:00+00:00</updated>
		<link href="https://crab2313.github.io/drm/" type="text/html"/>
		<id>https://crab2313.github.io/drm/</id>
		<content type="html">&lt;p&gt;真的没有想到真的有人能看到这篇东西，所以我准备抽出时间把这个东西整理完。本文是我阅读内核DRM子系统的一些随笔，其目的是记录我对内核代码的阅读过程和自己的一些理解，希望景嘉微的大佬们多多指正。&lt;&#x2F;p&gt;
&lt;p&gt;接触linux桌面比较多的人一定会对DRM这个名字比较熟悉。网上也有大把资料在解释DRM到底是什么。DRM主要分为KMS与Render两大部分，本文实质上是在分析DRM中KMS相关的框架实现。而Render相关的API是特定于驱动的，内核并不为用户态提供一个通用的IOCTL接口。如果后续时间充足，我将会分析一下VC4的Render API，以及相应的用户态实现。从功能上讲，KMS负责搭建显示控制器的pipeline，并控制显示硬件将图像缓冲区scanout到屏幕上，而如何加速生成framebuffer中的内容则是3D引擎（即Render API）负责的事情。&lt;&#x2F;p&gt;
&lt;p&gt;对于KMS，有如下要素：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;显存管理器&lt;&#x2F;li&gt;
&lt;li&gt;modesetting API&lt;&#x2F;li&gt;
&lt;li&gt;显示API&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;在研究初期，研究案例最好硬件无关，且比较容易懂原理，且能够正常运行，可以参考virtio-gpu和QXL虚拟显卡。等到对内核DRM子系统有一定的理解后，可以分析简单的显卡硬件，如VC4（树莓派3B的显卡）。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;yue-du-lu-jing&quot;&gt;阅读路径&lt;&#x2F;h1&gt;
&lt;p&gt;需要看的东西有点多，甚至说比较乱。先列举一下：&lt;&#x2F;p&gt;
&lt;p&gt;内核中的内容：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;DRM驱动通用代码：包括GEM，KMS&lt;&#x2F;li&gt;
&lt;li&gt;AMD显卡相关的代码：AMDGPU，RADEON，AMDKFD（通用计算ROCM框架内核驱动）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;用户态代码：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;MESA： OpenGL state tracker， gallium 3D， vulkan， egl（重点），gbm&lt;&#x2F;li&gt;
&lt;li&gt;libdrm：基本为内核提供的IOCTL的wrapper&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;我想要重点理解的部分：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;context到底是什么？如OpenGL和egl创建的context&lt;&#x2F;li&gt;
&lt;li&gt;mesa的架构&lt;&#x2F;li&gt;
&lt;li&gt;wayland渲染的基本原理&lt;&#x2F;li&gt;
&lt;li&gt;DRI到底由什么构成&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这里我觉得还是先从MESA这里着手，毕竟内核驱动缺少文档，且我对接口层到底怎么用还是不是很熟悉。看一下简单的DUMB驱动如何实现也是一个理解KMS比较好的方法。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;gem&quot;&gt;GEM&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;gemyu-ttmzhi-jian-de-guan-xi&quot;&gt;GEM与TTM之间的关系&lt;&#x2F;h2&gt;
&lt;p&gt;TTM是内核最初的DRM显存管理器，其设计思想是试图为所有的显卡驱动提供一个公共的API。TTM后面被认为是失败的，其API与实现复杂不可控，没有人愿意用他。后来intel吸取教训，设计了GEM，其设计较为灵活，只提供基本的实现，部分功能需要驱动程序通过驱动自定的接口进行扩展。GEM与TTM在特性上的主要区别为GEM不支持管理独立显存，只支持UMA，而TTM两种都支持。目前的DRM驱动程序中，基本都使用GEM作为前端为用户态提供接口，而涉及到管理独立显存的时候，则借助TTM作为后端实现管理功能。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;kuang-jia-chu-shi-hua&quot;&gt;框架初始化&lt;&#x2F;h2&gt;
&lt;p&gt;驱动程序可以自己选择是否使用GEM框架，如果选择使用，则需要在注册&lt;code&gt;drm_driver&lt;&#x2F;code&gt;到DRM core中时，在&lt;code&gt;driver_features&lt;&#x2F;code&gt;里设置DRIVER_GEM标志。在驱动加载时，DRM框架会自动初始化GEM。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;handleyu-name&quot;&gt;handle与name&lt;&#x2F;h2&gt;
&lt;p&gt;handle是gem_object的引用，其作用域被限制在drm文件描述符内，用于用户态程序引用内核态的drm_gem_object。当drm文件描述符被关闭时，所有的handle都会被关闭。而name则是drm_gem_object的名称，为一个32-bit整数。name的作用域是全局的，因此被直接保存在drm_gem_object内。默认情况下drm_gem_object的name都为0，表示其是未命名的。用户态可以通过FLINK为drm_gem_object命名，之后系统内的其他进程可以通过对应的name对该drm_gem_object进行访问。&lt;&#x2F;p&gt;
&lt;p&gt;handle的创建是创建GEM对象的一个步骤。目前GEM对象的创建一般是通过设备相关的API进行实现的，驱动程序可以通过&lt;code&gt;drm_gem_handle_create&lt;&#x2F;code&gt;函数从对应drm文件中创建一个handle返回给用于态。关于handle，gem core中还提供了&lt;code&gt;drm_gem_handle_delete&lt;&#x2F;code&gt;和&lt;code&gt;drm_gem_handle_lookup&lt;&#x2F;code&gt;函数。事实上，handle的管理是通过idr实现的。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;drm-gem-object&quot;&gt;drm_gem_object&lt;&#x2F;h2&gt;
&lt;p&gt;该对象是GEM内存管理的核心。GEM目前提供的功能是不完全的，部分空缺需要驱动自行填补，因此GEM框架要求驱动在&lt;code&gt;drm_gem_object&lt;&#x2F;code&gt;的基础上实现自己的GEM对象。这个操作实际上就是将&lt;code&gt;drm_gem_object&lt;&#x2F;code&gt;嵌入到驱动自己定义的&lt;code&gt;{driver}_gem_object&lt;&#x2F;code&gt;中。&lt;code&gt;drm_gem_object&lt;&#x2F;code&gt;定义在&lt;code&gt;include&#x2F;drm&#x2F;drm_gem.h&lt;&#x2F;code&gt;中，且有详细的注释，这里不再赘述，重点分析一些字段。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;filp&lt;&#x2F;code&gt;是一个指向&lt;code&gt;struct file&lt;&#x2F;code&gt;的指针，要理解它的作用就必须理解真正的内存是如何分配的。前面提到了GEM只支持UMA，即显卡使用RAM做为显存，这就又涉及到了两种情况。在PC中由于IOMMU的存在，显卡并不强制要求连续的物理内存，因此GEM可以使用SHMFS做为存储后端，此时filp指针就指向对应的文件描述符。而在嵌入式应用场景下，大部分设备没有IOMMU，因此必须要求连续的物理内存，此时filp为NULL，驱动通过CMA申请到连续的物理内存用作存储后端。注意，GEM框架并不负责管理存储后端，只提供了一些基本的helper，而存储的分配与释放完全由驱动程序控制。&lt;&#x2F;p&gt;
&lt;p&gt;TODO： 研究一下SHMFS&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;vma_node&lt;&#x2F;code&gt;简单来说是保存了这个object的mmap偏移量。这里又需要提及&lt;code&gt;drm_gem_object&lt;&#x2F;code&gt;向用户态的映射问题。GEM目前基本上是通过两种方式实现MAP gem_object到用户态的：设备相关IOCTL和基于drm文件描述符的mmap。后者通过一个虚拟的偏移量确定mmap究竟在映射哪一个&lt;code&gt;drm_gem_object&lt;&#x2F;code&gt;。该机制的实现细节需要单独讨论。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;dma_buf&lt;&#x2F;code&gt;字段是一个&lt;code&gt;struct dma_buf&lt;&#x2F;code&gt;类型的字段。这里又设计drm-prime框架的细节了。简单来说，通过name来实现进程间共享&lt;code&gt;drm_gem_object&lt;&#x2F;code&gt;存在显而易见的安全性问题，毕竟name是全局的。攻击者可以通过特定的pattern推测或者枚举&lt;code&gt;drm_gem_object&lt;&#x2F;code&gt;的name，达到窃取数据的目的。后续GEM集成了dma_buf，可以通过dma_buf实现共享。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yong-hu-tai-ying-she&quot;&gt;用户态映射&lt;&#x2F;h2&gt;
&lt;p&gt;用户态映射实质上就是将&lt;code&gt;drm_gem_object&lt;&#x2F;code&gt;描述的存储空间映射到用户态进程的虚拟地址空间，让用户态进程可以随机读写。正如前面提到的，这里只分析GEM提供的方式，即基于drm文件描述符的mmap。我们知道mmap系统调用的原型如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;mmap&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;addr&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, size_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;length&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;prot&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;flags&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;fd&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, off_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;offset&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;); 
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;GEM框架可以为每一个&lt;code&gt;drm_gem_object&lt;&#x2F;code&gt;绑定一个特定虚拟offset，通过offset辨别需要映射到用户态的&lt;code&gt;drm_gem_object&lt;&#x2F;code&gt;。该机制需要drm文件描述符与&lt;code&gt;drm_gem_object&lt;&#x2F;code&gt;的共同协作，前面看到&lt;code&gt;drm_gem_object&lt;&#x2F;code&gt;中提供了vma_node用于保存该信息，驱动程序需要自行调用&lt;code&gt;drm_gem_create_mmap_offset&lt;&#x2F;code&gt;为一个&lt;code&gt;drm_gem_object&lt;&#x2F;code&gt;注册一个虚拟offset。虚拟offset需要通过设备相关的IOCTL传递给用户态。&lt;code&gt;drm_device&lt;&#x2F;code&gt;中存在vma_offset_manager用于统一管理mmap的虚拟offset，其后端基本上为drm_mm与红黑树缓存的组合。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;dumb&quot;&gt;DUMB&lt;&#x2F;h1&gt;
&lt;p&gt;(TODO)&lt;&#x2F;p&gt;
&lt;h1 id=&quot;gbm&quot;&gt;GBM&lt;&#x2F;h1&gt;
&lt;p&gt;前面看到基于GEM的驱动对外是没有提供统一的内存管理接口的，至少Buffer Object创建销毁等操作是需要自行提供设备相关的即口进行实现的。用户态没有统一的接口对缓冲区进行管理，这导致某些特定用户态程序的开发的困难，如wayland compositor。MESA项目提供了libgbm，抽象并实现了一个通用的buffer管理API。这里记录对该API进行的探讨。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;note&quot;&gt;Note&lt;&#x2F;h2&gt;
&lt;p&gt;经过代码分析，gbm实际上来源于MESA内存OpenGL实现的&lt;code&gt;internal&#x2F;drm_interface.h&lt;&#x2F;code&gt;，也就是Mesa OpenGL实现的一个私有兼容层。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gbm-device&quot;&gt;gbm_device&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;code&gt;gbm_device&lt;&#x2F;code&gt;是DRM设备的抽象，管理所有的分配出来的BO（Buffer Object）。自然而然：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;一个&lt;code&gt;gbm_device&lt;&#x2F;code&gt;创建出来的BO的生命周期与该&lt;code&gt;gbm_device&lt;&#x2F;code&gt;绑定&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;gbm_device&lt;&#x2F;code&gt;与特定DRI设备绑定&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;code&gt;gbm_create_device&lt;&#x2F;code&gt;负责从一个DRM设备中创建&lt;code&gt;gbm_device&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; gbm_device* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;gbm_create_device&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;fd&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里的fd自然是打开&lt;code&gt;&#x2F;dev&#x2F;dri&#x2F;card*&lt;&#x2F;code&gt;时的文件描述符。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gbm-bo&quot;&gt;gbm_bo&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;code&gt;gbm_bo_create&lt;&#x2F;code&gt;函数用于创建BO，其原型如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; gbm_bo *
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;gbm_bo_create&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; gbm_device *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;gbm&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
              uint32_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;width&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, uint32_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;height&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
              uint32_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;format&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, uint32_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;flags&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;函数非常简单，只需要指定BO的长宽，格式以及标志（enum gbm_bo_flags）。GBM提供了一些基本的helper用于获取BO的相关属性。除此之外比较重要的操作就是将BO映射到用户态地址空间了：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;gbm_bo_map &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; gbm_bo *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;bo&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, uint32_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, uint32_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;y&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, uint32_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;width&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, uint32_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;height&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, uint32_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;flags&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, uint32_t *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;stride&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;**&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;map_data&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到该函数提供了将BO中的特定二维区域映射到功能。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;kms&quot;&gt;KMS&lt;&#x2F;h1&gt;
&lt;p&gt;主要分为用户态接口的使用，内核提供的框架和通用接口。&lt;&#x2F;p&gt;
&lt;p&gt;KMS将整个显示pipeline抽象成以下几个部分：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;framebuffer&lt;&#x2F;li&gt;
&lt;li&gt;plane&lt;&#x2F;li&gt;
&lt;li&gt;crtc&lt;&#x2F;li&gt;
&lt;li&gt;encoder&lt;&#x2F;li&gt;
&lt;li&gt;connector&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;其中每一个部分的含义可以参考内核文档，这里不赘述，这里只分析其在内核框架中是如何实现的。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dui-xiang-guan-li&quot;&gt;对象管理&lt;&#x2F;h2&gt;
&lt;p&gt;对于这几个对象，DRM框架将其称作“对象”，有一个公共的基类&lt;code&gt;struct drm_mode_object&lt;&#x2F;code&gt;，这个几个对象都由这个基类扩展而来。事实上，这个基类扩展出来的子类并不是只有上面提到的几种。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;drm_mode_object {
  uint32_t id;
  uint32_t type;
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;drm_object_properties *properties;
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kref refcount;
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*free_cb)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kref *kref);
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其中id和type分别为这个对象在KMS子系统中的ID和类型（即上面提到的几种）。注意所有的&lt;code&gt;drm_mode_object&lt;&#x2F;code&gt;的id共用一个namespace，保存在&lt;code&gt;drm_device-&amp;gt;mode_config.object_idr&lt;&#x2F;code&gt;中。因此，框架提供了&lt;code&gt;drm_mode_object_find&lt;&#x2F;code&gt;函数用于查找对应id的对象。当前DRM框架中存在如下的对象类型：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_OBJECT_CRTC &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0xcccccccc
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_OBJECT_CONNECTOR &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0xc0c0c0c0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_OBJECT_ENCODER &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0xe0e0e0e0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_OBJECT_MODE &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0xdededede
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_OBJECT_PROPERTY &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0xb0b0b0b0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_OBJECT_FB &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0xfbfbfbfb
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_OBJECT_BLOB &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0xbbbbbbbb
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_OBJECT_PLANE &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0xeeeeeeee
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_OBJECT_ANY &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;从&lt;code&gt;drm_mode_object&lt;&#x2F;code&gt;的定义中即可发现其实现了两个比较重要的功能：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;引用计数及生命周期管理&lt;&#x2F;li&gt;
&lt;li&gt;属性管理&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;属性在DRM中由&lt;code&gt;struct drm_property&lt;&#x2F;code&gt;表示，其本质是一个&lt;code&gt;DRM_MODE_OBJECT_PROPERTY&lt;&#x2F;code&gt;类型的&lt;code&gt;drm_mode_object&lt;&#x2F;code&gt;。一个&lt;code&gt;drm_mode_object&lt;&#x2F;code&gt;的所有属性保存在其内部的&lt;code&gt;drm_object_properties&lt;&#x2F;code&gt;中，其实现如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;drm_object_properties {
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; count;
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;drm_property *properties[DRM_OBJECT_MAX_PROPERTY];
  uint64_t values[DRM_OBJECT_MAX_PROPERTY];
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到每一个对象最多可以有24个属性。这里注意一个实现细节，&lt;code&gt;drm_property&lt;&#x2F;code&gt;表示一个属性对象，描述属性的类型（如整形，range，浮点数等）、名称和取值范围（约束）。&lt;code&gt;drm_object_properties&lt;&#x2F;code&gt;中的properties保存属性的类型，而&lt;code&gt;values&lt;&#x2F;code&gt;保存对应类型的值。这是因为同一类型的对象基本上都共有特定名称和类型的属性，独立的属性对象使得我们不需要为在每一个对象中都保存同样的属性名称和类型。对象的属性可以通过&lt;code&gt;drm_object_property_*&lt;&#x2F;code&gt;函数操作。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;atomic-mode-setting&quot;&gt;Atomic Mode Setting&lt;&#x2F;h2&gt;
&lt;p&gt;先写一下我的理解，看看到最后读完代码有什么新收获没有。&lt;&#x2F;p&gt;
&lt;p&gt;首先Atomic Mode Setting是DRM子系统最近的一次比较大的改动，其目的是填补当前API的不足。由于原先的API不支持同时更新整个DRM显示pipeline的状态，因此KMS过程中会出现一些中间状态，容易造成开发者不希望看见的结果，影响用户体验。同时，原先的KMS接口也不支持回滚，需要应用程序自己记录原先的配置状态，Atomic Mode Setting也解决了这个问题。&lt;&#x2F;p&gt;
&lt;p&gt;由于Atomic Mode Setting是新出现的API，为了解决用户态程序的兼容性问题，Atomic Mode Setting的接口被隐藏起来，只有用户态程序显式告知DRM层其支持Atomic Mode Setting时它的接口才会暴露出来。目前主流的开源驱动基本都已经迁移到了Atomic Mode Setting接口上了。&lt;&#x2F;p&gt;
&lt;p&gt;Atomic Mode Setting接口在用户态看来，是将原先各个KMS object的状态由隐式的通过API更新，变成了显式的对象属性。用户态程序可以通过通用的属性操作接口读写KMS object上的属性，更改不会立即生效，而是缓存起来。当应用程序更新完其所有想要更新的属性时，可以通过Commit操作告知要求KMS层真正的更新硬件的状态。此时驱动程序需要验证应用程序要求进行的修改是否合法，在合法的情况下，可以一次性完成整个显示状态的修改。Atomic Mode Setting也实现了只用于检查新状态是否合法的接口。&lt;&#x2F;p&gt;
&lt;p&gt;由于Atomic Mode Setting提供的接口的功能是强于原先的KMS接口的，因此原先的KMS接口可以被Atomic Mode Setting接口实现。KMS Core提供了一些helper函数用以帮助驱动程序作者实现原先的Legacy KMS接口[&lt;a href=&quot;https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;html&#x2F;latest&#x2F;gpu&#x2F;drm-kms-helpers.html#atomic-modeset-helper-functions-reference&quot; title=&quot;Atomic Modeset Helper Functions Reference&quot;&gt;1&lt;&#x2F;a&gt;]&lt;a href=&quot;https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;html&#x2F;latest&#x2F;gpu&#x2F;drm-kms-helpers.html#atomic-modeset-helper-functions-reference&quot; title=&quot;Atomic Modeset Helper Functions Reference&quot;&gt;1&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;由于Legacy接口注定要扔到历史垃圾箱，后续的所有分析都是以&lt;code&gt;Atomic Mode Setting&lt;&#x2F;code&gt;的code path作为基准。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;qu-dong-jie-kou&quot;&gt;驱动接口&lt;&#x2F;h2&gt;
&lt;p&gt;驱动实现KMS接口的方式如下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;在probe函数中调用&lt;code&gt;drm_mode_config_init&lt;&#x2F;code&gt;函数初始化KMS core&lt;&#x2F;li&gt;
&lt;li&gt;填充mode_config中int min_width, min_height; int max_width, max_height的值，这些值是framebuffer的大小限制&lt;&#x2F;li&gt;
&lt;li&gt;设置mode_config中的funcs&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;下面以virtio-gpu为例分析驱动的实现。对于virtio-gpu上面的操作步骤实现如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;drm_mode_config_init&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(vgdev-&amp;gt;ddev);
        vgdev-&amp;gt;ddev-&amp;gt;mode_config.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;quirk_addfb_prefer_host_byte_order &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
        vgdev-&amp;gt;ddev-&amp;gt;mode_config.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;funcs &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &amp;amp;virtio_gpu_mode_funcs;
        vgdev-&amp;gt;ddev-&amp;gt;mode_config.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;helper_private &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &amp;amp;virtio_mode_config_helpers;

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* modes will be validated against the framebuffer size *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        vgdev-&amp;gt;ddev-&amp;gt;mode_config.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;min_width &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= XRES_MIN;
        vgdev-&amp;gt;ddev-&amp;gt;mode_config.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;min_height &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= YRES_MIN;
        vgdev-&amp;gt;ddev-&amp;gt;mode_config.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;max_width &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= XRES_MAX;
        vgdev-&amp;gt;ddev-&amp;gt;mode_config.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;max_height &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= YRES_MAX;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;funcs中填充的内容如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static const struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drm_mode_config_funcs virtio_gpu_mode_funcs = {
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;fb_create &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= virtio_gpu_user_framebuffer_create,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;atomic_check &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= drm_atomic_helper_check,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;atomic_commit &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= drm_atomic_helper_commit,
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;helperjia-gou&quot;&gt;helper架构&lt;&#x2F;h2&gt;
&lt;p&gt;helper架构是我起的名，知道是指什么东西就好。DRM子系统的API比较难抽象，简单来说就是硬件各有各的不同，很多情况下，驱动可以使用一个共同的实现，而在其它情况下，驱动需要提供自己的实现。因此，DRM驱动核心的接口使用了helper架构，其基本思想是通过一组回调函数抽象特定组件的操作，比如&lt;code&gt;drm_connector_funcs&lt;&#x2F;code&gt;，同时又使用另外一组helper函数给出了原先那组回调函数的通用实现，让开发最者实现这组helper函数抽象出的回调函数即可。&lt;&#x2F;p&gt;
&lt;p&gt;这样双层的实现即能保证开发者有足够高的自由度（完全不用helper函数），也能简化开发者的开发（使用helper函数），同时提供给开发者hook特定helper函数的能力。下面以&lt;code&gt;drm_connector&lt;&#x2F;code&gt;为例说明helper架构的实现与使用方式。&lt;&#x2F;p&gt;
&lt;p&gt;正常情况下，创建&lt;code&gt;drm_connector&lt;&#x2F;code&gt;对象时需要提供&lt;code&gt;struct drm_connector_funcs&lt;&#x2F;code&gt;回调函数组，而使用helper函数时，可以直接用helper函数填充对应回调函数：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static const struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drm_connector_funcs vc4_hdmi_connector_funcs = {
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;detect &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= vc4_hdmi_connector_detect,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;fill_modes &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= drm_helper_probe_single_connector_modes,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;destroy &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= vc4_hdmi_connector_destroy,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;reset &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= drm_atomic_helper_connector_reset,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;atomic_duplicate_state &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= drm_atomic_helper_connector_duplicate_state,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;atomic_destroy_state &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= drm_atomic_helper_connector_destroy_state,
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;事实上helper函数并不万能，只是抽象出了大多数驱动程序应该共享的行为，而特定于硬件的部分，则需要以回调函数的形式提供给helper函数，这个回调函数组由&lt;code&gt;struct drm_connector_helper_funcs&lt;&#x2F;code&gt;提供。在创建&lt;code&gt;drm_connector&lt;&#x2F;code&gt;时，需要通过&lt;code&gt;drm_connector_helper_add&lt;&#x2F;code&gt;函数注册。函数将对应的回调函数对象的地址保存在了&lt;code&gt;drm_connector&lt;&#x2F;code&gt;中的&lt;code&gt;helper_private&lt;&#x2F;code&gt;指针中，如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static inline void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;drm_connector_helper_add&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drm_connector *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;connector&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
                                            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drm_connector_helper_funcs *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;funcs&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        connector-&amp;gt;helper_private = funcs;
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这一套实现位于&lt;code&gt;include&#x2F;drm&#x2F;drm_modeset_helper_vtables.h&lt;&#x2F;code&gt;中，其他的DRM对象都有类似的实现，可以详细阅读&lt;code&gt;drm_connector_helper_funcs&lt;&#x2F;code&gt;的注释，理解其中对应的回调函数的用途。在实现DRM驱动时，helper架构会频繁用到，合理掌握helper函数可以极大简化开发，提升驱动程序的兼容性。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;crtc&quot;&gt;CRTC&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;framebuffer&quot;&gt;Framebuffer&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;html&#x2F;latest&#x2F;gpu&#x2F;drm-kms.html#frame-buffer-abstraction&quot;&gt;内核文档&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;framebuffer应该是唯一一个与硬件无关的抽象了。驱动程序需要提供自己的framebuffer实现，其主要入口就是前面提到的&lt;code&gt;drm_mode_config_funcs-&amp;gt;fb_create&lt;&#x2F;code&gt;回调函数。驱动程序通过扩展&lt;code&gt;drm_framebuffer&lt;&#x2F;code&gt;结构体可以向framebuffer中加入自己私有的字段。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;virtio_gpu_framebuffer {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drm_framebuffer base;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;virtio_gpu_fence *fence;
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;创建framebuffer时，需要通过&lt;code&gt;drm_framebuffer_init&lt;&#x2F;code&gt;函数将framebuffer初始化，并导出到用户空间。&lt;code&gt;fb_create&lt;&#x2F;code&gt;函数接受一个&lt;code&gt;drm_mode_fb_cmd2&lt;&#x2F;code&gt;类型的参数：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;drm_mode_fb_cmd2 {
        __u32 fb_id;
        __u32 width;
        __u32 height;
        __u32 pixel_format; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* fourcc code from drm_fourcc.h *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        __u32 flags; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* see above flags *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        __u32 handles[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;];
        __u32 pitches[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* pitch for each plane *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        __u32 offsets[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* offset of each plane *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        __u64 modifier[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* ie, tiling, compress *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其中最重要的就是handle，handle是Buffer Object的指针，该Buffer Object就是被创建framebuffer的存储后端。&lt;&#x2F;p&gt;
&lt;p&gt;TODO framebuffer releated operation&lt;&#x2F;p&gt;
&lt;h2 id=&quot;plane&quot;&gt;Plane&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;html&#x2F;latest&#x2F;gpu&#x2F;drm-kms.html#plane-abstraction&quot;&gt;内核文档&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;plane由&lt;code&gt;drm_plane&lt;&#x2F;code&gt;表示，其本质是对显示控制器中scanout硬件的抽象。简单来说，给定一个plane，可以让其与一个framebuffer关联表示进行scanout的数据，同时控制控制scanout时进行的额外操作，比如colorspace的改变，旋转、拉伸等操作。&lt;code&gt;drm_plane&lt;&#x2F;code&gt;是与硬件强相关的，显示控制器支持的plane是固定的，其支持的功能也是由硬件决定的。&lt;&#x2F;p&gt;
&lt;p&gt;对于&lt;code&gt;drm_plane&lt;&#x2F;code&gt;的分析，我们从其结构体定义入手。首先可以看到，一个plane必须要与一个&lt;code&gt;drm_deivce&lt;&#x2F;code&gt;关联，且一个&lt;code&gt;drm_device&lt;&#x2F;code&gt;中支持的所有plane都被保存在一个链表中。&lt;code&gt;drm_plane&lt;&#x2F;code&gt;中存有一个mask，用以表示该&lt;code&gt;drm_plane&lt;&#x2F;code&gt;可以绑定的CRTC。同时&lt;code&gt;drm_plane&lt;&#x2F;code&gt;中也保存了一个&lt;code&gt;format_types&lt;&#x2F;code&gt;数组，表示该&lt;code&gt;plane&lt;&#x2F;code&gt;支持的framebuffer格式。&lt;&#x2F;p&gt;
&lt;p&gt;所有的&lt;code&gt;drm_plane&lt;&#x2F;code&gt;必为三种类型之一：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Primary&lt;&#x2F;code&gt; - 主plane，一般控制整个显示器的输出。CRTC必须要有一个这样的plane。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Curosr&lt;&#x2F;code&gt; - 表示鼠标光标，可选。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Overlay&lt;&#x2F;code&gt; - 叠加plane，可以在主plane上叠加一层输出，可选。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;来回顾一点历史：内核向用户态导出的接口实际上不包含&lt;code&gt;Primary Plane&lt;&#x2F;code&gt;，对应plane的接口只能操作&lt;code&gt;Cursor Plane&lt;&#x2F;code&gt;和&lt;code&gt;Overlay Plane&lt;&#x2F;code&gt;，后期提供了一个&lt;code&gt;Universial Plane&lt;&#x2F;code&gt;特性，使得用户态API可以直接操作&lt;code&gt;Primary Plane&lt;&#x2F;code&gt;。在明白这个历史遗留问题后，对&lt;code&gt;drm_plane&lt;&#x2F;code&gt;的实现就好理解了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;encoder&quot;&gt;Encoder&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;mode&quot;&gt;Mode&lt;&#x2F;h2&gt;
&lt;p&gt;一般人对mode的理解仅仅是分辨率，这种理解在DRM中是不够的，不足以理解&lt;code&gt;drm_display_mode&lt;&#x2F;code&gt;是干什么的。简单来说，mode是一组信号时序，用以驱动显示器正确显示一帧图像。首先能够猜到需要传什么东西给显示器：像素数据。而到底多少个像素就跟显示器的分辨率有关了，如1080p的显示器需要传递&lt;code&gt;1080 x 1920&lt;&#x2F;code&gt;个像素。更加具体的形式是一行一行的从左到右发送，由于硬件实现需要，需要额外的步骤对信号进行同步。帧与帧之间被称为vertical，即竖直的，而行与行之间被称为horizontal，即水平的，这直接对应于显示器的横竖方向。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; *               Active                 Front           Sync           Back
 *              Region                 Porch                          Porch
 *     &amp;lt;-----------------------&amp;gt;&amp;lt;----------------&amp;gt;&amp;lt;-------------&amp;gt;&amp;lt;--------------&amp;gt;
 *       &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;|
 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; |
 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;  |..................               ................
 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*                                                _______________
 *     &amp;lt;----- [hv]display -----&amp;gt;
 *     &amp;lt;------------- [hv]sync_start ------------&amp;gt;
 *     &amp;lt;--------------------- [hv]sync_end ---------------------&amp;gt;
 *     &amp;lt;-------------------------------- [hv]total -----------------------------&amp;gt;*
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上面内核注释中的字符画完美的解释了&lt;code&gt;drm_display_mode&lt;&#x2F;code&gt;中变量的定义。需要注意的是现实状况中，还有需要其它复杂的显示模式，比如interlaced模式等，所以&lt;code&gt;drm_display_mode&lt;&#x2F;code&gt;区分逻辑参数与硬件参数，硬件参数就是真正进行硬件操作时使用的参数，而逻辑参数是为了方便驱动开发人员进行的抽象，&lt;code&gt;drm_display_mode&lt;&#x2F;code&gt;根据相应的flag计算出硬件参数。&lt;&#x2F;p&gt;
&lt;p&gt;除了上述直接与硬件相关的参数，&lt;code&gt;drm_display_mode&lt;&#x2F;code&gt;还携带了一些DRM相关的属性。比如类型：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;**
         * @type:
         *
         * A bitmask of flags, mostly about the source of a mode. Possible flags
         * are:
         *
         *  - DRM_MODE_TYPE_PREFERRED: Preferred mode, usually the native
         *    resolution of an LCD panel. There should only be one preferred
         *    mode per connector at any given time.
         *  - DRM_MODE_TYPE_DRIVER: Mode created by the driver, which is all of
         *    them really. Drivers must set this bit for all modes they create
         *    and expose to userspace.
         *  - DRM_MODE_TYPE_USERDEF: Mode defined via kernel command line
         *&#x2F;
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; type;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到mode的两个来源：驱动创建和内核命令行自行定义。而&lt;code&gt;DRM_MODE_TYPE_PREFERRED&lt;&#x2F;code&gt;标记的&lt;code&gt;drm_display_mode&lt;&#x2F;code&gt;则一般为对应connector的native mode。除此之外一个比较重要的属性就是status：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;**
         * @status:
         *
         * Status of the mode, used to filter out modes not supported by the
         * hardware. See enum &amp;amp;drm_mode_status.
         *&#x2F;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;enum&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drm_mode_status status;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;该属性直接标记该mode是否可以被硬件接受，如果不行，则会标注出具体原因。对应显示器的长宽一般会由&lt;code&gt;width_mm&lt;&#x2F;code&gt;和&lt;code&gt;height_mm&lt;&#x2F;code&gt;记录，单位是毫米。最后注意&lt;code&gt;drm_display_mode&lt;&#x2F;code&gt;一般与&lt;code&gt;drm_connector&lt;&#x2F;code&gt;关联，因此&lt;code&gt;drm_modes.c&lt;&#x2F;code&gt;中提供了相应的helper函数，比如：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;drm_mode_probed_add&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drm_connector *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;connector&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
                         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drm_display_mode *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;mode&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;WARN_ON&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;mutex_is_locked&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;connector-&amp;gt;dev-&amp;gt;mode_config.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;mutex&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;));

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;list_add_tail&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;mode-&amp;gt;head, &amp;amp;connector-&amp;gt;probed_modes);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;drm_mode_probed_add&lt;&#x2F;code&gt;函数将该mode添加到一个connector的管理中。注意probed_modes列表中可能包含了许多硬件无法使用的mode，对于这样的一个列表，可以使用&lt;code&gt;drm_mode_prune_invalid&lt;&#x2F;code&gt;将其中非法的mode清除。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;connector&quot;&gt;Connector&lt;&#x2F;h2&gt;
&lt;p&gt;首先明确connector抽象了什么东西。从内核文档的描述中可以明白，connector抽象的是一个&lt;strong&gt;能够显示像素的设备&lt;&#x2F;strong&gt;，从流媒体的角度来说，就是一个sink，是最终的图像输出的地方。或者更加具象的理解一下，字面意思就是显卡上面的接头，比如HDMI，DP等接头。connector由&lt;code&gt;struct drm_connector&lt;&#x2F;code&gt;进行表示，并定义在&lt;code&gt;include&#x2F;drm&#x2F;drm_connector.h&lt;&#x2F;code&gt;中，接下来就分析其相关实现。&lt;&#x2F;p&gt;
&lt;p&gt;首先从该结构体的定义下手，可以看到结构体定义开始比较长的，先从常规部分下手：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;drm_connector {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;** @dev: parent DRM device *&#x2F;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;drm_device *dev;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;** @kdev: kernel device for sysfs attributes *&#x2F;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;device *kdev;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;** @attr: sysfs attributes *&#x2F;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;device_attribute *attr;
		.......
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;很明显，从这里看出，内核认为&lt;code&gt;struct drm_connector&lt;&#x2F;code&gt;是sysfs树形结构的一员，翻译一下，就是一个&lt;code&gt;struct drm_connector&lt;&#x2F;code&gt;对象会对应&lt;code&gt;&#x2F;sys&lt;&#x2F;code&gt;目录下的某个子文件夹（节点）。有关该文件夹中相关的属性文件可以后续进行分析。&lt;&#x2F;p&gt;
&lt;p&gt;接下来可以看到明白一个&lt;code&gt;drm_device&lt;&#x2F;code&gt;中的所有connector都会被保存在一个链表中，进行管理，且&lt;code&gt;drm_connector&lt;&#x2F;code&gt;是一个&lt;code&gt;drm_mode_object&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;**
         * @head:
         *
         * List of all connectors on a @dev, linked from
         * &amp;amp;drm_mode_config.connector_list. Protected by
         * &amp;amp;drm_mode_config.connector_list_lock, but please only use
         * &amp;amp;drm_connector_list_iter to walk this list.
         *&#x2F;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; list_head head;

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;** @base: base KMS object *&#x2F;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drm_mode_object base;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;从这里之后，与&lt;code&gt;drm_connector&lt;&#x2F;code&gt;相关的分析主要以逻辑功能进行划分，而不应采取线性分析的方式。每一个&lt;code&gt;drm_connector&lt;&#x2F;code&gt;都应该定义一个类型，并保存在&lt;code&gt;drm_connector&lt;&#x2F;code&gt;中：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;**
         * @connector_type:
         * one of the DRM_MODE_CONNECTOR_&amp;lt;foo&amp;gt; types from drm_mode.h
         *&#x2F;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; connector_type;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;** @connector_type_id: index into connector type enum *&#x2F;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; connector_type_id;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;内核支持的&lt;code&gt;drm_connector&lt;&#x2F;code&gt;类型是uapi的一部分，定义在&lt;code&gt;include&#x2F;uapi&#x2F;drm&#x2F;drm_mode.h&lt;&#x2F;code&gt;中：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_CONNECTOR_Unknown      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_CONNECTOR_VGA          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_CONNECTOR_DVII         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_CONNECTOR_DVID         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_CONNECTOR_DVIA         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_CONNECTOR_Composite    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_CONNECTOR_SVIDEO       &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_CONNECTOR_LVDS         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;7
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_CONNECTOR_Component    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_CONNECTOR_9PinDIN      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;9
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_CONNECTOR_DisplayPort  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_CONNECTOR_HDMIA        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;11
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_CONNECTOR_HDMIB        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_CONNECTOR_TV           &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;13
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_CONNECTOR_eDP          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;14
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_CONNECTOR_VIRTUAL      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;15
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_CONNECTOR_DSI          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;16
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_CONNECTOR_DPI          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;17
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_MODE_CONNECTOR_WRITEBACK    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;18
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;很明显，connector驱动在初始化一个connector的时候应该设置connector的类型。与其他的drm对象类似，&lt;code&gt;drm_connector&lt;&#x2F;code&gt;的创建者需要提供一组回调函数，由于实现connector需要支持的一组操作：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;** @funcs: connector control functions *&#x2F;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drm_connector_funcs *funcs;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;drm-helper-probe-single-connector-modes&quot;&gt;drm_helper_probe_single_connector_modes&lt;&#x2F;h3&gt;
&lt;p&gt;函数是一个helper，用于提供默认的&lt;code&gt;drm_connector_funcs-&amp;gt;fill_modes&lt;&#x2F;code&gt;实现。本质上函数实现了对connector支持的&lt;code&gt;drm_display_mode&lt;&#x2F;code&gt;的扫描。从函数的注释中，可以看到函数进行的操作大致为：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;将connector中现有&lt;code&gt;modes&lt;&#x2F;code&gt;列表中的&lt;code&gt;drm_display_mode&lt;&#x2F;code&gt;全部标记为&lt;code&gt;MODE_STALE&lt;&#x2F;code&gt;状态&lt;&#x2F;li&gt;
&lt;li&gt;从以下三个来源收集&lt;code&gt;drm_display_mode&lt;&#x2F;code&gt;，并使用&lt;code&gt;drm_mode_probed_add&lt;&#x2F;code&gt;函数添加到&lt;code&gt;probed_list&lt;&#x2F;code&gt;中：
&lt;ul&gt;
&lt;li&gt;&amp;amp;drm_connector_helper_funcs.get_modes回调函数&lt;&#x2F;li&gt;
&lt;li&gt;如果&lt;code&gt;drm_connector&lt;&#x2F;code&gt;目前已经连接，则加入VESA标准DMT模式&lt;code&gt;1024 x 768&lt;&#x2F;code&gt;（这个就是VGA接口没插稳检测不到EDID时分辨率变&lt;code&gt;1024x768&lt;&#x2F;code&gt;的原因了吧）&lt;&#x2F;li&gt;
&lt;li&gt;从内核命令行参数&lt;code&gt;video=&lt;&#x2F;code&gt;读取并生成&lt;code&gt;drm_display_mode&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;将probed_list中的&lt;code&gt;drm_display_mode&lt;&#x2F;code&gt;移动到&lt;code&gt;modes&lt;&#x2F;code&gt;列表中，并合并冲突项&lt;&#x2F;li&gt;
&lt;li&gt;验证非STALE状态&lt;code&gt;drm_display_mode&lt;&#x2F;code&gt;的合法性&lt;&#x2F;li&gt;
&lt;li&gt;将所有非法的&lt;code&gt;drm_display_mode&lt;&#x2F;code&gt;从&lt;code&gt;modes&lt;&#x2F;code&gt;列表中删除&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;hotplugjian-ce&quot;&gt;hotplug检测&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;drm_connector&lt;&#x2F;code&gt;支持hotplug且DRM中提供了相应的helper，简化实现。目前主要的helper有：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;drm_kms_helper_poll_init()用于提供轮询检测支持&lt;&#x2F;li&gt;
&lt;li&gt;drm_helper_hpd_irq_event()用于提供中断检测支持&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;下面就来分析DRM对于轮询检测的helper实现。可以看到，该helper的实现非常简单，其基本原理是创建一个delayed_work并使能：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;drm_kms_helper_poll_init&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drm_device *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dev&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;INIT_DELAYED_WORK&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;dev-&amp;gt;mode_config.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;output_poll_work&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, output_poll_execute);
        dev-&amp;gt;mode_config.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;poll_enabled &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;drm_kms_helper_poll_enable&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(dev);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;而&lt;code&gt;drm_kms_helper_poll_enable&lt;&#x2F;code&gt;函数很明显就是用于重置并使能这个delayed_work。注意这个函数的调用参数为&lt;code&gt;drm_device&lt;&#x2F;code&gt;，也就是这个机制整个就是应用于一个&lt;code&gt;drm_device&lt;&#x2F;code&gt;的。在分析这个函数之前，可以发现一个模块参数&lt;code&gt;drm.poll&lt;&#x2F;code&gt;，用于控制轮询的行为：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static bool&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drm_kms_helper_poll = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;module_param_named&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(poll, drm_kms_helper_poll, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0600&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;drm_kms_helper_poll_enable&lt;&#x2F;code&gt;函数首先检查是否能够开启轮询模式，条件如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(!dev-&amp;gt;mode_config.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;poll_enabled &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;|| !drm_kms_helper_poll)
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;也就是说，&lt;code&gt;drm.poll&lt;&#x2F;code&gt;模块参数可以直接影响轮询的行为。随后函数遍历所有的&lt;code&gt;drm_connector&lt;&#x2F;code&gt;，然后决定是否需要进行轮询：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;drm_connector_list_iter_begin&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(dev, &amp;amp;conn_iter);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;drm_for_each_connector_iter&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(connector, &amp;amp;conn_iter) {
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(connector-&amp;gt;polled &amp;amp; (DRM_CONNECTOR_POLL_CONNECT |
                                         DRM_CONNECTOR_POLL_DISCONNECT))
                        poll = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
        }
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;drm_connector_list_iter_end&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;conn_iter);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里注意到&lt;code&gt;drm_connector.polled&lt;&#x2F;code&gt;字段，它表示一个&lt;code&gt;drm_connector&lt;&#x2F;code&gt;的轮询模式，是一个bitflag，有如下三位：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;         * DRM_CONNECTOR_POLL_HPD
         *     The connector generates hotplug events and doesn&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;t need to be
         *     periodically polled. The CONNECT and DISCONNECT flags must not
         *     be set together with the HPD flag.
         *
         * DRM_CONNECTOR_POLL_CONNECT
         *     Periodically poll the connector for connection.
         *
         * DRM_CONNECTOR_POLL_DISCONNECT
         *     Periodically poll the connector for disconnection, without
         *     causing flickering even when the connector is in use. DACs should
         *     rarely do this without a lot of testing.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;简单来说就是检测所有的&lt;code&gt;drm_connector&lt;&#x2F;code&gt;中是否有需要轮询检测状态的，如果有则开启轮询。函数最后根据检测的结果打开轮询：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(poll)
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;schedule_delayed_work&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;dev-&amp;gt;mode_config.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;output_poll_work&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, delay);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;默认情况下，第一次进行轮询的delay为1秒，否则为10秒：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;DRM_OUTPUT_POLL_PERIOD (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*HZ)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;前面看到delayed_work的回调函数为&lt;code&gt;output_poll_execute&lt;&#x2F;code&gt;，函数的实现还是比较简单的。函数遍历&lt;code&gt;drm_device&lt;&#x2F;code&gt;所有的&lt;code&gt;drm_connector&lt;&#x2F;code&gt;，然后找到需要进行轮询的设备，并调用&lt;code&gt;drm_helper_probe_detect&lt;&#x2F;code&gt;检测这个&lt;code&gt;drm_connector&lt;&#x2F;code&gt;的状态。而&lt;code&gt;drm_helper_probe_detect&lt;&#x2F;code&gt;仅仅是调用了&lt;code&gt;drm_connector_helper_funcs&lt;&#x2F;code&gt;中注册的&lt;code&gt;detect_ctx&lt;&#x2F;code&gt;和&lt;code&gt;detect&lt;&#x2F;code&gt;回调函数。&lt;&#x2F;p&gt;
&lt;p&gt;对于支持中断的&lt;code&gt;drm_connector&lt;&#x2F;code&gt;，如果它是粗粒度的，即无法判断哪一个&lt;code&gt;drm_connector&lt;&#x2F;code&gt;状态发生了改变，则驱动开发者可以在进程上下文调用&lt;code&gt;drm_helper_hpd_irq_event&lt;&#x2F;code&gt;函数，检测所有标记了&lt;code&gt;DRM_CONNECTOR_POLL_HPD&lt;&#x2F;code&gt;的&lt;code&gt;drm_connector&lt;&#x2F;code&gt;。反之，则开发这可以自行调用&lt;code&gt;drm_kms_helper_hotplug_event&lt;&#x2F;code&gt;函数处理该事件。&lt;code&gt;drm_kms_helper_hotplug_event&lt;&#x2F;code&gt;的主要行为是发送uevent到用户态，并调用&lt;code&gt;dev-&amp;gt;mode_config.funcs-&amp;gt;output_poll_changed&lt;&#x2F;code&gt;回调函数。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yong-hu-tai-diao-yong-lu-jing&quot;&gt;用户态调用路径&lt;&#x2F;h2&gt;
&lt;p&gt;对于与&lt;code&gt;drmModeSetCrtc&lt;&#x2F;code&gt;相关的legacy接口，其最终都调用到了IOCTL上：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;DRM_IOCTL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(fd, DRM_IOCTL_MODE_SETCRTC, &amp;amp;crtc);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;而所有与drm相关的定义都在&lt;code&gt;drivers&#x2F;gpu&#x2F;drm&#x2F;drm_ioctl.c&lt;&#x2F;code&gt;中：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;DRM_IOCTL_DEF&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(DRM_IOCTL_MODE_SETCRTC, drm_mode_setcrtc, DRM_MASTER),
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以知道它的处理函数是&lt;code&gt;drm_mode_setcrtc&lt;&#x2F;code&gt;。函数首先检查DRM设备的feature：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;drm_core_check_feature&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(dev, DRIVER_MODESET))
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;-EOPNOTSUPP;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;忽略到中间的处理可以看到：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;drm_drv_uses_atomic_modeset&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(dev))
                ret = crtc-&amp;gt;funcs-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;set_config&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;set, &amp;amp;ctx);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;                ret = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__drm_mode_set_config_internal&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;set, &amp;amp;ctx);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;对于支持A-KMS的驱动来说，我们最终调用的就是&lt;code&gt;drm_crtc_funcs-&amp;gt;set_config&lt;&#x2F;code&gt;回调函数，也就是&lt;code&gt;drm_atomic_helper_set_config&lt;&#x2F;code&gt;函数。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static inline bool &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;drm_drv_uses_atomic_modeset&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drm_device *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dev&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;drm_core_check_feature&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(dev, DRIVER_ATOMIC) ||
                (dev-&amp;gt;mode_config.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;funcs &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;amp;&amp;amp; dev-&amp;gt;mode_config.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;funcs&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;-&amp;gt;atomic
_commit != &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;用户态A-KMS调用的入口函数&lt;code&gt;drmModeAtomicCommit&lt;&#x2F;code&gt;内部使用了不同的IOCTL调用：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        ret = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;DRM_IOCTL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(fd, DRM_IOCTL_MODE_ATOMIC, &amp;amp;atomic);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;对应到内核态：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;DRM_IOCTL_DEF&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(DRM_IOCTL_MODE_ATOMIC, drm_mode_atomic_ioctl, DRM_MASTER),
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;该函数就是A-KMS在内核对应的处理函数，主要进行如下的操作：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;检查DRM设备是否设置&lt;code&gt;DRIVER_ATOMIC&lt;&#x2F;code&gt;标志，没有设置报错退出&lt;&#x2F;li&gt;
&lt;li&gt;检查用户态是否使能了A-KMS相关的API，没有使能报错退出&lt;&#x2F;li&gt;
&lt;li&gt;处理用户态传入的flags如PAGE_FLIP_ASYNC，ATOMIC_TEST_ONLY，PAGE_FLIP_EVENT等&lt;&#x2F;li&gt;
&lt;li&gt;申请一个新的atomic_mode_state，将用户态传入的property拷贝并设置到新的state上&lt;&#x2F;li&gt;
&lt;li&gt;最后根据flags中是否允许阻塞调用&lt;code&gt;drm_atomic_commit&lt;&#x2F;code&gt;或者&lt;code&gt;drm_atomic_nonblocking_commit&lt;&#x2F;code&gt;函数&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;statedui-xiang&quot;&gt;State对象&lt;&#x2F;h2&gt;
&lt;p&gt;state是什么？这里的state是DRM框架用来追踪显示pipeline各个组件状态的状态集合。一个DRM显示pipeline的整体状态由&lt;code&gt;struct drm_atomic_state&lt;&#x2F;code&gt;表示：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;drm_atomic_state {
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kref ref;
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;drm_device *dev;
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; allow_modeset : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; legacy_cursor_update : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; async_update : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; duplicated : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__drm_planes_state *planes;
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__drm_crtcs_state *crtcs;
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; num_connector;
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__drm_connnectors_state *connectors;
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; num_private_objs;
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__drm_private_objs_state *private_objs;
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;drm_modeset_acquire_ctx *acquire_ctx;
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;drm_crtc_commit *fake_commit;
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; work_struct commit_work;
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到他由每个独立的组件（即drm object）的状态对象组成。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;statede-chuang-jian&quot;&gt;State的创建&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;drm_atomic_state&lt;&#x2F;code&gt;的创建由&lt;code&gt;drm_atomic_state_alloc&lt;&#x2F;code&gt;实现。函数中可以看到，&lt;code&gt;drm_mode_config_funcs&lt;&#x2F;code&gt;中提供了名为&lt;code&gt;atomic_state_alloc&lt;&#x2F;code&gt;的hook，允许我们自己实现state对象的创建。在默认情况下，函数会调用简单分配内存，然后使用&lt;code&gt;drm_atomic_state_init&lt;&#x2F;code&gt;进行初始化。初始化函数仅仅是简单分配分配&lt;code&gt;drm_atomic_state&lt;&#x2F;code&gt;中几个指针指向的内存区域。&lt;&#x2F;p&gt;
&lt;p&gt;对于各个drm object对应的state，其创建操作由其对应的&lt;code&gt;drm_{object}_funcs-&amp;gt;atomic_duplicate_state&lt;&#x2F;code&gt;实现，在驱动程序没有扩展&lt;code&gt;drm_atomic_state&lt;&#x2F;code&gt;的情况下，这个回调函数一般填写为&lt;code&gt;drm_atomic_helper_{object}_duplicate_state&lt;&#x2F;code&gt;。而在commit过程中，是由&lt;code&gt;drm_atomic_get_{object}_state&lt;&#x2F;code&gt;函数触发这个创建操作的。该函数触发复制state操作后，还会将复制后的state及原本的state填入&lt;code&gt;drm_atomic_state&lt;&#x2F;code&gt;中对应的&lt;code&gt;__drm_{object}_state&lt;&#x2F;code&gt;中。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__drm_{object}_state {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drm_{object} *ptr;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drm_{object}_state *state, *old_state, *new_state;
    
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* extra fields may exist *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里的&lt;code&gt;old_state&lt;&#x2F;code&gt;保存&lt;code&gt;drm_{object}&lt;&#x2F;code&gt;现有的state，而&lt;code&gt;state&lt;&#x2F;code&gt;及&lt;code&gt;new_state&lt;&#x2F;code&gt;就保存我们复制后的state。&lt;&#x2F;p&gt;
&lt;p&gt;最后描述一下commit时创建state的简单流程：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;drm_mode_atomic_ioctl函数中会将用户态传入的property更新依次调用drm_atomic_set_property写入前面创建的&lt;code&gt;drm_atomic_state&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;drm_atomic_set_property函数会根据传入object的类型调用对应的&lt;code&gt;drm_atomic_get_{object}_state&lt;&#x2F;code&gt;函数，得到对应于该object类型的&lt;code&gt;drm_{object}_state&lt;&#x2F;code&gt;。在这个调用中，如果&lt;code&gt;drm_atomic_mode&lt;&#x2F;code&gt;中对应的&lt;code&gt;__drm_{object}_state&lt;&#x2F;code&gt;不存在，则复制原有的state并填入其中&lt;&#x2F;li&gt;
&lt;li&gt;随后&lt;code&gt;drm_atomic_set_property&lt;&#x2F;code&gt;会调用&lt;code&gt;drm_atomic_{object}_set_property&lt;&#x2F;code&gt;将属性更新写入到新的state当中&lt;&#x2F;li&gt;
&lt;li&gt;最后drm_mode_atomic_ioctl调用对应函数（&lt;code&gt;drm_atomic_commit&lt;&#x2F;code&gt;及其非阻塞版本）进行commit操作（该操作前提是没有设置TEST_ONLY的标志）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;stategeng-xin&quot;&gt;state更新&lt;&#x2F;h3&gt;
&lt;p&gt;state更新由&lt;code&gt;drm_atomic_{object}_set_property&lt;&#x2F;code&gt;函数实现。目前我们看到的state更新是作为一个整体出现的，即通过用户态的commit操作触发。事实上DRM还支持partial update，支持单独对某个object进行更新操作，后面会分析清楚。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;statede-commit&quot;&gt;state的commit&lt;&#x2F;h3&gt;
&lt;p&gt;上面看到真正的commit操作由&lt;code&gt;drm_atomic_commit&lt;&#x2F;code&gt;函数实现。该函数的实现也比较简单：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;drm_atomic_commit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drm_atomic_state *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;state&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drm_mode_config *config = &amp;amp;state-&amp;gt;dev-&amp;gt;mode_config;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ret;

        ret = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;drm_atomic_check_only&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(state);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(ret)
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ret;

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;DRM_DEBUG_ATOMIC&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;committing &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%p&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, state);

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; config-&amp;gt;funcs-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;atomic_commit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(state-&amp;gt;dev, state, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;false&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;主要分为检查state合法性和调用&lt;code&gt;drm_mode_config_funcs-&amp;gt;atomic_commit&lt;&#x2F;code&gt;函数进行commit操作。默认情况下，atomic_commit回调函数的功能是由&lt;code&gt;drm_atomic_helper_commit&lt;&#x2F;code&gt;实现的。函数内部有两个code path：阻塞和非阻塞，我们主要讨论阻塞情况下的实现。在阻塞情况下，函数会直接调用&lt;code&gt;drm_mode_config_helpers-&amp;gt;atomic_commit_tail&lt;&#x2F;code&gt;函数。A-KMS中实现了一个标准的helper：&lt;code&gt;drm_atomic_helper_commit_tail&lt;&#x2F;code&gt;。而该helper又由更多的helper组成，因此想要真正理解A-KMS中commit操作的大致流程，需要分析这些helper实现的功能及调用的约定。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;drm_atomic_helper_commit_tail&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drm_atomic_state *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;old_state&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drm_device *dev = old_state-&amp;gt;dev;

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;drm_atomic_helper_commit_modeset_disables&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(dev, old_state);

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;drm_atomic_helper_commit_planes&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(dev, old_state, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;drm_atomic_helper_commit_modeset_enables&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(dev, old_state);

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;drm_atomic_helper_fake_vblank&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(old_state);

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;drm_atomic_helper_commit_hw_done&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(old_state);

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;drm_atomic_helper_wait_for_vblanks&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(dev, old_state);

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;drm_atomic_helper_cleanup_planes&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(dev, old_state);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;drm-atomic-helper-commit-modeset-disables&quot;&gt;drm_atomic_helper_commit_modeset_disables&lt;&#x2F;h3&gt;
&lt;p&gt;该helper的作用是关闭所有的&lt;&#x2F;p&gt;
&lt;p&gt;TODO: check_only&lt;&#x2F;p&gt;
&lt;h2 id=&quot;atomic-modeset-helperhan-shu-fen-xi&quot;&gt;Atomic Modeset Helper函数分析&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;jia-gou&quot;&gt;架构&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;去libdrm里找找看A-KMS的IOCTL接口与legacy到底有什么不同没有&lt;&#x2F;li&gt;
&lt;li&gt;假设有不同，那么IOCTL就是有两套接口。对于legacy接口，走原先legacy那套，其对应callback由Atomic Modeset Helper函数实现。对于A-KMS接口，其对应接口也由对应Helper实现。也就是说，Helper是框架中的一部分。&lt;&#x2F;li&gt;
&lt;li&gt;现在已经都是用新的A-KMS接口了，我认为legacy不用花大功夫去分析。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;整体架构为：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;原先legacy的callback保留，但是基本由A-KMS提供的公共helper实现&lt;&#x2F;li&gt;
&lt;li&gt;公共helper依赖与对应KMS object中保存的private_helper实现功能&lt;&#x2F;li&gt;
&lt;li&gt;驱动程序在注册KMS object时必须初始化legacy callback和private_helper，否则无法正常工作&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;以CRTC举例，如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static const struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drm_crtc_funcs virtio_gpu_crtc_funcs = {
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;set_config             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= drm_atomic_helper_set_config,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;destroy                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= drm_crtc_cleanup,

        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;page_flip              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= drm_atomic_helper_page_flip,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;reset                  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= drm_atomic_helper_crtc_reset,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;atomic_duplicate_state &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= drm_atomic_helper_crtc_duplicate_state,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;atomic_destroy_state   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= drm_atomic_helper_crtc_destroy_state,
};

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static const struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drm_crtc_helper_funcs virtio_gpu_crtc_helper_funcs = {
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;mode_set_nofb &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= virtio_gpu_crtc_mode_set_nofb,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;atomic_check  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= virtio_gpu_crtc_atomic_check,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;atomic_flush  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= virtio_gpu_crtc_atomic_flush,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;atomic_enable &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= virtio_gpu_crtc_atomic_enable,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;atomic_disable &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= virtio_gpu_crtc_atomic_disable,
};

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;vgdev_output_init&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; virtio_gpu_device *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;vgdev&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;index&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ......
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;drm_crtc_init_with_planes&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(dev, crtc, primary, cursor,
                                  &amp;amp;virtio_gpu_crtc_funcs, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;drm_crtc_helper_add&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(crtc, &amp;amp;virtio_gpu_crtc_helper_funcs);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ......
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;}

&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;drm-atomic-helper-check&quot;&gt;drm_atomic_helper_check&lt;&#x2F;h3&gt;
&lt;p&gt;从前面我们看到，A-KMS的主要操作主要分为两个：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;检查显示mode的合法性，确认硬件确实在该mode下正常工作&lt;&#x2F;li&gt;
&lt;li&gt;commit操作，将硬件完整的设置成对应的状态&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;而&lt;code&gt;drm_atomic_helper_check&lt;&#x2F;code&gt;就是一般情况下&lt;code&gt;drm_mode_config_funcs-&amp;gt;atomic_check&lt;&#x2F;code&gt;内的回调函数。其主要包含两个大的功能点：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;drm_atomic_helper_check_modeset&lt;&#x2F;li&gt;
&lt;li&gt;drm_atomic_helper_check_planes&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;前者逐级调用CRTC下面组件的&lt;code&gt;atomic_check&lt;&#x2F;code&gt;回调函数，确认modeset是否合法。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Linux内核组播包接收流程分析</title>
		<published>2021-03-08T00:00:00+00:00</published>
		<updated>2021-03-08T00:00:00+00:00</updated>
		<link href="https://crab2313.github.io/multicast/" type="text/html"/>
		<id>https://crab2313.github.io/multicast/</id>
		<content type="html">&lt;p&gt;本文直接分析组播接收的流程细节。由于工作需要，暂且分析2.6.32内核的相关细节，并将分析文档记录于此。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;qu-dong-ceng&quot;&gt;驱动层&lt;&#x2F;h2&gt;
&lt;p&gt;TCP&#x2F;IP协议栈是典型的tier架构，对于IP协议来说，其工作就是从链路层接收数据，然后对其进行处理，然后将数据传递给它的上一层协议。所以不难想象其在内核中的实现，即通过链路层的包中存在的某个字段确定该包为IPv4协议包，然后选择对应的handler进行处理。&lt;&#x2F;p&gt;
&lt;p&gt;IPv4包接收的核心逻辑是比较简明易懂的，时间紧张就不多讨论。首先明确驱动和内核网络子系统的界限，即一个sk_buff是如果通过驱动转交给内核的。目前内核保留了两套API，或者说机制，让驱动将接收到的数据包，或者说sk_buff，转交给内核网络子系统。一般称这两个API为legacy和NAPI，这二者的区别为前者是中断驱动的，而后者是中断与轮询机制相结合的。二者的接收入口分别为&lt;code&gt;netif_rx&lt;&#x2F;code&gt;以及&lt;code&gt;netif_receive_skb&lt;&#x2F;code&gt;。无论哪种情况下，网卡驱动都会自行选择一个API，并创建sk_buff，填入数据，然后通过选择的API将填好数据的sk_buff提交给内核（目前基本上都是用NAPI）。&lt;&#x2F;p&gt;
&lt;p&gt;也就是说，网卡驱动拥有提交sk_buff的自由。一个常见的例子就是网卡的混杂模式，该模式下网卡可以接收到链路中发送给所有地址的数据包，而不是仅仅接收自己绑定IP地址的数据包。这个模式就需要网卡驱动的相关配合。&lt;&#x2F;p&gt;
&lt;p&gt;对于以太网卡驱动，内核提供给其一个比较重要的helper函数就是&lt;code&gt;eth_type_trans&lt;&#x2F;code&gt;，该函数用于直接根据ethernet链路层报文header中的字段确定packet类型，并填充到&lt;code&gt;sk_buffer&lt;&#x2F;code&gt;的protocol字段中，同时对于组播包一个比较重要的细节就是该函数也根据报文链路地址设置设置&lt;code&gt;skb-&amp;gt;pkt_type&lt;&#x2F;code&gt;字段，即一个包的类型。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__be16 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;eth_type_trans&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; sk_buff *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;skb&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; net_device *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dev&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ethhdr *eth;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned char &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*rawp;

        skb-&amp;gt;dev = dev;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;skb_reset_mac_header&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(skb);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;skb_pull&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(skb, ETH_HLEN);
        eth = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eth_hdr&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(skb);

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;unlikely&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;is_multicast_ether_addr&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(eth-&amp;gt;h_dest))) {
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;compare_ether_addr_64bits&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(eth-&amp;gt;h_dest, dev-&amp;gt;broadcast))
                        skb-&amp;gt;pkt_type = PACKET_BROADCAST;
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;                        skb-&amp;gt;pkt_type = PACKET_MULTICAST;
        }

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;*
         *      This ALLMULTI check should be redundant by 1.4
         *      so don&amp;#39;t forget to remove it.
         *
         *      Seems, you forgot to remove it. All silly devices
         *      seems to set IFF_PROMISC.
         *&#x2F;

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;*dev-&amp;gt;flags&amp;amp;IFF_PROMISC *&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) {
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;unlikely&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;compare_ether_addr_64bits&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(eth-&amp;gt;h_dest, dev-&amp;gt;dev_addr)))
                        skb-&amp;gt;pkt_type = PACKET_OTHERHOST;
        }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到&lt;code&gt;eth_trans_type&lt;&#x2F;code&gt;函数根据比较sk_buff接收网卡的MAC地址与接收包的目标MAC地址，确定该pkt_type的值。如果是广播地址则设置为&lt;code&gt;PACKET_BROADCAST&lt;&#x2F;code&gt;，组播则为&lt;code&gt;PACKET_MULTICAST&lt;&#x2F;code&gt;，而目的地非本网卡MAC地址的包则为&lt;code&gt;PACKET_OTHERHOST&lt;&#x2F;code&gt;类型（即网卡混杂模式下接收到的链路上目的地不是自己MAC的包）。注意可以从后面看到IP层根本不处理&lt;code&gt;PACKET_OTHERHOST&lt;&#x2F;code&gt;类型的包，而是直接丢弃，这个后面继续分析。&lt;&#x2F;p&gt;
&lt;p&gt;无论是legacy还是NAPI，其对驱动发送的sk_buff的处理都是相同的（甚至说legacy相关API在后期已经构建于NAPI之上）。这里主要分析&lt;code&gt;__netif_recieve_skb&lt;&#x2F;code&gt;函数，因为netif_rx也是实现在它之上。从内核的角度来看，驱动在其方便的时候调用了这个函数，即用调用这个函数的方式将自己准备好的sk_buff提交给内核。因此，内核首先要帮助处理和建立sk_buff的一些状态，即将sk_buff从链路层切换到网络层，简单来说就是设置一些字段，然后调整一下sk_buff中的数据指针，使其指向网络层的数据，具体细节可以研究一下&lt;code&gt;sk_buff&lt;&#x2F;code&gt;的实现。&lt;&#x2F;p&gt;
&lt;p&gt;从这里会碰到内核网络协议栈实现的一个典型pattern，即根据类型对包的分流处理，这也与网络协议的设计相符合。在网络多层设计中，一般情况下，位于位于底层的协议在封装上层协议的数据包时，都会在header中留有一个字段用户确定上层协议类型。例如，以太网的frame header中就留有字段确定该frame中传输的数据是ARP包还是IP包。内核对于该种设计的处理有一个特定的pattern，即定义一个通用的&lt;code&gt;type + handler&lt;&#x2F;code&gt;的数据结构，然后将其串起来，根据&lt;code&gt;type&lt;&#x2F;code&gt;寻找特定的handler。特化到L3（网络）层，该数据结构就是&lt;code&gt;struct packet_type&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;packet_type {
        __be16                  type;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* This is really htons(ether_type). *&#x2F;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;net_device       *dev;   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* NULL is wildcarded here           *&#x2F;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int                     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*func) (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; sk_buff *,
                                         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; net_device *,
                                         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; packet_type *,
                                         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; net_device *);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;sk_buff          *(*gso_segment)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;sk_buff *skb,
                                                int features);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int                     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*gso_send_check)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; sk_buff *skb);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;sk_buff          **(*gro_receive)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;sk_buff **head,
                                               &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;sk_buff *skb);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int                     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*gro_complete)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; sk_buff *skb);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*af_packet_priv;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; list_head        list;
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;一般情况下，我们只需要定义&lt;code&gt;type&lt;&#x2F;code&gt;和&lt;code&gt;func&lt;&#x2F;code&gt;回调函数。对于IPv4来说，定义如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; packet_type ip_packet_type __read_mostly = {
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cpu_to_be16&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(ETH_P_IP),
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;func &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= ip_rcv,
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;回到&lt;code&gt;__netif_receive_skb&lt;&#x2F;code&gt;函数的分析，前面提到&lt;code&gt;packet_type&lt;&#x2F;code&gt;是因为该函数对sk_buff的处理多处到了该结构体。除了前面提到的处理，函数还需要经过以下几个过程，这里简要提及：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;ptype_all&lt;&#x2F;li&gt;
&lt;li&gt;handle_bridge&lt;&#x2F;li&gt;
&lt;li&gt;handle_macvlan&lt;&#x2F;li&gt;
&lt;li&gt;handle_openvswitch&lt;&#x2F;li&gt;
&lt;li&gt;ptype_base&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;其中ptype_all是内核注册的一组packet_type，使得用户态可以在这里截获特定的sk_buff，如tcpdump等工具就是通过这种方式实现的。中间几个函数的处理目前略过。函数最后从系统注册的&lt;code&gt;ptype_base&lt;&#x2F;code&gt;列表中找到&lt;code&gt;skb-&amp;gt;protocol&lt;&#x2F;code&gt;对应的handler，进而进行处理，对于IPv4协议就是前面看到的ip_packet_type，对应的回调函数为&lt;code&gt;ip_rcv&lt;&#x2F;code&gt;函数。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ip-rcv&quot;&gt;ip_rcv&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;code&gt;ip_rcv&lt;&#x2F;code&gt;位于&lt;code&gt;net&#x2F;ipv4&#x2F;ip_input.c&lt;&#x2F;code&gt;中，是IPv4协议输入包的入口。函数开头直接检测该包是否属于本机，也就是说整个IPv4协议栈不负责处理网卡混杂模式下接收到的其他额外的包（即目标地址非本机网卡MAC的包）：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* When the interface is in promisc. mode, drop all the crap
         * that it receives, do not try to analyse it.
         *&#x2F;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(skb-&amp;gt;pkt_type == PACKET_OTHERHOST)
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;goto&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drop;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;随后函数增加IPv4收包计数器。函数对该包进行简单合法性检查后，将其扔进netfilter的&lt;code&gt;PRE_ROUTING&lt;&#x2F;code&gt;入口：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;NF_HOOK&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(PF_INET, NF_INET_PRE_ROUTING, skb, dev, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
                       ip_rcv_finish);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里如果没有iptable规则将包偷走，那么则会传入到下一级&lt;code&gt;ip_rcv_finish&lt;&#x2F;code&gt;函数。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ip-rcv-finish&quot;&gt;ip_rcv_finish&lt;&#x2F;h2&gt;
&lt;p&gt;这个函数是IPv4包处理的中心，由于我们这个sk_buff是从网卡驱动来的，所以它是没有路由缓存的，而函数开头对该情况进行的处理，创建了一个路由表缓存条目。注意2.6.32内核比较古老，路由子系统还是使用的旧的基于路由缓存的实现，新版本内核已经改为基于字典树的路由表实现。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;*
         *      Initialise the virtual path cache for the packet. It describes
         *      how the packet travels inside Linux networking.
         *&#x2F;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;skb_dst&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(skb) == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) {
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; err = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ip_route_input&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(skb, iph-&amp;gt;daddr, iph-&amp;gt;saddr, iph-&amp;gt;tos,
                                         skb-&amp;gt;dev);
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;unlikely&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(err)) {
                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(err == -EHOSTUNREACH)
                                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;IP_INC_STATS_BH&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dev_net&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(skb-&amp;gt;dev),
                                                IPSTATS_MIB_INADDRERRORS);
                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(err == -ENETUNREACH)
                                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;IP_INC_STATS_BH&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dev_net&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(skb-&amp;gt;dev),
                                                IPSTATS_MIB_INNOROUTES);
                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;goto&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drop;
                }
        }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;事实上这个初始化路由表缓存条目的行为直接沟通了路由子系统，为该包决定好了去处，后续的任务仅仅是再次检查合法性，更新广播包与组播包的计数器：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(iph-&amp;gt;ihl &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ip_rcv_options&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(skb))
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;goto&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drop;

        rt = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;skb_rtable&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(skb);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(rt-&amp;gt;rt_type == RTN_MULTICAST) {
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;IP_UPD_PO_STATS_BH&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dev_net&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(rt-&amp;gt;u.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dst&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dev&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;), IPSTATS_MIB_INMCAST,
                                skb-&amp;gt;len);
        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(rt-&amp;gt;rt_type == RTN_BROADCAST)
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;IP_UPD_PO_STATS_BH&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dev_net&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(rt-&amp;gt;u.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dst&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dev&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;), IPSTATS_MIB_INBCAST,
                                skb-&amp;gt;len);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;最后将这个sk_buff扔到路由子系统中：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dst_input&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(skb);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;lu-you-zi-xi-tong-xiang-guan&quot;&gt;路由子系统相关&lt;&#x2F;h2&gt;
&lt;p&gt;前面看到，由于我们扔给&lt;code&gt;ip_rcv_finish&lt;&#x2F;code&gt;的包是从网卡驱动直接创建的，所以没有路由缓存条目，需要通过路由子系统给其一个相关联的条目，该操作由&lt;code&gt;ip_route_input&lt;&#x2F;code&gt;函数实现，函数位于&lt;code&gt;net&#x2F;ipv4&#x2F;route.c&lt;&#x2F;code&gt;中。&lt;&#x2F;p&gt;
&lt;p&gt;首先明确函数的目的，即为什么要给一个sk_buff关联一个路由表缓存。IPv4协议中，IP包的路由是非常复杂的，尤其是涉及到具体实现的时候。当我们将一个IP包交给内核的时候，内核需要根据包中记录的相关信息（如源地址，目标地址，IPv4 options）确定该包是否合法，是否需要额外处理，以及其具体去处，比如：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;FORWARD，即传递操作。默认情况下，内核不进行forward操作，否则，内核将自己不应该接收的包通过路由表的设置发送给下一级接收者&lt;&#x2F;li&gt;
&lt;li&gt;LOCAL DELIVERY，本地分发。内核认为该包是发给自己所运行的这台机器的，将会对其进行分发操作。其本质就是根据包的信息，将其分发给运行在操作系统下的应用程序。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;对于我们正在分析的情况，这一套还是比较简单的，因为没有涉及复杂的路由处理逻辑。2.6.32内核的路由缓存实现原理比较简单，但是细节繁杂，其主要思路是通过一个哈希表保存多个条目，起到快速查找的作用，因为路由表性能直接影响内核对于IP包的处理速度。可以看到哈希函数的参数如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        hash = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rt_hash&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(daddr, saddr, iif, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rt_genid&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(net));
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;也就是IP包的源地址，目标地址，以及网络接口编号（索引）。函数进行处理时，首先检查路由表中是否已有匹配于该包的路由表项，简单来说，就是根据源地址，目标地址以及网络接口编号算出一个hash值，然后在路由表的哈希表中查找该哈希值是否有对应的表项，最后确定该表项是否适用于该包，如果适用，则将表项与sk_buff进行关联，此时一次查找完成，这个sk_buff就找到了去处。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        tos &amp;amp;= IPTOS_RT_MASK;
        hash = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rt_hash&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(daddr, saddr, iif, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rt_genid&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(net));

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rcu_read_lock&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(rth = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rcu_dereference&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(rt_hash_table[hash].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;chain&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;); rth;
             rth = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rcu_dereference&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(rth-&amp;gt;u.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dst&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rt_next&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)) {
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(((rth-&amp;gt;fl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;fl4_dst &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;^ daddr) |
                     (rth-&amp;gt;fl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;fl4_src &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;^ saddr) |
                     (rth-&amp;gt;fl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;iif &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;^ iif) |
                     rth-&amp;gt;fl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;oif &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;|
                     (rth-&amp;gt;fl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;fl4_tos &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;^ tos)) == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;amp;&amp;amp;
                    rth-&amp;gt;fl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;mark &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;== skb-&amp;gt;mark &amp;amp;&amp;amp;
                    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;net_eq&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dev_net&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(rth-&amp;gt;u.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dst&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dev&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;), net) &amp;amp;&amp;amp;
                    !&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rt_is_expired&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(rth)) {
                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dst_use&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;rth-&amp;gt;u.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dst&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, jiffies);
                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RT_CACHE_STAT_INC&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(in_hit);
                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rcu_read_unlock&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;skb_dst_set&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(skb, &amp;amp;rth-&amp;gt;u.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dst&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
                }
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RT_CACHE_STAT_INC&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(in_hlist_search);
        }
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rcu_read_unlock&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上面原理讲的这么简单，但是内核实际的实现是比较凌乱的。首先明确内核路由表使用了RCU实现，这是因为路由子系统现实中是具有一定容错率的，允许对路由表的更新滞后生效，这完美满足了RCU的使用场景。也就是说，已经拿到的路由表缓存不一定严格反映路由表的更改，有一个非常微小的窗口，使部分包看到的路由表仍然是旧的。&lt;&#x2F;p&gt;
&lt;p&gt;对于没有找到对应路由表缓存的情况，函数需要创建路由表缓存项。对于目标地址为组播地址的sk_buff，函数将该工作委托给&lt;code&gt;ip_route_input_mc&lt;&#x2F;code&gt;函数，在此之前，需要进行一个检查。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ipv4_is_multicast&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(daddr)) {
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; in_device *in_dev;

                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rcu_read_lock&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;((in_dev = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__in_dev_get_rcu&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(dev)) != &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) {
                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; our = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ip_check_mc&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(in_dev, daddr, saddr,
                                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ip_hdr&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(skb)-&amp;gt;protocol);
                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(our
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#ifdef&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; CONFIG_IP_MROUTE
                            || (!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ipv4_is_local_multicast&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(daddr) &amp;amp;&amp;amp;
                                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;IN_DEV_MFORWARD&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(in_dev))
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#endif
                            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) {
                                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rcu_read_unlock&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
                                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ip_route_input_mc&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(skb, daddr, saddr,
                                                         tos, dev, our);
                        }
                }
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rcu_read_unlock&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;-EINVAL;
        }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;ip_check_mc&lt;&#x2F;code&gt;函数检查接收到该sk_buff的网卡是否注册到了该组播组中，如果没有则拒绝创建对应缓存表项，本质上就是拒绝接收。&lt;code&gt;ip_route_input_mc&lt;&#x2F;code&gt;函数的本质就是进行一系列合法性检查，并创建对应的路由表项，可以注意到：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(our) {
                rth-&amp;gt;u.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dst&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= ip_local_deliver;
                rth-&amp;gt;rt_flags |= RTCF_LOCAL;
        }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;由于我们是link-local地址，所以our为1，因此路由表项指定的分发函数为&lt;code&gt;ip_local_deliver&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;从前面的&lt;code&gt;ip_rcv_finish&lt;&#x2F;code&gt;可以看到，函数最后调用&lt;code&gt;dst_input&lt;&#x2F;code&gt;进行分发，其本质就是调用该回调函数进行分发操作：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Input packet from network to transport.  *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static inline int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;dst_input&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; sk_buff *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;skb&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;skb_dst&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(skb)-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(skb);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;ip-local-deliver&quot;&gt;ip_local_deliver&lt;&#x2F;h2&gt;
&lt;p&gt;函数如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;*
 *      Deliver IP Packets to the higher protocol layers.
 *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ip_local_deliver&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; sk_buff *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;skb&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;*
         *      Reassemble IP fragments.
         *&#x2F;

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ip_hdr&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(skb)-&amp;gt;frag_off &amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;htons&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(IP_MF | IP_OFFSET)) {
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ip_defrag&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(skb, IP_DEFRAG_LOCAL_DELIVER))
                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
        }

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;NF_HOOK&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(PF_INET, NF_INET_LOCAL_IN, skb, skb-&amp;gt;dev, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
                       ip_local_deliver_finish);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;即如果IP包是分片的，则需要调用&lt;code&gt;ip_defrag&lt;&#x2F;code&gt;函数进行合并处理，我们这里假定是部分片的。因此这里碰到了netfilter的另一个钩子&lt;code&gt;INET_LOCAL_IN&lt;&#x2F;code&gt;，如果包没有被规则拐走，则交由&lt;code&gt;ip_local_deliver_finish&lt;&#x2F;code&gt;处理。在该函数中，通过检测IP头中的protocol字段，即可确定是UDP协议报文，进一步交由UDP协议进行处理：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;                        ret = ipprot-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;handler&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(skb);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static const struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; net_protocol udp_protocol = {
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;handler &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;=      udp_rcv,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;err_handler &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;=  udp_err,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;no_policy &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;=    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;netns_ok &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;=     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;</content>
	</entry>
	<entry xml:lang="en">
		<title>Linux内核在RISC-V架构下的内存屏障与原子操作</title>
		<published>2020-08-14T00:00:00+00:00</published>
		<updated>2020-08-14T00:00:00+00:00</updated>
		<link href="https://crab2313.github.io/riscv-atomic-barrier-bitops/" type="text/html"/>
		<id>https://crab2313.github.io/riscv-atomic-barrier-bitops/</id>
		<content type="html">&lt;p&gt;内存一致性模型是一个体系结构中至关重要的一部分，本质上为软件与硬件之间的契约。软件开发人员可以从内存一致性模型中得知硬件进行内存操作时可能的行为，这是多线程共享内存操作正确性的基石。RISC-V的内存模型被称作RVWMO（RISC-V Weak Memory Order），本质上是&lt;code&gt;Release Consistency&lt;&#x2F;code&gt;与&lt;code&gt;Relaxed Consistency&lt;&#x2F;code&gt;的结合体。本文试图从Linux对内存一致性模型的抽象API入手，分析这些抽象API的用法用例以及对应RISC-V体系结构的实现。&lt;&#x2F;p&gt;
&lt;p&gt;题外话，来总结一下想要理解这部分内容需要哪些知识储备：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;GCC內联汇编基础。上述提到的抽象API有很大一部分都是使用具体体系结构下的汇编代码实现，因此掌握GCC提供的扩展內联汇编是读懂对应实现的必要基础。建议看这本&lt;a href=&quot;https:&#x2F;&#x2F;0xax.gitbooks.io&#x2F;linux-insides&#x2F;content&#x2F;Theory&#x2F;linux-theory-3.html&quot;&gt;简易教程&lt;&#x2F;a&gt;和&lt;a href=&quot;https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc-10.2.0&#x2F;gcc&#x2F;Extended-Asm.html&quot;&gt;GCC官方文档&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;计算机体系结构相关理论。这里没什么多说的，目前大部分体系结构手册都假定读者具有扎实的计算机体系结构理论基础。这里推荐&lt;a href=&quot;https:&#x2F;&#x2F;www.morganclaypool.com&#x2F;doi&#x2F;10.2200&#x2F;S00962ED2V01Y201910CAC049&quot;&gt;《A Primer on Memory Consistency and Cache Coherence, 2nd》&lt;&#x2F;a&gt;，里面有引用一些paper，建议一读。&lt;&#x2F;li&gt;
&lt;li&gt;对应体系结构手册。说到底，内存一致性是体系结构不可分离的一部分，因此熟读体系结构手册是理解对应操作的有力途径。&lt;&#x2F;li&gt;
&lt;li&gt;阅读内核文档。内核的&lt;code&gt;memory-barrier.txt&lt;&#x2F;code&gt;、&lt;code&gt;atomic_t.txt&lt;&#x2F;code&gt;以及&lt;code&gt;atomic_bitops.txt&lt;&#x2F;code&gt;都是极其重要的说明文档。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;nei-cun-ping-zhang&quot;&gt;内存屏障&lt;&#x2F;h2&gt;
&lt;p&gt;RISC-V的内存屏障全部由&lt;code&gt;fence&lt;&#x2F;code&gt;指令实现，第一次读RISC-V手册的人一般会难以相信&lt;code&gt;fence&lt;&#x2F;code&gt;的设计竟然这么简单。&lt;code&gt;fence&lt;&#x2F;code&gt;指令形式如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fence &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;iorw&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;], [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;iorw&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其中&lt;code&gt;[iorw]&lt;&#x2F;code&gt;为&lt;code&gt;iorw&lt;&#x2F;code&gt;中的任选几个字母，其中：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;i：设备内存输入（读取）&lt;&#x2F;li&gt;
&lt;li&gt;o: 设备内存输出（写入）&lt;&#x2F;li&gt;
&lt;li&gt;r：普通内存读取&lt;&#x2F;li&gt;
&lt;li&gt;w：普通内存写入&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;整个指令&lt;code&gt;fence [set1], [set2]&lt;&#x2F;code&gt;的语义为：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;定义predecessor集合为该&lt;code&gt;fence&lt;&#x2F;code&gt;指令之前所有属于&lt;code&gt;[set1]&lt;&#x2F;code&gt;类型的指令之集合&lt;&#x2F;li&gt;
&lt;li&gt;定义successor集合为该&lt;code&gt;fence&lt;&#x2F;code&gt;指令之后所有属于&lt;code&gt;[set2]&lt;&#x2F;code&gt;类型的指令之集合&lt;&#x2F;li&gt;
&lt;li&gt;则其他RISC-V Hart或者外部设备不会观测到successor集合中的指令在predecessor集合中的指令之前发生&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Linux内核中，内存屏障相关的定义都在体系结构对应文件夹下的&lt;code&gt;include&#x2F;asm&#x2F;barrier.h&lt;&#x2F;code&gt;中。其中，对于&lt;code&gt;fence&lt;&#x2F;code&gt;指令的抽象如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;RISCV_FENCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;p&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) \
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;__asm__ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__volatile__ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;fence &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; #p &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; #s : : : &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;memory&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;很显然是一条简单的內联汇编，&lt;code&gt;__volatile__&lt;&#x2F;code&gt;与&lt;code&gt;memory&lt;&#x2F;code&gt;都是用于阻止编译器进行优化的常规操作。后续的实现都是围绕这个宏进行的。&lt;&#x2F;p&gt;
&lt;p&gt;内核中对这些宏的实现策略比较简单，基本原理如下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;asm-generic&lt;&#x2F;code&gt;中的&lt;code&gt;barrier.h&lt;&#x2F;code&gt;中定义默认实现，如果目标架构没有对应实现，则启动默认实现&lt;&#x2F;li&gt;
&lt;li&gt;在&lt;code&gt;arch&#x2F;include&#x2F;asm&#x2F;barrier.h&lt;&#x2F;code&gt;中定义架构特定实现，一般为内联汇编定义&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;mb-rmb-wmb&quot;&gt;mb &amp;amp;&amp;amp; rmb &amp;amp;&amp;amp; wmb&lt;&#x2F;h3&gt;
&lt;p&gt;这三个操作与其对应的&lt;code&gt;smp_*&lt;&#x2F;code&gt;之间最大的区别就是需要对设备内存也生效，所以它们的实现如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;mb&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RISCV_FENCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(iorw,iorw)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;rmb&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RISCV_FENCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(ir,ir)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;wmb&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RISCV_FENCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(ow,ow)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;smp-mb-smp-rmb-smp-wmb&quot;&gt;smp_mb &amp;amp;&amp;amp; smp_rmb &amp;amp;&amp;amp; smp_wmb&lt;&#x2F;h3&gt;
&lt;p&gt;首先一定明确&lt;code&gt;smp_&lt;&#x2F;code&gt;前缀所代表的含义，即“用于SMP（symmetric multi-processor）的”。因此，在内核支持SMP时，它们被定义为其对应的&lt;code&gt;__smp_*&lt;&#x2F;code&gt;，反之则定义为&lt;code&gt;barrier()&lt;&#x2F;code&gt;，即普通的编译器内存屏障，防止编译器进行内存访问重排。前面也提到了，这几个操作并不需要考虑到设备内存，因此它们定义如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__smp_mb&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RISCV_FENCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(rw,rw)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__smp_rmb&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RISCV_FENCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(r,r)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__smp_wmb&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RISCV_FENCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(w,w)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;smp-load-acquire-smp-store-release&quot;&gt;smp_load_acquire &amp;amp;&amp;amp; smp_store_release&lt;&#x2F;h3&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__smp_store_release&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;p&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;v&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)					\
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{									\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;compiletime_assert_atomic_type&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*p);				\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RISCV_FENCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(rw,w);						\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;WRITE_ONCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*p, v);						\
} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__smp_load_acquire&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;p&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)						\
({									\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;typeof&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*p) ___p1 = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;READ_ONCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*p);				\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;compiletime_assert_atomic_type&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*p);				\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RISCV_FENCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(r,rw);						\
	___p1;								\
})
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;还是跟前面提到的一样，带&lt;code&gt;smp_&lt;&#x2F;code&gt;前缀的宏都是只在&lt;code&gt;CONFIG_SMP&lt;&#x2F;code&gt;开启时有定义，否则为空操作。&lt;code&gt;load acquire&lt;&#x2F;code&gt;的定义就是在这个&lt;code&gt;barrier&lt;&#x2F;code&gt;之后的读写不能出现在它之前，且&lt;code&gt;load acquire&lt;&#x2F;code&gt;是读取操作，所以自然使用&lt;code&gt;RISCV_FENCE(r, rw)&lt;&#x2F;code&gt;。&lt;code&gt;store release&lt;&#x2F;code&gt;同理。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yuan-zi-cao-zuo&quot;&gt;原子操作&lt;&#x2F;h2&gt;
&lt;p&gt;可以从&lt;code&gt;arch&#x2F;riscv&#x2F;Kconfig&lt;&#x2F;code&gt;中看到RISC-V平台在非64位时会选择&lt;code&gt;CONFIG_GENERIC_ATOMIC64&lt;&#x2F;code&gt;，如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;config RISCV
        def_bool y
        select ARCH_CLOCKSOURCE_INIT
        select ARCH_SUPPORTS_ATOMIC_RMW
        ......
        select GENERIC_ATOMIC64 if !64BIT   &amp;lt;== 
        select GENERIC_CLOCKEVENTS
        ......
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这点很好理解：在32位下RISC-V架构无法保证64位操作的原子性，因此内核使用通用的64位原子操作实现，通过自旋锁实现64位原子操作，这在&lt;code&gt;arch&#x2F;riscv&#x2F;include&#x2F;asm&#x2F;atomic.h&lt;&#x2F;code&gt;开头中有体现：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#ifdef&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; CONFIG_GENERIC_ATOMIC64
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;# include &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;asm-generic&#x2F;atomic64.h&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#else
# if&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; (__riscv_xlen &amp;lt; 64)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#  error &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;64-bit atomics require XLEN to be at least 64&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;# endif
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#endi
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;原子变量的定义是跨平台的，位于&lt;code&gt;include&#x2F;linux&#x2F;types.h&lt;&#x2F;code&gt;中：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typedef struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; counter;
} atomic_t;

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#ifdef&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; CONFIG_64BIT
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typedef struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
	s64 counter;
} atomic64_t;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#endif
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个原子性由硬件保证，一般来说，一个架构的word大小数据在对齐访问的情况下是可以保证原子性的，具体需要翻看手册。随后是&lt;code&gt;fence&lt;&#x2F;code&gt;指令实现的&lt;code&gt;release acquire&lt;&#x2F;code&gt;语义：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__atomic_acquire_fence&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()					\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;__asm__ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__volatile__&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(RISCV_ACQUIRE_BARRIER &amp;quot;&amp;quot; ::: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;memory&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;)

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__atomic_release_fence&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()					\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;__asm__ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__volatile__&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(RISCV_RELEASE_BARRIER &amp;quot;&amp;quot; ::: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;memory&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个用于&lt;code&gt;atomic-fallback.h&lt;&#x2F;code&gt;中自动生成的函数。对于读写这种&lt;code&gt;non-RMW&lt;&#x2F;code&gt;操作，如你所见就是这么简单：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; __always_inline &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;atomic_read&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; atomic_t *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;v&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;READ_ONCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(v-&amp;gt;counter);
}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; __always_inline &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;atomic_set&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(atomic_t *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;v&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;i&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;WRITE_ONCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(v-&amp;gt;counter, i);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;还是那句话，硬件保证原子性，内核只要保证生成的指令不走样就行了，这也是使用&lt;code&gt;READ_ONCE&lt;&#x2F;code&gt;和&lt;code&gt;WRITE_ONCE&lt;&#x2F;code&gt;的原因。接下来就是重头戏：对于&lt;code&gt;RMW&lt;&#x2F;code&gt;操作实现。RISC-V中定义了原子操作指令，即被称为&lt;code&gt;A&lt;&#x2F;code&gt;的扩展，Linux内核默认要求其已被实现。内核中通过內联汇编模板的方式实现这些操作，也算是比较简洁的了。&lt;&#x2F;p&gt;
&lt;p&gt;对于&lt;code&gt;RMW&lt;&#x2F;code&gt;类的原子操作，我们主要关注其：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;功能正确性&lt;&#x2F;li&gt;
&lt;li&gt;内存序正确性&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;zhi-ling-jian-jie&quot;&gt;指令简介&lt;&#x2F;h3&gt;
&lt;p&gt;先来简单介绍一下RISC-V的原子操作指令。很简单，几句话就可以描述清楚：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;RISC-V的原子操作指令命名类如&lt;code&gt;amo{op}.{w&#x2F;d}.{rl&#x2F;aq&#x2F;aqrl}&lt;&#x2F;code&gt;。第一部分描述功能，如&lt;code&gt;amoadd&lt;&#x2F;code&gt;和&lt;code&gt;amoswap&lt;&#x2F;code&gt;等等，其中&lt;code&gt;amo&lt;&#x2F;code&gt;是&lt;code&gt;atomic memory operation&lt;&#x2F;code&gt;的缩写。第二部分为操作数据的长度，w（word）表示32位，d（double word）表示32位。第三部分比较有意思，RISC-V的原子操作指令中encode了两位，分别&lt;code&gt;acquire&lt;&#x2F;code&gt;和&lt;code&gt;release&lt;&#x2F;code&gt;，使其具有了内存序属性，看得出来是对OS进行了高度优化的。&lt;&#x2F;li&gt;
&lt;li&gt;RISC-V的原子操作指令编码了三个寄存器：&lt;code&gt;rs1&lt;&#x2F;code&gt;、&lt;code&gt;rs2&lt;&#x2F;code&gt;和&lt;code&gt;rd&lt;&#x2F;code&gt;。其中&lt;code&gt;rs1&lt;&#x2F;code&gt;为原子变量的内存地址，&lt;code&gt;rs2&lt;&#x2F;code&gt;是该操作的另一个操作数（operand）。指令执行时，首先从&lt;code&gt;rs1&lt;&#x2F;code&gt;指向的内存中取出原子变量的值，保存在&lt;code&gt;rd&lt;&#x2F;code&gt;寄存器，然后与&lt;code&gt;rs2&lt;&#x2F;code&gt;进行操作，最后将结果保存回&lt;code&gt;rs1&lt;&#x2F;code&gt;指向的内存地址。这里注意RISC-V的原子操作可以将变量的地址保存在&lt;code&gt;rd&lt;&#x2F;code&gt;寄存器，如果不需要可用&lt;code&gt;zero&lt;&#x2F;code&gt;寄存器当作&lt;code&gt;rd&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;wu-fan-hui-zhi-yuan-zi-cao-zuo-han-shu&quot;&gt;无返回值原子操作函数&lt;&#x2F;h3&gt;
&lt;p&gt;顾名思义，就是没有返回值的&lt;code&gt;RMW&lt;&#x2F;code&gt;类原子操作函数，注意这类函数在内核中是没有内存序要求的。可以看到这类函数使用一个通用的模板生成：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ATOMIC_OP&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;op&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;asm_op&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;I&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;asm_type&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;c_type&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;prefix&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)		\
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; __always_inline							\
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; atomic##prefix##_##&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;op&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(c_type i, atomic##prefix##_t *v)		\
{									\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;__asm__ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__volatile__ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(						\
		&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;	amo&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; #asm_op &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; #asm_type &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt; zero, %1, %0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;	\
		: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;+A&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (v-&amp;gt;counter)					\
		: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (I)						\
		: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;memory&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;);						\
}			
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;很简单，唯一需要注意的就是这个&lt;code&gt;+A&lt;&#x2F;code&gt;。从GCC官方的&lt;a href=&quot;https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Machine-Constraints.html#Machine-Constraints&quot;&gt;文档&lt;&#x2F;a&gt;中可以看到，&lt;code&gt;A&lt;&#x2F;code&gt;是RISC-V中单独定义的，表示一个存放着内存地址的寄存器变量。且返回值寄存器被设置成&lt;code&gt;zero&lt;&#x2F;code&gt;，以示忽略。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ATOMIC_OPS&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;op&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;asm_op&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;I&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)					\
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ATOMIC_OP &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(op, asm_op, I, w, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,   )				\
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ATOMIC_OP &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(op, asm_op, I, d, s64, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;64&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#endif

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ATOMIC_OPS&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(add, add,  i)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ATOMIC_OPS&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(sub, add, -i)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ATOMIC_OPS&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(and, and,  i)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ATOMIC_OPS&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;( or,  or,  i)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ATOMIC_OPS&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(xor, xor,  i)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;you-fan-hui-zhi-yuan-zi-cao-zuo-han-shu&quot;&gt;有返回值原子操作函数&lt;&#x2F;h3&gt;
&lt;p&gt;内核中，有返回值原子操作函数分为&lt;code&gt;fetch&lt;&#x2F;code&gt;和&lt;code&gt;return&lt;&#x2F;code&gt;。这二者的区别为&lt;code&gt;fetch&lt;&#x2F;code&gt;返回原子变量原有的值，而&lt;code&gt;return&lt;&#x2F;code&gt;返回原子变量经过操作的值。我们可以从内核中的&lt;code&gt;atomic_t.txt&lt;&#x2F;code&gt;文档中知道，默认情况下，有返回值的原子操作函数都是有内存序的。且函数具有一些加了特殊后缀的变体，可以指定内存序语义，如&lt;code&gt;_relaxed&lt;&#x2F;code&gt;、&lt;code&gt;_acquire&lt;&#x2F;code&gt;和&lt;code&gt;_release&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ATOMIC_FETCH_OP&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;op&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;asm_op&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;I&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;asm_type&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;c_type&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;prefix&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)	\
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; __always_inline							\
c_type atomic##prefix##_fetch_##op##&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_relaxed&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(c_type i,			\
					     atomic##prefix##_t *v)	\
{									\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;register&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; c_type ret;						\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;__asm__ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__volatile__ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(						\
		&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;	amo&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; #asm_op &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; #asm_type &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt; %1, %2, %0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;	\
		: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;+A&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (v-&amp;gt;counter), &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;=r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (ret)				\
		: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (I)						\
		: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;memory&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;);						\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ret;							\
}									\
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; __always_inline							\
c_type atomic##prefix##_fetch_##&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;op&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(c_type i, atomic##prefix##_t *v)	\
{									\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;register&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; c_type ret;						\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;__asm__ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__volatile__ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(						\
		&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;	amo&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; #asm_op &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; #asm_type &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.aqrl  %1, %2, %0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;	\
		: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;+A&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (v-&amp;gt;counter), &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;=r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (ret)				\
		: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (I)						\
		: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;memory&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;);						\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ret;							\
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到&lt;code&gt;fetch&lt;&#x2F;code&gt;函数的內联汇编模板也分两套，对于&lt;code&gt;_relaxed&lt;&#x2F;code&gt;函数，没有加上&lt;code&gt;.aqrl&lt;&#x2F;code&gt;，即不指定内存序语义。&lt;code&gt;return&lt;&#x2F;code&gt;函数实际上就是&lt;code&gt;fetch&lt;&#x2F;code&gt;函数返回值经过重新计算得出，不再赘述，注意想清楚&lt;code&gt;atomic&lt;&#x2F;code&gt;的操作究竟在哪，就不会有&lt;code&gt;return&lt;&#x2F;code&gt;函数不是原子操作的错觉。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;atomic-fetch-add-unless-atomic-sub-if-positive&quot;&gt;atomic_fetch_add_unless &amp;amp;&amp;amp; atomic_sub_if_positive&lt;&#x2F;h3&gt;
&lt;p&gt;RISC-V结构下对这两个函数做了实现，且都是利用了&lt;code&gt;LR&#x2F;SC&lt;&#x2F;code&gt;指令。先来看一下它们实现的功能：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;atomic_fetch_add_unless&lt;&#x2F;code&gt;有两个额外参数&lt;code&gt;a&lt;&#x2F;code&gt;和&lt;code&gt;u&lt;&#x2F;code&gt;，进行操作时，如果原子变量的值与&lt;code&gt;u&lt;&#x2F;code&gt;不相等，则将其加上&lt;code&gt;a&lt;&#x2F;code&gt;，并返回原先的值。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;atomic_sub_if_positive&lt;&#x2F;code&gt;从名字上就可以看出来功能：如果原子变量的值是正的，则将其减去参数传入的值，并返回最后的结果。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;前面提到这两个操作是&lt;code&gt;LR&#x2F;SC&lt;&#x2F;code&gt;指令实现的，那么先简介一下这对指令是如何工作的：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;LR指令是&lt;code&gt;load reserved&lt;&#x2F;code&gt;的缩写，它首先会读取一个内存地址的值，然后在该内存地址做标记。&lt;&#x2F;li&gt;
&lt;li&gt;SC指令是&lt;code&gt;store conditional&lt;&#x2F;code&gt;的缩写，它的作用写将一个值写入一个内存地址。对于同一个&lt;code&gt;HART&lt;&#x2F;code&gt;，&lt;code&gt;SC&lt;&#x2F;code&gt;首先检查标记的值是否正确，如果正确才进行写入操作，否则返回错误。注意无论如何对应地址的标记都会被&lt;code&gt;SC&lt;&#x2F;code&gt;指令清除。&lt;&#x2F;li&gt;
&lt;li&gt;LR和SC配合使用，其意义在于：如果SC指令成功执行，则意味着在LR到SC指令这一段时间内，没有其他的&lt;code&gt;HART&lt;&#x2F;code&gt;对这个地址进行访问（因为标记没有失效）。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;__asm__ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__volatile__ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(
		&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;0:	lr.w     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%[p]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%[c]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
		&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;	beq      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%[p]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%[u]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;, 1f&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
		&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;	add      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%[rc]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%[p]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%[a]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
		&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;	sc.w.rl  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%[rc]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%[rc]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%[c]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
		&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;	bnez     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%[rc]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;, 0b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
		&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;	fence    rw, rw&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
		&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;1:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
		: [p]&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;=&amp;amp;r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (prev), [rc]&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;=&amp;amp;r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (rc), [c]&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;+A&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (v-&amp;gt;counter)
		: [a]&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (a), [u]&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (u)
		: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;memory&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到本质是通过循环调用&lt;code&gt;LR&#x2F;SC&lt;&#x2F;code&gt;对，不断尝试，如果成功，则说明这段时间内没有人访问原子变量，操作成功独占，故而肯定是原子的。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Linux内核在RISC-V架构下的setup_arch与异常处理</title>
		<published>2020-08-05T00:00:00+00:00</published>
		<updated>2020-08-05T00:00:00+00:00</updated>
		<link href="https://crab2313.github.io/riscv-setup-arch-exception/" type="text/html"/>
		<id>https://crab2313.github.io/riscv-setup-arch-exception/</id>
		<content type="html">&lt;p&gt;在分析完Linux内核在RISC-V架构下的启动流程后，我们分析Linux下与RISC-V相关的架构相关实现。很明显，这类知识都是非常零散的，这里使用的入手点为&lt;code&gt;setup_arch&lt;&#x2F;code&gt;的实现。&lt;&#x2F;p&gt;
&lt;p&gt;在开始分析之前，一定要对Linux内核的架构相关代码有一定的认识，这里做一个原理性的说明。Linux内核的codebase可以简单分成两个部分：架构相关部分和架构无关部分。为了支持多个架构，且最大限度地公用代码，又保留架构相关实现的灵活性，Linux内核的实现经过了精细的设计。内核底层对一些架构相关的操作进行了抽象，向内核通用代码提供了公共的接口。每一个内核支持的架构都对应一个&lt;code&gt;arch&#x2F;&lt;&#x2F;code&gt;下的文件夹，里面存放着本架构相关的代码。&lt;&#x2F;p&gt;
&lt;p&gt;接下来简要介绍一下内核实现多架构支持的手段：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;条件编译。这个方法主要用在一些极端特殊场合，多用于驱动对特定平台的区别操作。内核提供了一些宏，用于检测当前架构。&lt;&#x2F;li&gt;
&lt;li&gt;weak函数。这个方法利用了ELF object文件中的&lt;code&gt;weak symbol&lt;&#x2F;code&gt;，具有这个属性的&lt;code&gt;symbol&lt;&#x2F;code&gt;在链接时，如果链接器可以在所有进行链接的object文件中找到同名&lt;code&gt;symbol&lt;&#x2F;code&gt;，则会用这个&lt;code&gt;symbol&lt;&#x2F;code&gt;把&lt;code&gt;weak symbol&lt;&#x2F;code&gt;顶替掉。内核使用&lt;code&gt;__weak&lt;&#x2F;code&gt;（本质就是一个GCC扩展）标记weak函数。内核可以对所有架构实现一个通用的weak函数，如果有架构需要一个自己的版本，则可以直接定义，并将其顶替。&lt;&#x2F;li&gt;
&lt;li&gt;平台相关函数。这类函数为强平台相关，内核一般定义一个共同函数原型及函数语意，由各架构自行实现该函数。这里其实也包括一部分宏。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;setup-arch&quot;&gt;setup_arch&lt;&#x2F;h2&gt;
&lt;p&gt;阅读过任何一本内核书的人对这个函数一定不陌生。这个函数主要做架构相关的初始化操作。函数首先设置&lt;code&gt;init_mm&lt;&#x2F;code&gt;上的四个变量，前面提到过，&lt;code&gt;_stext&lt;&#x2F;code&gt;等变量是通过链接脚本放到内核二进制文件特定地址的，通过他们可以获取内核内存布局的范围。注意这里已经开启MMU了，且RISC-V内核使用的是PC相对寻址，因此这时获取的是对应的虚拟地址。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	init_mm.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;start_code &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) _stext;
	init_mm.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;end_code   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) _etext;
	init_mm.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;end_data   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) _edata;
	init_mm.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;brk        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) _end;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;she-bei-shu-yu-can-shu-jie-xi&quot;&gt;设备树与参数解析&lt;&#x2F;h3&gt;
&lt;p&gt;在这个阶段，设备树并没有完全进行解析，内核只需要提取一小部分重要信息即可。回顾原先的分析，&lt;code&gt;_start_kernel&lt;&#x2F;code&gt;在调用&lt;code&gt;start_kernel&lt;&#x2F;code&gt;前调用了&lt;code&gt;parse_dtb&lt;&#x2F;code&gt;函数，如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; __init &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;parse_dtb&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;early_init_dt_scan&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(dtb_early_va))
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;

	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pr_err&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;No DTB passed to the kernel&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#ifdef&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; CONFIG_CMDLINE_FORCE
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;strlcpy&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(boot_command_line, CONFIG_CMDLINE, COMMAND_LINE_SIZE);
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pr_info&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Forcing kernel command line to: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, boot_command_line);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#endif
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个函数简单调用了设备树（OF）模块的通用函数&lt;code&gt;early_init_dt_scan&lt;&#x2F;code&gt;，从设备树中解析并设置一些基本的信息。这里简单分析一下获取了哪些信息。在简单检查设备树的合法性之后，可以看到进行了如下操作：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Retrieve various information from the &#x2F;chosen node *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	rc = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;of_scan_flat_dt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(early_init_dt_scan_chosen, boot_command_line);
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(!rc)
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pr_warn&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;No chosen node found, continuing without&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;);

	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Initialize {size,address}-cells info *&#x2F;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;of_scan_flat_dt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(early_init_dt_scan_root, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);

	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Setup memory, calling early_init_dt_add_memory_arch *&#x2F;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;of_scan_flat_dt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(early_init_dt_scan_memory, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;总结如下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;扫描设备树的&lt;code&gt;chosen&lt;&#x2F;code&gt;节点，获取内核命令行，initrd等关键信息，其中内核并命令行被保存在&lt;code&gt;boot_command_line&lt;&#x2F;code&gt;字符数组中&lt;&#x2F;li&gt;
&lt;li&gt;扫描&lt;code&gt;&#x2F;&lt;&#x2F;code&gt;节点下的&lt;code&gt;#address-cells&lt;&#x2F;code&gt;，&lt;code&gt;#size-cells&lt;&#x2F;code&gt;等信息并记录&lt;&#x2F;li&gt;
&lt;li&gt;扫描&lt;code&gt;memory&lt;&#x2F;code&gt;节点信息，获取设备树中关于内存的描述，并调用&lt;code&gt;early_init_dt_add_memory_arch&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;code&gt;early_init_dt_add_memory_arch&lt;&#x2F;code&gt;函数RISC-V使用了内核默认的实现，即将内核区域添加到&lt;code&gt;memblock&lt;&#x2F;code&gt;中。也就是说，RISC-V架构下的启动内存管理器是memblock，memblock的实现比较独立，另开文档进行分析。&lt;&#x2F;p&gt;
&lt;p&gt;在&lt;code&gt;setup_arch&lt;&#x2F;code&gt;中调用了&lt;code&gt;parse_early_param&lt;&#x2F;code&gt;通用函数，用于解析&lt;code&gt;early param&lt;&#x2F;code&gt;。内核中的&lt;code&gt;early param&lt;&#x2F;code&gt;都会特殊标记起来，保存在一个特殊的section里，在内核启动初期从内核命令行解析出来。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;memblockchu-shi-hua&quot;&gt;memblock初始化&lt;&#x2F;h3&gt;
&lt;p&gt;前面看到，内核中设备树解析的通用代码将设备树中设定的可用内存区域传递给&lt;code&gt;memblock&lt;&#x2F;code&gt;进行管理。而在&lt;code&gt;setup_arch&lt;&#x2F;code&gt;中则调用&lt;code&gt;setup_bootmem&lt;&#x2F;code&gt;初始化memblock。&lt;&#x2F;p&gt;
&lt;p&gt;前面已经看到，从设备树中读取到的可用物理内存范围已经在内核默认的&lt;code&gt;early_init_dt_add_memory_arch&lt;&#x2F;code&gt;中加入到了memblock管理器中。此时，memblock还需要进行一些别的操作，使其可用。首当其冲的就是保留特定物理内存，这一点是比较容易想到的。一般情况下，设备树描述的是整个板子可用的物理内存区域，内核二进制，设备树二进制装载进内存时也会占用其中一部分空间，这就需要&lt;code&gt;setup_bootmem&lt;&#x2F;code&gt;函数手动保留这些区域。&lt;&#x2F;p&gt;
&lt;p&gt;如果读过设备树的标准，则应该知道，设备树中存在&lt;code&gt;reserved memory&lt;&#x2F;code&gt;的描述，因此&lt;code&gt;setup_bootmem&lt;&#x2F;code&gt;调用&lt;code&gt;early_init_fdt_scan_reserved_mem&lt;&#x2F;code&gt;函数进行扫描，然后将对应参数进行保留。最后函数将所有物理内存区域的NUMA节点设置为0。&lt;&#x2F;p&gt;
&lt;p&gt;这里还有一个点可以稍微提一下：在RISC-V体系结构下，如果开启两级页表，那么最大能够支持的物理内存大小是2GB，如果可用物理内存大小超过了2GB，页表是无法进行映射的。&lt;code&gt;setup_bootmem&lt;&#x2F;code&gt;函数因此进行了一项修复，即将超出最大支持范围的物理内存区域从bootmem中移除，避免对其的访问。对二进制比较敏感的话，可以想到，这一大小正好是&lt;code&gt;-PAGE_OFFSET&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;paging-init&quot;&gt;paging_init&lt;&#x2F;h3&gt;
&lt;p&gt;从名字上就可以看出这个函数是干什么的：初始化页表。前一篇文档看到内核在&lt;code&gt;setup_vm&lt;&#x2F;code&gt;中初始化了一个&lt;code&gt;early_pg_dir&lt;&#x2F;code&gt;页表，仅仅映射了内核所占用内存和一个FDT的fixmap，而&lt;code&gt;paging_init&lt;&#x2F;code&gt;中的&lt;code&gt;setup_vm_final&lt;&#x2F;code&gt;则是该操作的延续。首先明确使用两级初始化的原因：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;在没有读取设备树之前，内核是不知道物理内存的大小的。如果非要缩成一步，那么只能从内核所在内存结尾处开始，猜一个大小然后进行映射。这种实现有巨大的不确定性，并不是一个好的选择&lt;&#x2F;li&gt;
&lt;li&gt;紧接上一条，这么做有可能需要映射一些不存在的内存区域，使得页表占用更多空间&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;所以&lt;code&gt;setup_vm_final&lt;&#x2F;code&gt;的操作本质上就是将memblock中管理的内存添加到到&lt;code&gt;swapper_pg_dir&lt;&#x2F;code&gt;页表中，然后启用该页表。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;paging_init&lt;&#x2F;code&gt;随后初始化&lt;code&gt;Sparse Memory&lt;&#x2F;code&gt;，当然我们这里没有开启其对应支持，不予分析。&lt;code&gt;setup_zero_page&lt;&#x2F;code&gt;函数将内核预先在BSS中预留的一个page进行初始化操作（全写0）。&lt;code&gt;zone_size_init&lt;&#x2F;code&gt;函数实现比较简单，但是原先分析时漏掉了一点，这里补上。&lt;&#x2F;p&gt;
&lt;p&gt;目前的内核已经把bootmem去掉了，但是它的影响依然在内核中。&lt;code&gt;setup_bootmem&lt;&#x2F;code&gt;函数中设置了几个变量，如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;set_max_mapnr&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;PFN_DOWN&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(mem_size));
	max_pfn = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;PFN_DOWN&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;memblock_end_of_DRAM&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;());
	max_low_pfn = max_pfn;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这几个静态变量的意义如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;    min_low_pfn - the lowest PFN that is available in the system
    max_low_pfn - the highest PFN that may be addressed by low memory (ZONE_NORMAL)
    max_pfn - the last PFN available to the system.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;zone_size_init&lt;&#x2F;code&gt;如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; __init &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;zone_sizes_init&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; max_zone_pfns[MAX_NR_ZONES] = { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, };

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#ifdef&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; CONFIG_ZONE_DMA32
	max_zone_pfns[ZONE_DMA32] = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;PFN_DOWN&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;min&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;UL &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* SZ_1G,
			(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;PFN_PHYS&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(max_low_pfn)));
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#endif
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	max_zone_pfns[ZONE_NORMAL] = max_low_pfn;

	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;free_area_init_nodes&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(max_zone_pfns);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到&lt;code&gt;ZONE_DMA32&lt;&#x2F;code&gt;的边界为4GB，这基本就是废话。记住这里初始化了&lt;code&gt;pg_data_t&lt;&#x2F;code&gt;就行了。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;unflatten-device-tree&quot;&gt;unflatten_device_tree&lt;&#x2F;h3&gt;
&lt;p&gt;该函数为OF模块的代码，目的是将设备树转换成更高效的内存中表示。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;sbi-init-setup-smp-riscv-fill-hwcap&quot;&gt;sbi_init &amp;amp;&amp;amp; setup_smp &amp;amp;&amp;amp; riscv_fill_hwcap&lt;&#x2F;h3&gt;
&lt;p&gt;这些非常独立的部分单独进行分析。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jin-cheng-guan-li&quot;&gt;进程管理&lt;&#x2F;h2&gt;
&lt;p&gt;进程管理与体系结构相关的地方基本就是上下文切换了，在内核一般被称为switch。为了高速进行上下文切换，这个过程涉及的一部分数据结构和相关操作是与体系结构强相关的。&lt;strong&gt;任务&lt;&#x2F;strong&gt;上下文切换的基本执行操作由&lt;code&gt;__switch_to&lt;&#x2F;code&gt;完成，一般会再包装一层&lt;code&gt;switch_to&lt;&#x2F;code&gt;，现在以这个函数入手，分析RISC-V平台下对应的实现。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;__switch_to&lt;&#x2F;code&gt;在各个体系结构下有对应的实现，是体系结构强相关的。这是因为其基本行为就是保存当前CPU的执行状态，然后再装载一个其他的执行状态，这其中涉及到的寄存器保存等操作在每个体系结构都不一样。&lt;code&gt;__switch_to&lt;&#x2F;code&gt;函数在RISC-V下由汇编实现，位于&lt;code&gt;arch&#x2F;riscv&#x2F;kernel&#x2F;entry.S&lt;&#x2F;code&gt;中，如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ENTRY(__switch_to)
        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Save context &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;into &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;prev&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&amp;gt;thread &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        li    a4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_THREAD_RA
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;a3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;a0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;a4
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;a4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;a1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;a4
        REG_S ra&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_THREAD_RA_RA(a3)
        REG_S &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_THREAD_SP_RA(a3)
        REG_S s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_THREAD_S0_RA(a3)
        REG_S s1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_THREAD_S1_RA(a3)
        REG_S s2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_THREAD_S2_RA(a3)
        ...
        REG_S s11&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_THREAD_S11_RA(a3)
        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Restore context from next&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&amp;gt;thread &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        REG_L ra&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_THREAD_RA_RA(a4)
        REG_L &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_THREAD_SP_RA(a4)
        REG_L s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_THREAD_S0_RA(a4)
        REG_L s1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_THREAD_S1_RA(a4)
        ...
        REG_L s11&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_THREAD_S11_RA(a4)
        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Swap the &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;CPU &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;entry around. &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        lw a3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_TI_&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;CPU&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(a0)
        lw a4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_TI_&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;CPU&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(a1)
        sw a3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_TI_&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;CPU&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(a1)
        sw a4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_TI_&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;CPU&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(a0)
#if TASK_TI != &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;#error &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;TASK_TI != 0: tp will contain a &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;struct thread_info&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;#39;, not a &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;struct task_struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;#39; so get_current() won&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;t work.&amp;quot;
        addi tp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;a1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_TI
#else
        move tp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;a1
#endif
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ret
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ENDPROC(__switch_to)

&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;实现是比较简单的，这里稍微解读一下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a0&lt;&#x2F;code&gt;和&lt;code&gt;a1&lt;&#x2F;code&gt;分别为进行上下文切换的两个&lt;code&gt;task_struct&lt;&#x2F;code&gt;地址&lt;&#x2F;li&gt;
&lt;li&gt;需要保存的执行状态被称作&lt;code&gt;thread_struct&lt;&#x2F;code&gt;，与体系结构相关，被定义在&lt;code&gt;asm&#x2F;processor.h&lt;&#x2F;code&gt;中。或许有人会奇怪为什么保存的寄存器这么少，只有&lt;code&gt;ra&lt;&#x2F;code&gt;，&lt;code&gt;sp&lt;&#x2F;code&gt;，&lt;code&gt;s0&lt;&#x2F;code&gt;-&lt;code&gt;s11&lt;&#x2F;code&gt;。这个解释比较简单，注意它们在RISC-V ABI中被称作&lt;code&gt;Callee-Saved&lt;&#x2F;code&gt;寄存器，被调用函数方需要保存的寄存器，反之就是其他寄存器已经被调用方保存过了（栈上）。也就是说&lt;code&gt;__switch_to&lt;&#x2F;code&gt;只需要保存这些没有被保存的寄存器，结合栈上原有的寄存器，即可还原处理器状态。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;tp&lt;&#x2F;code&gt;寄存器全称&lt;code&gt;thread pointer&lt;&#x2F;code&gt;，在内核态中用于保存当前&lt;code&gt;task_struct&lt;&#x2F;code&gt;的指针。上下文切换时，需要更改该寄存器。&lt;&#x2F;li&gt;
&lt;li&gt;注意&lt;code&gt;__switch_to&lt;&#x2F;code&gt;函数有返回值，返回值为&lt;code&gt;a0&lt;&#x2F;code&gt;。注意&lt;code&gt;a0&lt;&#x2F;code&gt;从头到尾没有变化，正确理解这个行为其实就是正确理解上下文切换的关键。&lt;&#x2F;li&gt;
&lt;li&gt;最后一个细节，&lt;code&gt;TASK_TI_CPU&lt;&#x2F;code&gt;等常量是哪里来的呢。这个问题本质为C与汇编的互通有无问题，如果想要在汇编中访问结构体的字段，其常规操作为结构体指针加上一个偏移量。&lt;code&gt;Kbuild&lt;&#x2F;code&gt;提供了&lt;code&gt;asm-offsets.h&lt;&#x2F;code&gt;机制，开发者只需要在&lt;code&gt;asm-offsets.c&lt;&#x2F;code&gt;中定义macro和其对应的结构体和结构体中的字段，内核的&lt;code&gt;Kbuild&lt;&#x2F;code&gt;即可自行生成&lt;code&gt;asm-offsets.h&lt;&#x2F;code&gt;供汇编代码引用。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* CPU-specific state of a task *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;thread_struct {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Callee-saved registers *&#x2F;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ra;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; sp;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Kernel mode stack *&#x2F;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; s[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;];	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* s[0]: frame pointer *&#x2F;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; __riscv_d_ext_state fstate;
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上面是不是少了什么东西？很明显少了浮点和向量寄存器的处理。很多书上其实写明白了，内核中并不使用浮点或者向量指令，因此这两类指令相关的寄存器管理是需要区别对待的。这方面一个比较普遍的优化原理就是内核对用户态进程对于浮点或者向量指令的使用进行检测，仅当用户态使用了时才在上下文切换时记录对应的状态。来看RISC-V是如何实现真正的上下文入口&lt;code&gt;switch_to&lt;&#x2F;code&gt;的：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;switch_to&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;prev&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;next&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;last&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)			\
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{							\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; task_struct *__prev = (prev);		\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; task_struct *__next = (next);		\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(has_fpu)					\
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__switch_to_aux&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(__prev, __next);	\
	((last) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__switch_to&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(__prev, __next));		\
} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;和其他体系结构大同小异，&lt;code&gt;switch_to&lt;&#x2F;code&gt;是一个宏，它的参数意义大部分书中都有涉及，这里只详细解释一下&lt;code&gt;last&lt;&#x2F;code&gt;参数的行为在RISC-V下是如何实现的。首先一定要明确&lt;code&gt;__prev&lt;&#x2F;code&gt; 和&lt;code&gt;__next&lt;&#x2F;code&gt;这两个变量的声明，这两个变量是保存在&lt;strong&gt;栈上&lt;&#x2F;strong&gt;的，只要栈（指针）发生了改变，那么这两个变量的值就会发生改变。调用&lt;code&gt;__switch_to&lt;&#x2F;code&gt;函数时，参数通过&lt;code&gt;a0&lt;&#x2F;code&gt;传入，因此&lt;code&gt;__switch_to&lt;&#x2F;code&gt;的&lt;code&gt;a0&lt;&#x2F;code&gt;一定是上一次上下文切换时的&lt;code&gt;task_struct&lt;&#x2F;code&gt;，假设其为A。而当&lt;code&gt;__switch_to&lt;&#x2F;code&gt;执行完毕之后，由于栈指针发生了改变，变为A被上下文切换时的栈指针，此时的&lt;code&gt;__prev&lt;&#x2F;code&gt;变为了A被上下文切换时处理器执行的前一个任务。&lt;&#x2F;p&gt;
&lt;p&gt;回归重点，即当&lt;code&gt;has_fpu&lt;&#x2F;code&gt;为&lt;code&gt;true&lt;&#x2F;code&gt;时的&lt;code&gt;__switch_to_aux&lt;&#x2F;code&gt;路径。内核提供&lt;code&gt;CONFIG_FPU&lt;&#x2F;code&gt;选项配置内核对FPU的支持，在支持FPU的情况下，如果&lt;code&gt;status&lt;&#x2F;code&gt;寄存器的&lt;code&gt;SD&lt;&#x2F;code&gt;位被设置，说明需要保存FPU状态，此时内核调用&lt;code&gt;fstate_save&lt;&#x2F;code&gt;函数将FPU寄存器保存。如果被切换到的任务的浮点寄存器已被使用，则将其状态恢复：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static inline void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fstate_restore&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; task_struct *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;task&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
				  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; pt_regs *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;regs&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;((regs-&amp;gt;status &amp;amp; SR_FS) != SR_FS_OFF) {
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__fstate_restore&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(task);
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__fstate_clean&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(regs);
	}
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;zhong-duan-yi-chang-yu-xi-tong-diao-yong&quot;&gt;中断、异常与系统调用&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;code&gt;start_kernel&lt;&#x2F;code&gt;函数的开头会调用&lt;code&gt;local_irq_disable&lt;&#x2F;code&gt;将当前CPU的中断处理关闭，这是非常正常的，毕竟这个阶段内核没有做好处理中断的准备，而此时的中断向量也是&lt;code&gt;head.S&lt;&#x2F;code&gt;中利用&lt;code&gt;trampoline&lt;&#x2F;code&gt;进行虚拟地址跳跃时设置的。RISC-V下的中断向量是&lt;code&gt;trap_init&lt;&#x2F;code&gt;中设置的，定义在&lt;code&gt;arch&#x2F;riscv&#x2F;traps.c&lt;&#x2F;code&gt;中，如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;trap_init&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;*
	 * Set sup0 scratch register to 0, indicating to exception vector
	 * that we are presently executing in the kernel
	 *&#x2F;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;csr_write&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(CSR_SCRATCH, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Set the exception vector address *&#x2F;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;csr_write&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(CSR_TVEC, &amp;amp;handle_exception);
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Enable interrupts *&#x2F;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;csr_write&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(CSR_IE, IE_SIE);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;对于&lt;code&gt;CSR_SCRATCH&lt;&#x2F;code&gt;寄存器的设计用途，RISC-V的手册中讲的不明所以，这在后续的代码分析中就会明晰。&lt;code&gt;traps_init&lt;&#x2F;code&gt;函数随后将中断向量设置为&lt;code&gt;handle_exception&lt;&#x2F;code&gt;函数的地址，并将软件中断打开。在处理器不同状态之间跳转的代码一般实现在体系结构对应的&lt;code&gt;entry.S&lt;&#x2F;code&gt;中，RISC-V也不例外。这里注意&lt;code&gt;CSR_TVEC&lt;&#x2F;code&gt;的最低两位是中断处理模式，由于RISC-V指令为4字节对齐，那么这个模式位必为0，也就是所有的中断都会由&lt;code&gt;handle_exception&lt;&#x2F;code&gt;处理。&lt;&#x2F;p&gt;
&lt;p&gt;传统意义上的I&#x2F;O中断，异常，以及系统调用都由&lt;code&gt;handle_exception&lt;&#x2F;code&gt;进行处理，这就意味着该函数的实现相对复杂，需要好好梳理。从这个函数中我们也可以分析出&lt;code&gt;CSR_SCRATCH&lt;&#x2F;code&gt;寄存器是如何使用的。Linux内核使用&lt;code&gt;CSR_SCRATCH&lt;&#x2F;code&gt;寄存器保存当前特权级对立特权级（内核态对应用户态，用户态对应内核态）的&lt;code&gt;tp&lt;&#x2F;code&gt;寄存器的值，且如果&lt;code&gt;CSR_SCRATCH&lt;&#x2F;code&gt;为0则表示中断是在内核态触发的。函数开头如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ENTRY(handle_exception)
	&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*
	 * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;If coming from userspace&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;preserve the user thread pointer &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;and &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;load
	 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;the kernel thread pointer.  If we came from the kernel&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;the scratch
	 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;register will contain &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;and &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;we should continue on the current TP.
	 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
	csrrw tp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;CSR_SCRATCH&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;tp
	bnez tp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;_save_context

_restore_kernel_tpsp:
	csrr tp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;CSR_SCRATCH
	REG_S &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_TI_KERNEL_SP(tp)
_save_context:
	...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;即先将当前&lt;code&gt;tp&lt;&#x2F;code&gt;的值与&lt;code&gt;CSR_SCRATCH&lt;&#x2F;code&gt;的值进行交换，如果发现&lt;code&gt;CSR_SCRATCH&lt;&#x2F;code&gt;的值为0，则明显是由内核态跳入异常处理的，此时需要将&lt;code&gt;tp&lt;&#x2F;code&gt;寄存器的值还原，并将此时的内核栈指针保存在&lt;code&gt;struct thread_info&lt;&#x2F;code&gt;的&lt;code&gt;kernel_sp&lt;&#x2F;code&gt;字段中。从函数中可以看到，&lt;code&gt;thread_info-&amp;gt;kernel_sp&lt;&#x2F;code&gt;的值在每次进入异常处理时都会被写掉，但由于&lt;code&gt;handle_exception&lt;&#x2F;code&gt;记录了&lt;code&gt;pt_regs&lt;&#x2F;code&gt;，因此异常退出时该值可以被还原。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;_save_context&lt;&#x2F;code&gt;本质上是在栈上保存一个&lt;code&gt;pt_regs&lt;&#x2F;code&gt;，不赘述。随后&lt;code&gt;CSR_SCRATCH&lt;&#x2F;code&gt;被写0用以标记内核态，如前面所述。接下来装载&lt;code&gt;gp&lt;&#x2F;code&gt;寄存器，这对C语言运行环境是至关重要的。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;	&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Load the &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;global &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;pointer &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
.option &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;push
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.option norelax
	la gp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__global_pointer$
.option po
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;注意&lt;code&gt;norelax&lt;&#x2F;code&gt;属性可以要求链接器不对标记区域的指令进行重排优化操作。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhong-duan&quot;&gt;中断&lt;&#x2F;h3&gt;
&lt;p&gt;可以通过&lt;code&gt;CSR_CAUSE&lt;&#x2F;code&gt;的最高位确定当前是否是中断，所以有如下实现：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;	la ra&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ret_from_exception
	&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*
	 * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;MSB of cause differentiates between
	 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;interrupts &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;and &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;exceptions
	 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
	bge s4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;zero&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;1f

	&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Handle interrupts &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
	move a0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;pt_regs &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
	tail do_IRQ
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;函数&lt;code&gt;do_IRQ&lt;&#x2F;code&gt;的返回地址被设置成了&lt;code&gt;ret_from_exception&lt;&#x2F;code&gt;，如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ret_from_exception:
	REG_L s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;PT_STATUS(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;)
	csrc CSR_STATUS&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;SR_IE
#ifdef CONFIG_RISCV_M_MODE
	&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;the MPP value is too large to be used as an immediate arg for addi &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
	li t0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;SR_MPP
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;and &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;t0
#else
	andi s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;SR_SPP
#endif
	bnez s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;resume_kernel
resume_userspace:
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;通过&lt;code&gt;CSR_STATUS&lt;&#x2F;code&gt;上的&lt;code&gt;SPP&lt;&#x2F;code&gt;位可以获取到&lt;code&gt;handle_exception&lt;&#x2F;code&gt;跳转执行时原先CPU位于的特权级，对于内核态和用户态需要区分对待。实际上这两者最本质的区别就是对抢占的处理，&lt;code&gt;resume_kernel&lt;&#x2F;code&gt;会根据内核编译时是否支持抢占执行对应的操作：如果支持抢占，则检查当前任务的&lt;code&gt;preempt_count&lt;&#x2F;code&gt;和&lt;code&gt;TIF_NEED_RESCHED&lt;&#x2F;code&gt;标志，进行抢占操作，反之则直接返回。注意这里这个&lt;code&gt;ret_from_exception&lt;&#x2F;code&gt;是由多个路径共享的。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;do_IRQ&lt;&#x2F;code&gt;中根据&lt;code&gt;CSR_CAUSE&lt;&#x2F;code&gt;的值确定中断来源：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;switch &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(regs-&amp;gt;cause &amp;amp; ~CAUSE_IRQ_FLAG) {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;case&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; RV_IRQ_TIMER:
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;riscv_timer_interrupt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;break&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#ifdef&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; CONFIG_SMP
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;case&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; RV_IRQ_SOFT:
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;*
		 * We only use software interrupts to pass IPIs, so if a non-SMP
		 * system gets one, then we don&amp;#39;t know what to do.
		 *&#x2F;
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;riscv_software_interrupt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;break&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#endif
	case&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; RV_IRQ_EXT:
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;handle_arch_irq&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(regs);
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;break&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;default&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;:
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pr_alert&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;unexpected interrupt cause 0x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%lx&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, regs-&amp;gt;cause);
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;BUG&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
	}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其中，&lt;code&gt;handle_arch_irq&lt;&#x2F;code&gt;是中断控制器驱动通过调用&lt;code&gt;set_handle_irq&lt;&#x2F;code&gt;注册的中断处理函数。Linux内核中对于RISC-V专门实现了对应的时钟源：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* called directly from the low-level interrupt handler *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;riscv_timer_interrupt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; clock_event_device *evdev = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this_cpu_ptr&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;riscv_clock_event);

	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;csr_clear&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(CSR_IE, IE_TIE);
	evdev-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;event_handler&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(evdev);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;而&lt;code&gt;riscv_software_interrupt&lt;&#x2F;code&gt;只用于处理IPI中断，有机会的话单独分析。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;xi-tong-diao-yong&quot;&gt;系统调用&lt;&#x2F;h3&gt;
&lt;p&gt;系统调用的实现非常简单，如果&lt;code&gt;handle_exception&lt;&#x2F;code&gt;判断进入异常的原因为系统调用，则会：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;检查系统调用号合法性&lt;&#x2F;li&gt;
&lt;li&gt;处理系统调用tracer&lt;&#x2F;li&gt;
&lt;li&gt;通过&lt;code&gt;sys_call_table&lt;&#x2F;code&gt;和系统调用号拿到系统调用的函数指针，并跳转执行&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;	li t1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;beq a7&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;t1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ret_from_syscall_rejected
	blt a7&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;t1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;1f
	&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Call syscall &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
	la s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;sys_call_table
	slli t0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;a7&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;RISCV_LGPTR
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;t0
	REG_L s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(s0)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;:
	jalr s0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;qi-ta-yi-chang&quot;&gt;其他异常&lt;&#x2F;h3&gt;
&lt;p&gt;除了系统调用和中断之外的异常处理通过&lt;code&gt;excp_vect_table&lt;&#x2F;code&gt;之中注册的函数指针完成：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;	&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Handle other exceptions &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
	slli t0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;s4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;RISCV_LGPTR
	la t1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;excp_vect_table
	la t2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;excp_vect_table_end
	move a0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;pt_regs &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;t0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;t1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;t0
	&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Check if exception code lies within bounds &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
	bgeu t0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;t2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;1f
	REG_L t0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(t0)
	jr t0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;</content>
	</entry>
	<entry xml:lang="en">
		<title>Linux内核在RISC-V架构下的构建与启动</title>
		<published>2020-07-25T00:00:00+00:00</published>
		<updated>2020-07-25T00:00:00+00:00</updated>
		<link href="https://crab2313.github.io/riscv-build-and-boot/" type="text/html"/>
		<id>https://crab2313.github.io/riscv-build-and-boot/</id>
		<content type="html">&lt;p&gt;本文分析RISC-V的linux移植是如何完成的，并给出具体的入手方法，希望对后来者有所启发。RISC-V是一个比较新的体系结构，截至目前已经完成了非特权级Spec和特权级Spec（不包含hypervisor）的修订，由于后发优势，加上设计得当，RISC-V的设计相当简洁易懂，是学习体系结构以及Linux内核的良好素材。借助RISC-V，我们可以通读与RISC-V体系结构相关的Linux内核代码，这在其他体系结构上对于初学者是很难做到的。&lt;&#x2F;p&gt;
&lt;p&gt;首先我们需要通读RISC-V的手册，两本加起来不到三百页，对于稍有基础的人来说可能只需要两天就能够读完。RISC-V的汇编语言也非常简洁，设计独到，简化了程序开发人员的许多工作，推荐目前正在施工的&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;riscv&#x2F;riscv-asm-manual&#x2F;blob&#x2F;master&#x2F;riscv-asm.md&quot;&gt;官方教程&lt;&#x2F;a&gt;。本文尽量假定读者不熟悉内核的一些tricks，会做适当说明，至少会给出对应关键字，用以查找学习。&lt;&#x2F;p&gt;
&lt;p&gt;体系结构相关代码一般放置于&lt;code&gt;arch&#x2F;${arch}&#x2F;&lt;&#x2F;code&gt;文件夹下，主要涉及内核中与体系结构相关的部分，每个文件夹下的内容只在特定的体系结构中使用。我们主要研究其中的如下部分：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;内核的构建&lt;&#x2F;li&gt;
&lt;li&gt;内核的启动&lt;&#x2F;li&gt;
&lt;li&gt;内核体系结构相关函数的实现&lt;&#x2F;li&gt;
&lt;li&gt;内存一致性模型的映射&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;nei-he-de-gou-jian&quot;&gt;内核的构建&lt;&#x2F;h2&gt;
&lt;p&gt;很多与内核相关的书中都没有具体提到内核是如何构建的，最多介绍一下内核的大致内存布局。这里我主要介绍一下内核构建的大致原理。这里涉及的大部分内容实质上为ELF格式、编译器、链接器以及装载器的原理。Linux内核实质上为一个巨大的二进制可执行文件，这个可执行文件的格式一般是不确定的，与体系结构有关。这个格式实质上是与bootloader的约定，bootloader可以检测并识别特定的内核格式，然后将其装载到内存中并执行。这个约定一般被明确写在&lt;code&gt;Documentation&#x2F;${arch}&#x2F;&lt;&#x2F;code&gt;下的某个文件中，被称作&lt;code&gt;Boot Protocol&lt;&#x2F;code&gt;，即启动协议。特化到RISC-V体系结构，这个格式为与ARM64体系结构相同的PE格式，该格式的一个显著优势是可以作为UEFI Executable由UEFI直接执行，即我们熟知的UEFI stub启动方式。&lt;&#x2F;p&gt;
&lt;p&gt;熟悉了上面的概念后，我们来看内核的&lt;code&gt;Makefile&lt;&#x2F;code&gt;是如何生成RISC-V下的内核的。首先找到最显眼的文件&lt;code&gt;arch&#x2F;riscv&#x2F;Makefile&lt;&#x2F;code&gt;，可以看到如下定义：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# Default target when executing plain make
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;boot            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;:= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;arch&#x2F;riscv&#x2F;boot
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;KBUILD_IMAGE    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;:= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;boot&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;Image.gz

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;...

ifeq (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;CONFIG_RISCV_M_MODE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;CONFIG_SOC_KENDRYTE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;,yy)
KBUILD_IMAGE &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;:= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;boot&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;loader.bin
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;else
KBUILD_IMAGE &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;boot&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;Image.gz
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;endif
BOOT_TARGETS &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;= Image Image.gz loader loader.bin

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;all&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;:    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;notdir &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;KBUILD_IMAGE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;))

$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;BOOT_TARGETS&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: vmlinux
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Q&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;MAKE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;) $(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;build&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;boot&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;) $(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;boot&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$@
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        @&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kecho&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt; &amp;#39;  Kernel&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;boot&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$@&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt; is ready&amp;#39;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;不难得出如下结论：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;在非勘智SOC（K210）下，默认执行make后生成的文件为&lt;code&gt;Image.gz&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;对于由&lt;code&gt;BOOT_TARGETS&lt;&#x2F;code&gt;中定义的几种镜像名称，可以在&lt;code&gt;arch&#x2F;riscv&#x2F;boot&lt;&#x2F;code&gt;下的&lt;code&gt;Makefile&lt;&#x2F;code&gt;中找到生成方式&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;我们现在就来看&lt;code&gt;Image&lt;&#x2F;code&gt;是如何生成的：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;OBJCOPYFLAGS_Image &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;=-O binary -R .note -R .note.gnu.build-id -R .comment -S

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;obj&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;Image&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;vmlinux FORCE
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;call &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;if_changed&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,objcopy&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)

$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;obj&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;Image.gz&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;obj&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;Image FORCE
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;call &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;if_changed&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,gzip&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到&lt;code&gt;Image&lt;&#x2F;code&gt;实质上就是由vmlinux通过&lt;code&gt;objcopy -O binary&lt;&#x2F;code&gt;生成的binary格式。具有嵌入式开发经验的人对这个操作会比较熟悉，binary格式实质上就是ELF装载到内存后的内存dump，即以ELF起始装载地址指向的物理地址为起始地址的整片内存区域转储。而这样就比较有趣了，看到这里你一定能猜出&lt;code&gt;vmlinux&lt;&#x2F;code&gt;用了什么特殊手段将其内存布局安排的明明白白，使其通过objcopy后，可以得到一个PE格式的可执行程序。这个手段就是&lt;strong&gt;链接脚本&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;关于链接脚本的解读就不赘述了，建议通读&lt;code&gt;GNU ld&lt;&#x2F;code&gt;的文档。我们可以在&lt;code&gt;arch&lt;&#x2F;code&gt;文件夹下找到生成链接脚本的模板文件：&lt;code&gt;arch&#x2F;riscv&#x2F;kernel&#x2F;vmlinux.ld.S&lt;&#x2F;code&gt;。之所以称其为模板文件，是因为这个文件通过C语言的预处理后，可以生成最终的链接脚本&lt;code&gt;vmlinux.ld&lt;&#x2F;code&gt;。脚本的内容比较简单，我们先来看前几行：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;OUTPUT_ARCH(riscv)
ENTRY(_start)

jiffies = jiffies_64&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这几行比较常规，可以知道：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;输出的ELF为riscv体系结构&lt;&#x2F;li&gt;
&lt;li&gt;输出的ELF的entry point为&lt;code&gt;_start&lt;&#x2F;code&gt;符号的地址&lt;&#x2F;li&gt;
&lt;li&gt;符号&lt;code&gt;jiffies&lt;&#x2F;code&gt;与&lt;code&gt;jiffies_64&lt;&#x2F;code&gt;共用一个地址。这里可以参考其它文档中对于时间子系统的描述，这个trick可以让我们在内核中通过&lt;code&gt;jiffies&lt;&#x2F;code&gt;变量访问&lt;code&gt;jiffies_64&lt;&#x2F;code&gt;变量的低32位。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;接下来就是最关键的部分：&lt;code&gt;SECTIONS&lt;&#x2F;code&gt;定义，它能精确控制链接器的行为，按照你的需求合并section，并控制内存布局。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;LOAD_OFFSET PAGE_OFFSET
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#include &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;asm&#x2F;vmlinux.lds.h&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;

...

SECTIONS
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Beginning of code and text segment *&#x2F;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;. = LOAD_OFFSET;
        _start = .;
        HEAD_TEXT_SECTION
        . = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ALIGN&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(PAGE_SIZE);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到，整个内存的布局由&lt;code&gt;LOAD_OFFSET&lt;&#x2F;code&gt;，即&lt;code&gt;PAGE_OFFSET&lt;&#x2F;code&gt;地址开始，而&lt;code&gt;PAGE_OFFSET&lt;&#x2F;code&gt;大部分书中都有所涉及，这里不再提它是什么。我们可以看到&lt;code&gt;_start&lt;&#x2F;code&gt;符号的地址被定义为&lt;code&gt;PAGE_OFFSET&lt;&#x2F;code&gt;，即vmlinux虚拟地址空间的最开头，这也是其名字的由来，在内核中可以通过&lt;code&gt;&amp;amp;_start&lt;&#x2F;code&gt;获取其地址。&lt;&#x2F;p&gt;
&lt;p&gt;如果对ELF格式有一定理解，这一段可以跳过不看。这里&lt;code&gt;SECTIONS&lt;&#x2F;code&gt;中定义的是虚拟内存的布局，事实上ELF格式中是严格区分物理地址（在链接器的定义中称为装载地址&lt;code&gt;LMA&lt;&#x2F;code&gt;）和虚拟地址的，这一点要铭记。在大多数情况下，这两个地址是相同的，但由于内核会将其位于的物理地址通过页表映射到PAGE_OFFSET上位置（不是绝对，有偏移量随机化实现），所以需要严格区分这两种情况。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Section used for early init (in .S files) *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;HEAD_TEXT  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;KEEP&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*(.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;head&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;text&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;))

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;HEAD_TEXT_SECTION                                                       \
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;head&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;text &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;AT&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ADDR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;head&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;text&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) - LOAD_OFFSET) {               \
                HEAD_TEXT                                               \
        }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;HEAD_TEXT_SECTION&lt;&#x2F;code&gt;定义如上，很简单，即将所有&lt;code&gt;.o&lt;&#x2F;code&gt;文件名为&lt;code&gt;.head.text&lt;&#x2F;code&gt;的section合并成vmlinux名为&lt;code&gt;.head.text&lt;&#x2F;code&gt;的section。这里注意两个trick：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;链接脚本中可以通过AT属性指定section的装载地址，这里可以看到&lt;code&gt;.head.text&lt;&#x2F;code&gt;的装载地址是0x0&lt;&#x2F;li&gt;
&lt;li&gt;链接器需要对最终生成的ELF进行优化，有可能会删除section没有被应用的符号，这里使用KEEP阻止链接器进行这个操作&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;很明显这个名为&lt;code&gt;.head.text&lt;&#x2F;code&gt;的section就是objcopy后得到的&lt;code&gt;Image&lt;&#x2F;code&gt;镜像的开头部分。我们已经知道了&lt;code&gt;Image&lt;&#x2F;code&gt;是一个PE兼容的镜像，所以这里一定定义了PE header。这里稍微有一点经验的人即可猜到&lt;code&gt;.head.text&lt;&#x2F;code&gt;是定义在&lt;code&gt;head.S&lt;&#x2F;code&gt;文件中的，这也是其名字的由来。对于内核内的汇编代码文件，&lt;code&gt;linux&#x2F;init.h&lt;&#x2F;code&gt;中定义了多个helper，用以简化section的定义：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* For assembly routines *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__HEAD          .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;section        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.head.text&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ax&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__INIT          .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;section        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.init.text&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ax&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__FINIT         .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;previous

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__INITDATA      .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;section        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.init.data&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;aw&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,%progbits
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__INITRODATA    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;section        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.init.rodata&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,%progbits
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__FINITDATA     .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;previous

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__MEMINIT        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;section       &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.meminit.text&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ax&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__MEMINITDATA    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;section       &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.meminit.data&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;aw&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__MEMINITRODATA  .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;section       &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.meminit.rodata&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;接着我们在&lt;code&gt;arch&#x2F;riscv&#x2F;kernel&#x2F;head.S&lt;&#x2F;code&gt;文件中看到这个section的定义：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__HEAD
ENTRY(_start)
        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*
         * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Image header expected by Linux boot&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;loaders. The image header data
         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;structure is described &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;asm&#x2F;image.h.
         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;Do &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;not &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;modify it without modifying the structure &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;and &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;all bootloaders
         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;th&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;at &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;expects this header form&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;at&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;!!
         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;jump to start kernel &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        j _start_kernel
        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;reserved &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;word &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.balign &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;#if __riscv_xlen == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;64
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Image load offset(2MB) from start of RAM &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dword &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x200000
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;#else
        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Image load offset(4MB) from start of RAM &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dword &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x400000
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;#endif
        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Effective size of kernel image &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dword &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;_end &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;_start
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dword &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__HEAD_FLAGS
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;word &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;RISCV_HEADER_VERSION
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;word &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dword &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.ascii RISCV_IMAGE_MAGIC
        .balign &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.ascii RISCV_IMAGE_MAGIC2
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;word &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到该section开头即为精心构建的PE header。至此，内核的构建方式已经比较明了，即利用链接脚本，精心设置整个vmlinux文件的布局，将&lt;code&gt;.head.text&lt;&#x2F;code&gt;放置到最前，并在其开头填充PE header，最后用objcopy导出这个带有PE header的二进制&lt;code&gt;Image&lt;&#x2F;code&gt;镜像。原理非常简单，但是其中涉及的技术比较非常规，对应用层开发人员来说并不常见。总的来说，其构建过程&lt;strong&gt;与ARM64基本一致&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;nei-he-qi-dong&quot;&gt;内核启动&lt;&#x2F;h2&gt;
&lt;p&gt;前面的分析其实已经起了个头，按照前面提到的，我们可以找到RISC-V架构的启动协议&lt;code&gt;Documentation&#x2F;riscv&#x2F;boot-image-header.txt&lt;&#x2F;code&gt;。事实上这个文件只是简单介绍了一下&lt;code&gt;Image&lt;&#x2F;code&gt;文件header的结构，更详细的启动协议还是处于TODO状态，我们需要从代码进行分析。前面提到RISC-V内核比较类似于ARM64内核的格式，如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        u32 code0;                &#x2F;* Executable code *&#x2F;
        u32 code1;                &#x2F;* Executable code *&#x2F;
        u64 text_offset;          &#x2F;* Image load offset, little endian *&#x2F;
        u64 image_size;           &#x2F;* Effective Image size, little endian *&#x2F;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;从bootloader的角度，装载并执行&lt;code&gt;Image&lt;&#x2F;code&gt;类型的内核只需要做两件事情：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;将整个&lt;code&gt;Image&lt;&#x2F;code&gt;文件放置到内存起始处向后偏移&lt;code&gt;text_offset&lt;&#x2F;code&gt;的内存地址&lt;&#x2F;li&gt;
&lt;li&gt;跳转到&lt;code&gt;code0&lt;&#x2F;code&gt;的地址进行执行&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;后续的事情，内核自理。我们看到&lt;code&gt;head.S&lt;&#x2F;code&gt;中有如下代码：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ENTRY(_start)
        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*
         * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Image header expected by Linux boot&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;loaders. The image header data
         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;structure is described &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;asm&#x2F;image.h.
         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;Do &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;not &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;modify it without modifying the structure &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;and &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;all bootloaders
         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;th&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;at &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;expects this header form&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;at&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;!!
         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;jump to start kernel &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        j _start_kernel
        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;reserved &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;很明显&lt;code&gt;code0&lt;&#x2F;code&gt;和&lt;code&gt;code1&lt;&#x2F;code&gt;放置的就是&lt;code&gt;j _start_kernel&lt;&#x2F;code&gt;生成的指令。那么我们就需要从&lt;code&gt;_start_kernel&lt;&#x2F;code&gt;开始看起。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;start-kernel&quot;&gt;_start_kernel&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;_start_kernel&lt;&#x2F;code&gt;可以看到，一开始主要做了三件事：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;关闭所有的中断&lt;&#x2F;li&gt;
&lt;li&gt;设置gp寄存器指向对应的地址（该寄存器为ABI相关，用于存放&lt;code&gt;__global_pointer$&lt;&#x2F;code&gt;的地址，即GOT的位置，可以参考&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;riscv&#x2F;riscv-elf-psabi-doc&#x2F;blob&#x2F;master&#x2F;riscv-elf.md&quot;&gt;RISCV调用协定&lt;&#x2F;a&gt;）&lt;&#x2F;li&gt;
&lt;li&gt;关闭FPU，内核中是不用任何浮点指令的&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;我们可以看到一个名为&lt;code&gt;CONFIG_RISCV_M_MODE&lt;&#x2F;code&gt;的内核配置，该选项启用时，内核默认自己从&lt;code&gt;Machine&lt;&#x2F;code&gt;特权级启动。该选项用于内核支持K210 SoC，我们默认该选项没有开启。这里注意，bootloader将控制权交给内核时，&lt;code&gt;a0&lt;&#x2F;code&gt;寄存器保存的值即为当前CPU执行单元的ID（RISC-V中称为HART ID）。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;_start_kernel&lt;&#x2F;code&gt;接下来就开始执行一个简单的&lt;code&gt;Boot Protocol&lt;&#x2F;code&gt;，选出一个用于启动内核的CPU，其他CPU进入等待状态。RISC-V处理器在reset之后，所有的处理单元（HART）都会一起开始执行，而Linux内核启动时为主从模型，因此需要挑选出其中一个完成部分内核启动工作，之后告知其他的处理器继续执行开始处理任务。首先确定CPU ID是否合法，即有没有超出内核编译时选择的最大支持CPU数，如果超过则非法：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;#ifdef CONFIG_SMP
        li t0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;CONFIG_NR_CPUS
        blt a0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;t0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.Lgood_cores
        tail .Lsecondary_park
.Lgood_cores:
#endif
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;.Lsecondary_park&lt;&#x2F;code&gt;分支实质上是循环调用&lt;code&gt;wfi&lt;&#x2F;code&gt;指令。接下来内核使用一个简单的策略选出用于启动的主CPU：先到先得。&lt;code&gt;setup.c&lt;&#x2F;code&gt;中定义了一个原子变量：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;atomic_t hart_lottery &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__section&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sdata&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;经过codepath的所有CPU都会试图通过原子操作将这个变量加1。RISC-V的原子操作指令会将原子变量的原有值保存在原子变量的目标寄存器中，也就是说，如果操作后目标寄存器的值为0的CPU为第一对其进行操作的CPU。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Pick one hart to run the main boot sequence &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        la a3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;hart_lottery
        li a2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;amoadd.w a3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;a2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(a3)
        bnez a3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.Lsecondary_start
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;对于所有竞争失败的CPU，我们在后面进行分析，目前还是顺着主CPU进行分析。随后主CPU的操作基本如下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;清空bss段，写为0&lt;&#x2F;li&gt;
&lt;li&gt;设置临时内核栈与&lt;code&gt;task_struct&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;依次调用&lt;code&gt;setup_vm&lt;&#x2F;code&gt;以及&lt;code&gt;relocate&lt;&#x2F;code&gt;设置内核的虚拟内存&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;最后调用C语言通用代码启动内核：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Start the kernel &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;call &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;soc_early_init
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;call &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;parse_dtb
        tail start_kernel
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;setup-vmyu-relocate&quot;&gt;setup_vm与relocate&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;setup_vm&lt;&#x2F;code&gt;函数位于&lt;code&gt;arch&#x2F;riscv&#x2F;mm&#x2F;init.c&lt;&#x2F;code&gt;中，其目的是设置一个最小的页表，让内核开启&lt;code&gt;MMU&lt;&#x2F;code&gt;并工作在虚拟内存之下，为后续的内存初始化做准备。注意&lt;code&gt;setup_vm&lt;&#x2F;code&gt;在被调用时很明显是没有设置好页表的，也就是说&lt;code&gt;setup_vm&lt;&#x2F;code&gt;函数生成汇编时的引用必须为&lt;code&gt;PC-relative&lt;&#x2F;code&gt;的，由于目前内核在RISC-V体系结构下全局使用&lt;code&gt;-cmodel=medany&lt;&#x2F;code&gt;进行编译，因此这一点是满足的。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;setup_vm&lt;&#x2F;code&gt;函数执行的操作在各个体系结构中没有本质区别，都为设置一个最简单的页表，将内核所在的物理地址映射到PAGE_OFFSET所在虚拟地址区域（即将内核二进制所在的物理地址加上一个PAGE_OFFSET减去_start所的的偏移量）。因此，这里的任务实质上是建立一个临时页表，即内核临时的虚拟地址空间映射，：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;MAX_EARLY_MAPPING_SIZE	SZ_128M

pgd_t early_pg_dir[PTRS_PER_PGD] __initdata &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__aligned&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(PAGE_SIZE);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;来挖细节，确定这个临时页表里初始化了哪些东西。首先明确一点，RISC-V支持多种页表结构，我们只分析64位的Sv39，目前内核在RISC-V 64位下就支持这一种模式。随后应该想到，setup_vm的运行环境里并没有初始化任何内存，因此必须静态定义一些变量，预留出一些内存供我们使用。先看&lt;code&gt;setup_vm&lt;&#x2F;code&gt;里用到的两个helper函数：&lt;code&gt;create_pgd_mapping&lt;&#x2F;code&gt; &amp;amp;&amp;amp; &lt;code&gt;create_pmd_mapping&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;当前在RISC-V下的内核并不支持四级页表，那么自然没有PUD。&lt;code&gt;early_pmd&lt;&#x2F;code&gt;数组用于满足在MMU还没有开启时存放PMD表的需求：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#if&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; MAX_EARLY_MAPPING_SIZE &amp;lt; PGDIR_SIZE
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;NUM_EARLY_PMDS		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;UL
#else
#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;NUM_EARLY_PMDS		(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;UL &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;+ MAX_EARLY_MAPPING_SIZE &#x2F; PGDIR_SIZE)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#endif
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;pmd_t early_pmd[PTRS_PER_PMD * NUM_EARLY_PMDS] __initdata &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__aligned&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(PAGE_SIZE);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在64位下，&lt;code&gt;NUM_EARLY_PMDS&lt;&#x2F;code&gt;始终为1。可以通过&lt;code&gt;alloc_pmd&lt;&#x2F;code&gt;函数申请一个PMD表：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; phys_addr_t __init &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;alloc_pmd&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(uintptr_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;va&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
	uintptr_t pmd_num;

	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(mmu_enabled)
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;memblock_phys_alloc&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(PAGE_SIZE, PAGE_SIZE);

	pmd_num = (va - PAGE_OFFSET) &amp;gt;&amp;gt; PGDIR_SHIFT;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;BUG_ON&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(pmd_num &amp;gt;= NUM_EARLY_PMDS);
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(uintptr_t)&amp;amp;early_pmd[pmd_num * PTRS_PER_PMD];
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里能很明显看到，在MMU使能之前使用&lt;code&gt;early_pmd&lt;&#x2F;code&gt;的空间，而使能之后则使用memblock中分配的内存。&lt;code&gt;create_pgd_mapping&lt;&#x2F;code&gt;函数原型如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; __init &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;create_pgd_mapping&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(pgd_t *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pgdp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
				      uintptr_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;va&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, phys_addr_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pa&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
				      phys_addr_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sz&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, pgprot_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;prot&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里仔细看实现，不要误解了&lt;code&gt;va&lt;&#x2F;code&gt;和&lt;code&gt;pa&lt;&#x2F;code&gt;的意思。va是你想进行映射的&lt;strong&gt;虚拟地址&lt;&#x2F;strong&gt;，&lt;code&gt;pa&lt;&#x2F;code&gt;是你要往PGD中给这个虚拟地址对应的表项存放的&lt;strong&gt;下一级页表&lt;&#x2F;strong&gt;的&lt;strong&gt;物理地址&lt;&#x2F;strong&gt;。&lt;code&gt;sz&lt;&#x2F;code&gt;是你要映射的内存区域的大小，必须小于&lt;code&gt;PGDIR_SIZE&lt;&#x2F;code&gt;，可以为下面一级表项可以映射内存区域的长度。如果&lt;code&gt;create_pgd_mapping&lt;&#x2F;code&gt;函数发现&lt;code&gt;sz&lt;&#x2F;code&gt;小于&lt;code&gt;PGDIR_SIZE&lt;&#x2F;code&gt;，则会递归的创建更下一级的页表。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;early_pg_dir&lt;&#x2F;code&gt;页表内包含两类映射：内核和FIXMAP。其中内核映射是将内核自身处于的连续物理内存区域映射到位于&lt;code&gt;PAGE_OFFSET&lt;&#x2F;code&gt;的虚拟内存地址上。而FIXMAP映射并没有映射全部的FIXMAP，而是仅仅影射了FIX_FDT部分，让后续的代码可以访问设备树。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;setup_vm&lt;&#x2F;code&gt;并不是仅仅只创建了一个&lt;code&gt;early_pg_dir&lt;&#x2F;code&gt;页表，还创建了&lt;code&gt;trampoline_pg_dir&lt;&#x2F;code&gt;页表。这个页表将&lt;code&gt;PAGE_OFFSET&lt;&#x2F;code&gt;后长为&lt;code&gt;PMD_SIZE&lt;&#x2F;code&gt;的区域映射到&lt;code&gt;load_pa&lt;&#x2F;code&gt;，即内核起始被装载后的起始物理内存地址。&lt;code&gt;trampoline_pg_dir&lt;&#x2F;code&gt;页表的作用我们随后就会看到。&lt;&#x2F;p&gt;
&lt;p&gt;分析完&lt;code&gt;setup_vm&lt;&#x2F;code&gt;函数后，又回到汇编代码中，这次来看relocate函数。函数只有一个参数&lt;code&gt;a0&lt;&#x2F;code&gt;寄存器，用于传递一个页表的物理地址。这个&lt;code&gt;relocate&lt;&#x2F;code&gt;函数原理听着很简单，但是真到自己写的时侯则是满满的细节。首先我们知道我们要在该函数中开启MMU，这就说明调用函数时保存的&lt;code&gt;ra&lt;&#x2F;code&gt;寄存器，即函数返回地址中的地址已经失效，需要将其修改为对应的虚拟地址。这个原理比较简单，首先通过PC相对寻址得到&lt;code&gt;_start&lt;&#x2F;code&gt;的物理地址，然后将其与&lt;code&gt;PAGE_OFFSET&lt;&#x2F;code&gt;相减，即得到物理地址与虚拟地址的偏移量。&lt;&#x2F;p&gt;
&lt;p&gt;接下来就到前面设置的&lt;code&gt;trampoline_pg_dir&lt;&#x2F;code&gt;上场的时间了，我们需要借助&lt;code&gt;trampoline&lt;&#x2F;code&gt;页表通过中断向量的方式从物理地址跳转到虚拟地址，原理如下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;首先将中断向量设置到&lt;code&gt;relocate&lt;&#x2F;code&gt;函数的后半段需要跳转的地方&lt;&#x2F;li&gt;
&lt;li&gt;然后将&lt;code&gt;trampoline_pg_dir&lt;&#x2F;code&gt;的地址设置到STVEC寄存器，设置完成MMU被启用，这使得访问原有物理地址时触发异常并跳转到中断向量&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;事实上，这个&lt;code&gt;trampoline&lt;&#x2F;code&gt;是多余的，我不知道上游为什么不删除它，也许是因为CPU热插拔支持的缘故。&lt;code&gt;relocate&lt;&#x2F;code&gt;最终会装载&lt;code&gt;early_pg_dir&lt;&#x2F;code&gt;页表，此时内核已经位于正确的虚拟地址空间上。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;lin-shi-nei-he-zhan-yu-task-struct&quot;&gt;临时内核栈与task_struct&lt;&#x2F;h3&gt;
&lt;p&gt;回到&lt;code&gt;_start_kernel&lt;&#x2F;code&gt;，当&lt;code&gt;relocate&lt;&#x2F;code&gt;执行完毕之后，内核需要初始化一个内核线程的运行环境。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Initialize page tables &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;and &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;relocate to virtual addresses &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        la &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;init_thread_union &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;THREAD_SIZE
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里init_thread_union是通过链接脚本留出的一个PAGE（riscv平台上为4KB）大小的区域，用以充当临时内核栈。随后程序按照riscv的C程序调用协定保存两个Caller需要保存的寄存器，即：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;a0：当前hart（Hardware Thread，即RISCV术语中的最小执行单元，即一个逻辑CPU）的id&lt;&#x2F;li&gt;
&lt;li&gt;a1：指向设备树的指针&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这两个参数都是bootloader传进来的。到达这一步之后，内核调用setup_vm()函数，设置一个基本的页表，进而为后续打开分页机制做准备。&lt;&#x2F;p&gt;
&lt;p&gt;进入内核C语言环境的最后一个步骤是设置&lt;code&gt;tp&lt;&#x2F;code&gt;寄存器。我们知道内核初始化时，自身运行的上下文为init_task，即内核的第一个任务（&lt;code&gt;init&#x2F;init_task.c&lt;&#x2F;code&gt;）。该task_struct是静态初始化的，因此我们唯一需要做得就是修改当前CPU的运行上下文，使其认为他当前是在运行init_task任务。内核的进程上下文切换是一个及其架构相关的操作，我们来看看riscv平台是如果进行这个操作的。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        la tp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;init_task
        sw s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_TI_&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;CPU&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(tp) # 将当前&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;CPU &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ID表存在task_struct中
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果读过riscv的C语言调用约定一定会知道tp寄存器的存在，事实上文档中并没有写的较为详细。但是现在我们在这里看到在Supervisor模式下的用途：保存当前CPU运行的进程上下文，即&lt;code&gt;task_struct&lt;&#x2F;code&gt;结构体。查看&lt;code&gt;asm&#x2F;current.h&lt;&#x2F;code&gt;也可以发现这一事实：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;create_pte_mappingstatic __always_inline &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; task_struct *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;get_current&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;register struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; task_struct *tp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;__asm__&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;tp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; tp;
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;</content>
	</entry>
	<entry xml:lang="en">
		<title>TTM内存分配器分析</title>
		<published>2020-04-26T00:00:00+00:00</published>
		<updated>2020-04-26T00:00:00+00:00</updated>
		<link href="https://crab2313.github.io/ttm/" type="text/html"/>
		<id>https://crab2313.github.io/ttm/</id>
		<content type="html">&lt;h1 id=&quot;ttm&quot;&gt;TTM&lt;&#x2F;h1&gt;
&lt;p&gt;本文结合QXL内的实现分析内核DRM框架中提供的TTM内存管理器。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bo&quot;&gt;BO&lt;&#x2F;h2&gt;
&lt;p&gt;BO是Buffer Object的缩写，与Buffer是有区别的。个人理解BO和Buffer最大的区别就是BO比Buffer多了好几个操作，且BO的后端Buffer位置是会变化的。这是因为在GPU工作时，同一个BO可能被管理器移动到三个位置上：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;GPU的专有内存中，也称显存、VRAM&lt;&#x2F;li&gt;
&lt;li&gt;系统内存中&lt;&#x2F;li&gt;
&lt;li&gt;系统内存在磁盘中的缓存中&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;因此，BO提供了这些操作的抽象。注意BO有可能被多个对象访问，如GPU和CPU，且GPU和CPU只能访问特定位置上的BO。如，GPU只能访问VRAM和（部分）系统内存中的BO。这其中的拷贝和管理就需要TTM进行。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ttmde-ju-xian-xing&quot;&gt;TTM的局限性&lt;&#x2F;h2&gt;
&lt;p&gt;TTM有一大堆问题，但作为目前最成熟的codebase，基本上所有开发者都是边骂边用。目前的基本操作是使用GEM当作用户态前端，但是后端使用TTM进行。目前TTM的codebase经过多年clean up，目前还剩1w行左右。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;chu-shi-hua&quot;&gt;初始化&lt;&#x2F;h2&gt;
&lt;p&gt;TTM的初始化由&lt;code&gt;ttm_bo_device_init&lt;&#x2F;code&gt;函数进行，该函数会会让驱动得到一个&lt;code&gt;ttm_bo_device&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;ttm_bo_init_mm&lt;&#x2F;code&gt;负责初始化一个memory_manager。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ttm_bo_device {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; list_head device_list;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ttm_bo_driver *driver;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ttm_mem_type_manager man[TTM_NUM_MEM_TYPES];
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;drm_vma_offset_manager *vma_manager;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; list_head ddestroy;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;address_space *dev_mapping;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; delayed_work wq;

	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; need_dma32;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; no_retry;
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;所有的&lt;code&gt;ttm_bo_device&lt;&#x2F;code&gt;都会放到一个&lt;code&gt;ttm_bo_global&lt;&#x2F;code&gt;上的&lt;code&gt;device_list&lt;&#x2F;code&gt;中。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ttm-mem-type-manager&quot;&gt;ttm_mem_type_manager&lt;&#x2F;h2&gt;
&lt;p&gt;前面看到&lt;code&gt;ttm_bo_device&lt;&#x2F;code&gt;中保存了一个&lt;code&gt;ttm_mem_type_manager&lt;&#x2F;code&gt;数组，即用于管理多种内存类型的管理器。注意到其内部保存了一组&lt;code&gt;func&lt;&#x2F;code&gt;函数指针，该指针通常由使用TTM的驱动进行设置，一般为&lt;code&gt;ttm_bo_manager_func&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ttm_mem_type_manager_func ttm_bo_manager_func = {
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;init &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= ttm_bo_man_init,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;takedown &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= ttm_bo_man_takedown,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;get_node &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= ttm_bo_man_get_node,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;put_node &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= ttm_bo_man_put_node,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;debug &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= ttm_bo_man_debug
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;事实上DRM子系统提供了自己的内存分配器，称为&lt;code&gt;drm_mm&lt;&#x2F;code&gt;，具体信息详见&lt;a href=&quot;https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;html&#x2F;latest&#x2F;gpu&#x2F;drm-mm.html#drm-mm-range-allocator&quot;&gt;内核文档&lt;&#x2F;a&gt;。&lt;code&gt;ttm_mem_type_manager_func&lt;&#x2F;code&gt;中的回调函数使用&lt;code&gt;drm_mm&lt;&#x2F;code&gt;管理各类型的存储空间。有关于初始化的&lt;code&gt;init&lt;&#x2F;code&gt;和与之相反的&lt;code&gt;takedown&lt;&#x2F;code&gt;可以不谈，主要需要分析&lt;code&gt;get_node&lt;&#x2F;code&gt;函数，该函数为内存分配的入口函数。函数事实上的实现也很简单，仅仅是调用&lt;code&gt;drm_mm&lt;&#x2F;code&gt;的接口获取&lt;code&gt;drm_mm_node&lt;&#x2F;code&gt;并将其写入传入的&lt;code&gt;ttm_mem_reg&lt;&#x2F;code&gt;中：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;		mem-&amp;gt;mm_node = node;
		mem-&amp;gt;start = node-&amp;gt;start;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;注意这个&lt;code&gt;start&lt;&#x2F;code&gt;字段，后面会看到可以以它计算出BO对应的物理地址。&lt;&#x2F;p&gt;
&lt;p&gt;除了&lt;code&gt;TTM_PL_SYSTEM&lt;&#x2F;code&gt;类型外的&lt;code&gt;ttm_mem_type_manager&lt;&#x2F;code&gt;一般由驱动程序自行初始化。初始化&lt;code&gt;ttm_mem_type_manager&lt;&#x2F;code&gt;的入口函数为&lt;code&gt;ttm_bo_init_mm&lt;&#x2F;code&gt;，该函数会调用驱动程序注册给&lt;code&gt;ttm_bo_device&lt;&#x2F;code&gt;的&lt;code&gt;ttm_bo_driver&lt;&#x2F;code&gt;上的&lt;code&gt;init_mem_type&lt;&#x2F;code&gt;函数指针初始化对应类型的内存管理器。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ttm-buffer-object&quot;&gt;ttm_buffer_object&lt;&#x2F;h2&gt;
&lt;p&gt;这个对象应该是TTM管理的BO的基类，对BO的管理应该都是围绕它进行的。从这里看到TTM和GEM其是并不是独立的两个组件，&lt;code&gt;ttm_buffer_object&lt;&#x2F;code&gt;是以&lt;code&gt;drm_gem_object&lt;&#x2F;code&gt;为基类的。&lt;&#x2F;p&gt;
&lt;p&gt;先来看明白一个结构体：&lt;code&gt;ttm_placement&lt;&#x2F;code&gt;，如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ttm_placement {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;		num_placement;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ttm_place	*placement;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;		num_busy_placement;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ttm_place	*busy_placement;
};

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ttm_place {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	fpfn;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	lpfn;
	uint32_t	flags;
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;每个&lt;code&gt;ttm_buffer_object&lt;&#x2F;code&gt;都有与之关联的&lt;code&gt;ttmp_placement&lt;&#x2F;code&gt;，而&lt;code&gt;ttm_placement&lt;&#x2F;code&gt;的意义也很简单，即BO可以放置的位置和当空间紧张时，BO可以放置的位置。&lt;code&gt;ttm_place&lt;&#x2F;code&gt;实际上描述了一段内存区域（由起始和结束PFN描述）和一个flags。这两个结构体结合即可描述清楚BO对于存储空间的偏好。&lt;&#x2F;p&gt;
&lt;p&gt;除此之外BO还有类型属性，即：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ttm_bo_type {
	ttm_bo_type_device,
	ttm_bo_type_kernel,
	ttm_bo_type_sg
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里只需要明白device和kernel的最大区别是kernel类型的BO无法被用户态进行访问。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;ttm_bo_init&lt;&#x2F;code&gt;函数负责初始化一个&lt;code&gt;ttm_buffer_object&lt;&#x2F;code&gt;，而其内部由&lt;code&gt;ttm_bo_init_reserved&lt;&#x2F;code&gt;实现。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ttm-mem-reg&quot;&gt;ttm_mem_reg&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;code&gt;ttm_bo_init_reserved&lt;&#x2F;code&gt;使用&lt;code&gt;ttm_bo_validate&lt;&#x2F;code&gt;函数验证&lt;code&gt;ttm_buffer_object&lt;&#x2F;code&gt;是否在正确的位置上，如果不是，则调用move操作将其放置在正确的位置上。一个BO当前处于的存储位置由&lt;code&gt;ttm_mem_reg&lt;&#x2F;code&gt;描述：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ttm_mem_reg {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*mm_node;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; start;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; size;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; num_pages;
	uint32_t page_alignment;
	uint32_t mem_type;
	uint32_t placement;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ttm_bus_placement bus;
};

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ttm_bus_placement {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*addr;
	phys_addr_t	base;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	size;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	offset;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;		is_iomem;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;		io_reserved_vm;
	uint64_t        io_reserved_count;
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;di-zhi-kong-jian-ying-she&quot;&gt;地址空间映射&lt;&#x2F;h2&gt;
&lt;p&gt;该操作主要指将一个BO映射到CPU的虚拟地址，该操作是BO最主要的操作之一。只有映射到虚拟地址空间，一个BO后端的Buffer才能被CPU访问，才能被应用程序操作（读写）。TTM提供了好几组工具函数，用于实现各种各样的映射，首先来看&lt;code&gt;ttm_bo_kmap&#x2F;kunmap&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;提到映射，那么我们首先要明白TTM允许使用它的驱动程序注册一组callback，这组callback在映射&#x2F;取消映射时被调用，可以让驱动程序hook自己的操作。这组callback为&lt;code&gt;ttm_bo_driver&lt;&#x2F;code&gt;上的&lt;code&gt;io_mem_reserve&lt;&#x2F;code&gt;和&lt;code&gt;io_mem_free&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;ttm_bo_kmap&lt;&#x2F;code&gt;函数的主要工作为将BO映射到内核虚拟地址空间中，注意它的最后一个参数&lt;code&gt;map&lt;&#x2F;code&gt;，为一个&lt;code&gt;ttm_bo_kmap_obj&lt;&#x2F;code&gt;结构体。该结构体用于表示一个kmap映射，如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;TTM_BO_MAP_IOMEM_MASK &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x80
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ttm_bo_kmap_obj {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*virtual;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;page *page;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
		ttm_bo_map_iomap        = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| TTM_BO_MAP_IOMEM_MASK,
		ttm_bo_map_vmap         = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
		ttm_bo_map_kmap         = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
		ttm_bo_map_premapped    = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| TTM_BO_MAP_IOMEM_MASK,
	} bo_kmap_type;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ttm_buffer_object *bo;
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;很明显&lt;code&gt;virtual&lt;&#x2F;code&gt;为映射好之后的起始虚拟地址，而从后面可以看到&lt;code&gt;page&lt;&#x2F;code&gt;为kmap下映射用的&lt;code&gt;struct page&lt;&#x2F;code&gt;指针（注意kmap模式只有在映射一个page，且允许缓存时使用）。简单分析了这个参数后，来看正主。除去参数合法性检查等操作后，可以看到函数调用了&lt;code&gt;ttm_mem_io_reserve&lt;&#x2F;code&gt;，这本质就是调用了上面提到的&lt;code&gt;io_mem_reserve&lt;&#x2F;code&gt;回调函数。随后，函数根据BO是否为IO内存调用&lt;code&gt;ttm_bo_kmap_ttm&lt;&#x2F;code&gt;或者&lt;code&gt;ttm_bo_ioremap&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;ttm_bo_kmap_ttm&lt;&#x2F;code&gt;函数像前面提到的一样，在只映射一页且允许缓存的情况下使用kmap，在其他情况下使用vmap进行映射，这在&lt;code&gt;ttm_tt&lt;&#x2F;code&gt;的分析里详细看。而&lt;code&gt;ttm_bo_ioremap&lt;&#x2F;code&gt;的实现更加直观，分为两种情况：已经映射和没有映射。对于已经映射的BO，其&lt;code&gt;bo-&amp;gt;mem.bus.addr&lt;&#x2F;code&gt;不为0，则将&lt;code&gt;ttm_bo_kmap_obj&lt;&#x2F;code&gt;的类型设置为&lt;code&gt;ttm_bo_map_premapped&lt;&#x2F;code&gt;，并以该虚拟地址作为映射的虚拟地址。对于没有进行映射的BO，则根据&lt;code&gt;ttm_buffer_object&lt;&#x2F;code&gt;中的&lt;code&gt;ttm_mem_reg&lt;&#x2F;code&gt;中的&lt;code&gt;placement&lt;&#x2F;code&gt;标志中是否存在&lt;code&gt;TTM_PL_FLAG_WC&lt;&#x2F;code&gt;对物理地址调用ioremap_wc或者ioremap函数进行映射。最后一提，映射使用的物理地址通过&lt;code&gt;ttm_mem_reg.bus&lt;&#x2F;code&gt;上的&lt;code&gt;base+offset&lt;&#x2F;code&gt;计算而来。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ttm-mem-glob&quot;&gt;ttm_mem_glob&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;code&gt;ttm_mem_glob&lt;&#x2F;code&gt;是一个&lt;code&gt;ttm_mem_global&lt;&#x2F;code&gt;结构体，是一个单例对象，没错是全局的。这意味着无论内核中无论同时跑了多少个使用TTM的显卡驱动实例，它们都使用的是同一个&lt;code&gt;ttm_mem_glob&lt;&#x2F;code&gt;对象。首先明确&lt;code&gt;TTM&lt;&#x2F;code&gt;并没有直接调用内存子系统进行page的分配回收操作，而是增加了自己的抽象。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;TTM_MEM_MAX_ZONES &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ttm_mem_zone;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;extern struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ttm_mem_global {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kobject kobj;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;workqueue_struct *swap_queue;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; work_struct work;
	spinlock_t lock;
	uint64_t lower_mem_limit;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ttm_mem_zone *zones[TTM_MEM_MAX_ZONES];
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; num_zones;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ttm_mem_zone *zone_kernel;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#ifdef&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; CONFIG_HIGHMEM
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ttm_mem_zone *zone_highmem;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#else
	struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ttm_mem_zone *zone_dma32;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#endif
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;} ttm_mem_glob;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;该全局对象由&lt;code&gt;ttm_mem_global_init&lt;&#x2F;code&gt;初始化，我们只看它初始化的page pool，也就是page缓存池。这个page缓冲区池由&lt;code&gt;ttm_pool_manager&lt;&#x2F;code&gt;描述，也是单例对象，由&lt;code&gt;ttm_page_alloc_init&lt;&#x2F;code&gt;函数初始化。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ttm_pool_manager {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kobject		kobj;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; shrinker		mm_shrink;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ttm_pool_opts	options;

	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;union &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ttm_page_pool	pools[NUM_POOLS];
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ttm_page_pool	wc_pool;
			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ttm_page_pool	uc_pool;
			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ttm_page_pool	wc_pool_dma32;
			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ttm_page_pool	uc_pool_dma32;
			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ttm_page_pool	wc_pool_huge;
			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ttm_page_pool	uc_pool_huge;
		} ;
	};
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里注意一个逻辑，有cache的page是不需要缓存起来的，可以直接通过内存子系统提供的接口进行申请和回收。其于的情况下都会为其维护一个page池，由&lt;code&gt;struct ttm_page_pool&lt;&#x2F;code&gt;描述。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ttm_page_pool {
	spinlock_t		lock;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;			fill_lock;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; list_head	list;
	gfp_t			gfp_flags;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;		npages;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;char			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*name;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;		nfrees;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;		nrefills;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;		order;
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;ttm-tt&quot;&gt;ttm_tt&lt;&#x2F;h2&gt;
&lt;p&gt;TTM的全称是&lt;code&gt;Translation Table Manager&lt;&#x2F;code&gt;，那么&lt;code&gt;ttm_tt&lt;&#x2F;code&gt;中的&lt;code&gt;tt&lt;&#x2F;code&gt;就应该是&lt;code&gt;Translation Table&lt;&#x2F;code&gt;的缩写。这个结构体在BO的操作中时有出现，很显然它用管理内存页表，应用于存在于非VRAM空间中的BO。从名字上来看&lt;code&gt;ttm_tt&lt;&#x2F;code&gt;是TTM的核心对象之一。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ttm_tt {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ttm_bo_device *bdev;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ttm_backend_func *func;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;page **pages;
	uint32_t page_flags;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; num_pages;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;sg_table *sg; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* for SG objects via dma-buf *&#x2F;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;file *swap_storage;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;enum&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ttm_caching_state caching_state;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
		tt_bound,
		tt_unbound,
		tt_unpopulated,
	} state;
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;ttm_tt&lt;&#x2F;code&gt;实质上管理BO的存储后端，所以它是嵌入到&lt;code&gt;ttm_buffer_object&lt;&#x2F;code&gt;中的。事实上&lt;code&gt;ttm_buffer_object-&amp;gt;ttm&lt;&#x2F;code&gt;的创建是通过驱动程序注册的&lt;code&gt;ttm_bo_driver-&amp;gt;ttm_tt_create&lt;&#x2F;code&gt;回调函数实现的，下面是&lt;code&gt;ttm_ttm_create&lt;&#x2F;code&gt;函数的片段：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	bo-&amp;gt;ttm = bdev-&amp;gt;driver-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ttm_tt_create&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(bo, page_flags);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个回调函数内部一般会调用&lt;code&gt;ttm_tt_init&lt;&#x2F;code&gt;初始化&lt;code&gt;ttm_tt&lt;&#x2F;code&gt;，本质上是初始化&lt;code&gt;ttm_tt&lt;&#x2F;code&gt;各字段并申请一个用于存放&lt;code&gt;struct page&lt;&#x2F;code&gt;的数组。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;ttm_tt&lt;&#x2F;code&gt;的&lt;code&gt;state&lt;&#x2F;code&gt;中保存了当前的状态，即：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;unpopulated，内存没有分配&lt;&#x2F;li&gt;
&lt;li&gt;unbound，内存已经分配，但是没有bind&lt;&#x2F;li&gt;
&lt;li&gt;bind，内存已经分配，且已经bind&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>SMMU内核驱动分析</title>
		<published>2020-02-20T00:00:00+00:00</published>
		<updated>2020-02-20T00:00:00+00:00</updated>
		<link href="https://crab2313.github.io/smmu/" type="text/html"/>
		<id>https://crab2313.github.io/smmu/</id>
		<content type="html">&lt;h1 id=&quot;iommuhe-xin-kuang-jia-ceng&quot;&gt;IOMMU核心框架层&lt;&#x2F;h1&gt;
&lt;p&gt;IOMMU核心框架是管理IOMMU设备的一个通过框架，IOMMU设备通过实现特定的回调函数并将自身注册到IOMMU核心框架中，以此通过IOMMU核心框架提供的API向整个内核提供IOMMU功能。所有的IOMMU设备都嵌入了一个&lt;code&gt;struct iommu_device&lt;&#x2F;code&gt;，iommu的核心代码只会操作这个结构体。可以看到，我们唯一需要关心的就是ops，这是iommu驱动注册到core中的回调函数。:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;iommu_device {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; list_head list;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;iommu_ops *ops;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;fwnode_handle *fwnode;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;device *dev;
};

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;**
 * struct iommu_ops - iommu ops and capabilities
 * @capable: check capability
 * @domain_alloc: allocate iommu domain
 * @domain_free: free iommu domain
 * @attach_dev: attach device to an iommu domain
 * @detach_dev: detach device from an iommu domain
 * @map: map a physically contiguous memory region to an iommu domain
 * @unmap: unmap a physically contiguous memory region from an iommu domain
 * @flush_tlb_all: Synchronously flush all hardware TLBs for this domain
 * @tlb_range_add: Add a given iova range to the flush queue for this domain
 * @tlb_sync: Flush all queued ranges from the hardware TLBs and empty flush
 *            queue
 * @iova_to_phys: translate iova to physical address
 * @add_device: add device to iommu grouping
 * @remove_device: remove device from iommu grouping
 * @device_group: find iommu group for a particular device
 * @domain_get_attr: Query domain attributes
 * @domain_set_attr: Change domain attributes
 * @get_resv_regions: Request list of reserved regions for a device
 * @put_resv_regions: Free list of reserved regions for a device
 * @apply_resv_region: Temporary helper call-back for iova reserved ranges
 * @domain_window_enable: Configure and enable a particular window for a domain
 * @domain_window_disable: Disable a particular window for a domain
 * @domain_set_windows: Set the number of windows for a domain
 * @domain_get_windows: Return the number of windows for a domain
 * @of_xlate: add OF master IDs to iommu grouping
 * @pgsize_bitmap: bitmap of all possible supported page sizes
 *&#x2F;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;iommu中的核心代码在&lt;code&gt;drivers&#x2F;iommu&#x2F;iommu.c&lt;&#x2F;code&gt;中实现，下面从一些基本的方面分析核心层提供的功能。由于一个运行的系统中只会同时存在几个iommu设备，因此设备管理实现比较简单，是由链表实现的。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;LIST_HEAD&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(iommu_device_list);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;DEFINE_SPINLOCK&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(iommu_device_lock);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;注册和注销设备实质上就是操作这个链表。iommu向外提供的API不多，后面主要分析：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;iommu_map &amp;amp;&amp;amp; iommu_unmap&lt;&#x2F;li&gt;
&lt;li&gt;iommu_domain_alloc &amp;amp;&amp;amp; iommu_domain_free&lt;&#x2F;li&gt;
&lt;li&gt;iommu_attach_device &amp;amp;&amp;amp; iommu_detach_device&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;iommu-domain-alloc&quot;&gt;iommu_domain_alloc&lt;&#x2F;h2&gt;
&lt;p&gt;在我的理解中，domain这个词是从intel的VT-d文档中继承下来的，其他平台有各自的叫法如ARM下叫context。一个domain应该是指一个独立的iommu映射上下文。处于同一个domain中的设备使用同一套映射做地址转换（对于mmio来说就是独立的页表）。core层中使用&lt;code&gt;struct iommu_domain&lt;&#x2F;code&gt;表示一个domain：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;iommu_domain {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; type;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;iommu_ops *ops;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; pgsize_bitmap;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Bitmap of page sizes in use *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	iommu_fault_handler_t handler;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*handler_token;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; iommu_domain_geometry geometry;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*iova_cookie;
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;后面分析各个字段的含义。注释中提到了内核支持的domain类型：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;*
 * This are the possible domain-types
 *
 *	IOMMU_DOMAIN_BLOCKED	- All DMA is blocked, can be used to isolate
 *				  devices
 *	IOMMU_DOMAIN_IDENTITY	- DMA addresses are system physical addresses
 *	IOMMU_DOMAIN_UNMANAGED	- DMA mappings managed by IOMMU-API user, used
 *				  for VMs
 *	IOMMU_DOMAIN_DMA	- Internally used for DMA-API implementations.
 *				  This flag allows IOMMU drivers to implement
 *				  certain optimizations for these domain
 *&#x2F;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个函数仅仅就是调用ops中驱动注册的&lt;code&gt;domain_alloc&lt;&#x2F;code&gt;回调函数分配一个iommu_domain，从这里看书每个驱动也是要提供自己的domain类型并把&lt;code&gt;struct iommu_domain&lt;&#x2F;code&gt;嵌入进取的。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;iommu-attach-device&quot;&gt;iommu_attach_device&lt;&#x2F;h2&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;iommu_attach_device&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; iommu_domain *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;domain&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; device *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dev&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;从函数原型中可以看出该函数的操作对象是一个domain和一个设备，联想函数名称可以认为该函数是将一个设备添加到一个domain中。但事实上还是有些偏差的，该函数实际上将设备所在的Group与该domain绑定。值得一提的是，如果函数发现设备存在的Group中存在多个设备，则不进行绑定操作。总结下来，该操作针对独立设备（即所在Group里只有自己），将设备所在Group与domain进行绑定。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;iommu_group_device_count&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(group) != &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;goto&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; out_unlock;

	ret = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__iommu_attach_group&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(domain, group);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;__iommu_attach_group&lt;&#x2F;code&gt;遍历Group中所有的设备，并调用&lt;code&gt;__iommu_attach_device&lt;&#x2F;code&gt;。该函数首先通过&lt;code&gt;domain-&amp;gt;ops&lt;&#x2F;code&gt;中的is_attach_deffered检查是否延后进行attach操作。然后调用ops中的attach_dev函数将设备绑定到该domain中去。这里需要注意区分Group中default_domain和domain的概念：domain指group当前所在的domain，而default_domain指Group默认应该在的domain。进行attach操作时，会检查default_domain是否与domain相同，以此判断该Group是否已经attach到别的domain上了，在该情况下返回&lt;code&gt;-EBUSY&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;iommu-detach-device&quot;&gt;iommu_detach_device&lt;&#x2F;h2&gt;
&lt;p&gt;该函数与上面的&lt;code&gt;iommu_attach_device&lt;&#x2F;code&gt;几乎完全相反，并且该函数也是操作独立设备。这里注意如果Group有自己的default_domain，那么该函数在detach完成之后会重新attach到default_domain上。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;iommu-map&quot;&gt;iommu_map&lt;&#x2F;h2&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;iommu_map&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; iommu_domain *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;domain&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;iova&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
	      phys_addr_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;paddr&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, size_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;size&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;prot&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;函数原型上可以看出来是用于映射domain内的iova，将长度为&lt;code&gt;size&lt;&#x2F;code&gt;以&lt;code&gt;iova&lt;&#x2F;code&gt;为起始地址的iova区域映射到以paddr为起始地址的物理地址。该函数只能用于&lt;code&gt;UNMANAGED&lt;&#x2F;code&gt;类型和&lt;code&gt;DMA&lt;&#x2F;code&gt;类型的domain。&lt;code&gt;domain-&amp;gt;pgsize_bitmap&lt;&#x2F;code&gt;是一个bitmap，用于记录domain支持的最小page大小。iommu_map函数进行操作时，是以page为单位的，page大小不固定可以根据需要使用不同大小的page，在同一次iommu_map操作中也不要求page大小一致。最终一个page的映射是调用iommu-&amp;gt;ops中的map回调函数实现的。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;iommu-iova-to-phys&quot;&gt;iommu_iova_to_phys&lt;&#x2F;h2&gt;
&lt;p&gt;该函数调用&lt;code&gt;domain-&amp;gt;ops&lt;&#x2F;code&gt;中提供的&lt;code&gt;iova_to_phys&lt;&#x2F;code&gt;回调函数将iova转换成物理地址。&lt;&#x2F;p&gt;
&lt;p&gt;TODO dma integration&lt;&#x2F;p&gt;
&lt;h2 id=&quot;iommu-group&quot;&gt;IOMMU Group&lt;&#x2F;h2&gt;
&lt;p&gt;啃了两天PCIE协议，对IOMMU的Group概念也有了一定的理解。从内核角度来看Group是一组设备，是IOMMU可以辨别的最小单位，即IOMMU无法区分出一个Group中的设备。区分标准是什么呢，IO地址空间。以PCIE总线来举一个例子，我们知道PCIE是一个点对点的协议，如果一个多function设备挂到了一个不支持ACS的bridge下，那么这两个function可以通过该bridge进行通信。这样的通信直接由bridge进行转发而无需通过Root Complex，自然也就无需通过IOMMU。这种情况下，这两个function的IOVA无法完全通过IOMMU隔离开，所以他们需要分到同一个Group中。同一个Group的设备应该是公用一个domain的。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;iommu_group {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kobject kobj;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kobject *devices_kobj;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; list_head devices;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; mutex mutex;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; blocking_notifier_head notifier;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*iommu_data;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*iommu_data_release)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*iommu_data);
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;char &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*name;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; id;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;iommu_domain *default_domain;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;iommu_domain *domain;
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;从iommu_group的结构中可以发现，devices列表保存group中设备。一个group需要关联两个iommu_domain，除此之外支持内核中其他组件向该group中注册listener。default_domain保存的是默认该设备应该位于的domain，而domain字段保存设备当前所在的domain。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;iommu-group-add-device&quot;&gt;iommu_group_add_device&lt;&#x2F;h3&gt;
&lt;p&gt;该函数将一个设备加入一个Group，函数的主要操作如下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;处理sysfs相关的事项，如建立iommu_group符号链接&lt;&#x2F;li&gt;
&lt;li&gt;将设备的iommu_group字段设置为这个Group&lt;&#x2F;li&gt;
&lt;li&gt;调用iommu_group_create_direct_mappings建立设备的iova映射&lt;&#x2F;li&gt;
&lt;li&gt;将设备加入到Group内的list里&lt;&#x2F;li&gt;
&lt;li&gt;通知所有注册到Group里的listener有设备加入&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;TODO: iommu_group_create_direct_mappings&lt;&#x2F;p&gt;
&lt;h3 id=&quot;iommu-group-get-for-dev&quot;&gt;iommu_group_get_for_dev&lt;&#x2F;h3&gt;
&lt;p&gt;该函数获取一个设备所在的Group，如果设备不属于任何一个Group，则调用IOMMU驱动提供的&lt;code&gt;device_group&lt;&#x2F;code&gt;回调函数尝试进行获取。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	group = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;iommu_group_get&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(dev);
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(group)
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; group;

	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(!ops)
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ERR_PTR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(-EINVAL);

	group = ops-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;device_group&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(dev);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;随后，为获取的Group设置domain，最后将设备加入Group。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(!group-&amp;gt;default_domain) {
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; iommu_domain *dom;

		dom = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__iommu_domain_alloc&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(dev-&amp;gt;bus, iommu_def_domain_type);
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(!dom &amp;amp;&amp;amp; iommu_def_domain_type != IOMMU_DOMAIN_DMA) {
			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dev_warn&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(dev,
				 &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;failed to allocate default IOMMU domain of type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%u&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;; falling back to IOMMU_DOMAIN_DMA&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
				 iommu_def_domain_type);
			dom = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__iommu_domain_alloc&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(dev-&amp;gt;bus, IOMMU_DOMAIN_DMA);
		}

		group-&amp;gt;default_domain = dom;
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(!group-&amp;gt;domain)
			group-&amp;gt;domain = dom;
	}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;bus-integration&quot;&gt;Bus integration&lt;&#x2F;h2&gt;
&lt;p&gt;每一个&lt;code&gt;struct device&lt;&#x2F;code&gt;中保存了一个&lt;code&gt;struct iommu_group&lt;&#x2F;code&gt;的指针，用以获取该设备处于的group。除此之外，内核需要其他方式将iommu功能集成到总线中。很明显，一个iommu设备是作用于一个或者多个总线上的，那么就需要一个自然的方式管理与iommu相关的功能。首先明确&lt;code&gt;struct bus&lt;&#x2F;code&gt;中存在一个iommu_ops用于保存当前bus上生效的iommu驱动注册的iommu_ops。同时可以根据这个指针是否为NULL确认这个bus中是否支持iommu功能。&lt;&#x2F;p&gt;
&lt;p&gt;iommu核心框架中提供了&lt;code&gt;bus_set_iommu&lt;&#x2F;code&gt;函数，该函数可以被iommu驱动调用，用以将自身挂入到 对应总线中。函数中除了设置iommu_ops指针之外，还进行了两个工作：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;向bus中注册一个listener：对于bus上设备的插入与移除的设备，调用iommu_ops中对应的add_device和remove_device回调函数。对于bus接收到的其他设备事件（如bind，unbind等），则将其传播给该设备所处于的group中。&lt;&#x2F;li&gt;
&lt;li&gt;对于bus中已经存在的设备，则挨个调用&lt;code&gt;add_device&lt;&#x2F;code&gt;将其纳入iommu的管辖，并设置其group&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;iommu-fwspec&quot;&gt;iommu_fwspec&lt;&#x2F;h3&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;iommu_fwspec {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;iommu_ops	*ops;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;fwnode_handle	*iommu_fwnode;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*iommu_priv;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;		num_ids;
	u32			ids[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;];
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;iommu-domain&quot;&gt;IOMMU Domain&lt;&#x2F;h2&gt;
&lt;p&gt;每一个domain即代表一个iommu映射地址空间，即一个page table。一个Group逻辑上是需要与domain进行绑定的，即一个Group中的所有设备都位于一个domain中。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;iommu_domain {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; type;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;iommu_ops *ops;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; pgsize_bitmap;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Bitmap of page sizes in use *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	iommu_fault_handler_t handler;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*handler_token;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; iommu_domain_geometry geometry;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*iova_cookie;
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h1 id=&quot;smmuying-jian-ji-qu-dong-fen-xi&quot;&gt;SMMU硬件及驱动分析&lt;&#x2F;h1&gt;
&lt;p&gt;看代码要点：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;一定要看文档，SMMU是一个比较简单的设备，他的Spec只有300页&lt;&#x2F;li&gt;
&lt;li&gt;fault分为global和context，global基本上就是smmu本身的一些fault，而context是smmu在进行地址转换时出现的fault&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;开始分析代码，我认为需要从中断处理入手，这也是错误信息的入口。先看context fault的处理函数，代码不贴了基本就是打出相关的寄存器信息，没有什么参考意义。我认为有意义的地方是这个中断是怎么注册的，即驱动是如何管理io domain的。这就涉及通用的IOMMU框架代码了。&lt;&#x2F;p&gt;
&lt;p&gt;可以发现&lt;code&gt;arm_smmu_attach_dev&lt;&#x2F;code&gt;函数中将一个设备添加到一个特定的iommu domain中。函数中调用&lt;code&gt;arm_smmu_init_domain_context&lt;&#x2F;code&gt;函数注册了这个中断。对于每一个&lt;code&gt;struct device&lt;&#x2F;code&gt;，其内部有一个&lt;code&gt;iommu_group&lt;&#x2F;code&gt;字段保存其所在的Group。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; iommu_ops arm_smmu_ops = {
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;capable		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= arm_smmu_capable,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;domain_alloc		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= arm_smmu_domain_alloc,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;domain_free		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= arm_smmu_domain_free,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;attach_dev		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= arm_smmu_attach_dev,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;map			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= arm_smmu_map,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;unmap			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= arm_smmu_unmap,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;flush_iotlb_all	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= arm_smmu_iotlb_sync,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;iotlb_sync		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= arm_smmu_iotlb_sync,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;iova_to_phys		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= arm_smmu_iova_to_phys,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;add_device		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= arm_smmu_add_device,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;remove_device		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= arm_smmu_remove_device,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;device_group		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= arm_smmu_device_group,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;domain_get_attr	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= arm_smmu_domain_get_attr,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;domain_set_attr	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= arm_smmu_domain_set_attr,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;of_xlate		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= arm_smmu_of_xlate,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;get_resv_regions	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= arm_smmu_get_resv_regions,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;put_resv_regions	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= arm_smmu_put_resv_regions,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pgsize_bitmap		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;UL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Restricted during device attach *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;由于前面已经分析了IOMMU核心框架，熟悉了IOMMU核心框架如何与IOMMU驱动如何互动。这里分析流程即为以一个设备的IOMMU操作周期为基准分析SMMU驱动向IOMMU核心框架注册回调函数。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;stream-mappingguan-li&quot;&gt;Stream Mapping管理&lt;&#x2F;h2&gt;
&lt;p&gt;首先提及一些Spec中定义的名词：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Steam翻译成中文是流的意思。在SMMU中特指Master设备向SMMU发起的请求流。StreamID即为SMMU用以辨别不同Stream用的编号，注意Stream和设备不是一一对应的关系。&lt;&#x2F;li&gt;
&lt;li&gt;Stream Mapping在Spec中特指将StreamID映射到Stream Context（接近domain的概念）这一操作行为。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;代码中SME应该是&lt;code&gt;Stream Mapping Entry&lt;&#x2F;code&gt;的缩写。Spec中提及到三种Stream Mapping的方式，这里主要提及Stream Indexing&lt;code&gt;和&lt;&#x2F;code&gt;Stream Matching`两种。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;arm-smmu-add-device&quot;&gt;arm_smmu_add_device&lt;&#x2F;h2&gt;
&lt;p&gt;这个函数即为&lt;code&gt;add_device&lt;&#x2F;code&gt;回调函数。回忆前面的分析，IOMMU核心框架向bus中注册listener，每当bus中新增设备时，即会调用该函数。从这里看，该函数的主要功能就是将一个设备纳入到IOMMU驱动的管理中。该函数的核心参数就是被传入的&lt;code&gt;struct device&lt;&#x2F;code&gt;结构体中保存的&lt;code&gt;struct iommu_fwspec&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;**
 * struct iommu_fwspec - per-device IOMMU instance data
 * @ops: ops for this device&amp;#39;s IOMMU
 * @iommu_fwnode: firmware handle for this device&amp;#39;s IOMMU
 * @iommu_priv: IOMMU driver private data for this device
 * @num_ids: number of associated device IDs
 * @ids: IDs which this device may present to the IOMMU
 *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;iommu_fwspec {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;iommu_ops	*ops;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;fwnode_handle	*iommu_fwnode;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*iommu_priv;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;		num_ids;
	u32			ids[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;];
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;该参数是从ACPI或者设备树中得到的，用以描述设备绑定的IOMMU及拓扑关系。这里需要注意该关系必须遵循硬件设计，不然很明显是无法正常工作的。函数为设备内分配了一个&lt;code&gt;arm_smmu_master_cfg&lt;&#x2F;code&gt;结构体，如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;arm_smmu_master_cfg {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;arm_smmu_device		*smmu;
	s16				smendx[];
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;并保存在iommu_fwspec中的&lt;code&gt;iommu_priv&lt;&#x2F;code&gt;指针中。该结构体从名字上就能看出是Master设备的配置，Master这个名词在Spec中是指Bus Master，即可以发起总线请求的设备。函数的核心操作由&lt;code&gt;arm_smmu_master_alloc_smes&lt;&#x2F;code&gt;完成，从名字可以看出是为设备分配Stream Mapping中的表项。对于每一个与设备关联的StreamID，都需要分配一个Stream Mapping中的表项：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;		ret = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;arm_smmu_find_sme&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(smmu, sid, mask);
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(ret &amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;goto&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; out_err;

		idx = ret;
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(smrs &amp;amp;&amp;amp; smmu-&amp;gt;s2crs[idx].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;count &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) {
			smrs[idx].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;id &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= sid;
			smrs[idx].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;mask &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= mask;
			smrs[idx].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;valid &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
		}
		smmu-&amp;gt;s2crs[idx].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;count&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;++;
		cfg-&amp;gt;smendx[i] = (s16)idx;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里的操作简明易懂，唯一需要注意的就是表项的分配方式。首先搜索整个表中是否存在完全匹配（即集合意义上的包含）的表项，如果存在则使用该表项，否则使用表中第一个发现的空表项。到这里可以发现&lt;code&gt;arm_smmu_master_cfg&lt;&#x2F;code&gt;中的smendx即为保存该Master设备对应的Stream Mapping表项。表项申请完毕后，其实质上还是没有写入到SMMU的mmio空间去的，写入的话这个表项应该就生效了。但是软件上还是没有准备完毕的，这个设备没有加入任何Group或者domain。这里可以看到：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	group = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;iommu_group_get_for_dev&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(dev);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个函数是IOMMU核心框架提供的函数，函数最终还是会调用到&lt;code&gt;device_group&lt;&#x2F;code&gt;回调函数。这里我们只需要明确这个函数确定设备属于哪一个Group。最后，为了使表项立马生效，将其写入到S2CR寄存器中：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;for_each_cfg_sme&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(fwspec, i, idx) {
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;arm_smmu_write_sme&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(smmu, idx);
		smmu-&amp;gt;s2crs[idx].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;group &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= group;
	}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;arm-smmu-device-group&quot;&gt;arm_smmu_device_group&lt;&#x2F;h2&gt;
&lt;p&gt;该函数为device_group回调函数，目的是获取一个设备的Group。函数的操作也比较简单：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;sanity check：检查设备所有SME是否都位于同一个Group&lt;&#x2F;li&gt;
&lt;li&gt;如果设备已经有一个Group，那么返回该Group&lt;&#x2F;li&gt;
&lt;li&gt;设备没有Group的情况下，则需为设备分配一个Group。对于PCI设备调用&lt;code&gt;pci_device_group&lt;&#x2F;code&gt;，对于其他设备则为&lt;code&gt;generic_device_group&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;arm-smmu-domain-alloc&quot;&gt;arm_smmu_domain_alloc&lt;&#x2F;h2&gt;
&lt;p&gt;该函数为&lt;code&gt;domain_alloc&lt;&#x2F;code&gt;回调函数，其目的是申请一个domain。SMMU驱动只支持三种domain：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(type != IOMMU_DOMAIN_UNMANAGED &amp;amp;&amp;amp;
	    type != IOMMU_DOMAIN_DMA &amp;amp;&amp;amp;
	    type != IOMMU_DOMAIN_IDENTITY)
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;剩下的就是申请内存，初始化一些数据结构了，貌似有一些看着比较关键的字段是空着的。后面可以看到这个时候申请的domain仅仅是占位用的，没有什么实际意义。在调用attach_dev时，会初始化domain context。驱动通过&lt;code&gt;struct arm_smmu_domain&lt;&#x2F;code&gt;里的smmu字段判断context是否已经初始化。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;arm-smmu-attach-dev&quot;&gt;arm_smmu_attach_dev&lt;&#x2F;h2&gt;
&lt;p&gt;这里的实现细节是，一个设备的绑定的SMMU与其Stream Mappings已经在&lt;code&gt;add_device&lt;&#x2F;code&gt;回调函数中确定好了。attach_dev的实际操作就是根据设备保存的这些信息初始化domain。初始化domain context由&lt;code&gt;arm_smmu_init_domain_context&lt;&#x2F;code&gt;函数完成，该函数满满的硬件细节，后续需要专门讨论。一个domain在SMMU硬件中实际对应的概念就是Context Bank，在使用Stream Matching的情况下，一共存在三层映射：StreamID &amp;amp;&amp;amp; Mask -&amp;gt; S2CR寄存器 -&amp;gt; Context Bank。因此，初始化完domain（即Context Bank）后需要设置当前设备在Stream Mapping中对应的S2CR寄存器，使其指向该domain对应的Context Bank。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>PCI驱动框架分析</title>
		<published>2020-02-19T00:00:00+00:00</published>
		<updated>2020-02-19T00:00:00+00:00</updated>
		<link href="https://crab2313.github.io/pci/" type="text/html"/>
		<id>https://crab2313.github.io/pci/</id>
		<content type="html">&lt;h1 id=&quot;pci&quot;&gt;PCI&lt;&#x2F;h1&gt;
&lt;p&gt;分析流程：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;硬件文档&lt;&#x2F;li&gt;
&lt;li&gt;PCI框架核心层&lt;&#x2F;li&gt;
&lt;li&gt;PCI框架热插拔&lt;&#x2F;li&gt;
&lt;li&gt;vfio&lt;&#x2F;li&gt;
&lt;li&gt;iommu&lt;&#x2F;li&gt;
&lt;li&gt;vfio接口层与用户态使用cloud-hypervisor&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;一共十一万行代码。&lt;&#x2F;p&gt;
&lt;p&gt;从ACPI的codepath开始看吧，比较熟悉一点。首先是找到初始化函数，&lt;code&gt;acpi_pci_init&lt;&#x2F;code&gt;。可以看到该函数首先从FADT中的boot_flags标志里检查两个标志：&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;flags&lt;&#x2F;th&gt;&lt;th&gt;desc&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;ACPI_FADT_NO_MSI&lt;&#x2F;td&gt;&lt;td&gt;表示不支持MSI&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;ACPI_FADT_NO_ASPM&lt;&#x2F;td&gt;&lt;td&gt;表示不支持高级电源管理&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h2 id=&quot;acpixia-dui-pcizong-xian-de-mei-ju-cao-zuo&quot;&gt;ACPI下对PCI总线的枚举操作&lt;&#x2F;h2&gt;
&lt;p&gt;ACPI的Definition Block中使用&lt;code&gt;PNP0A03&lt;&#x2F;code&gt;表示一个PCI Host Bridge。有关ACPI的知识就不提了，这里只总结机制，剩下的交给ACPI的Spec。在内核代码简单搜索即可发现对于PCI Host Bridge的处理在&lt;code&gt;drivers&#x2F;acpi&#x2F;pci_root.c&lt;&#x2F;code&gt;文件中。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static const struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; acpi_device_id root_device_ids[] = {
	{&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;PNP0A03&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;},
	{&amp;quot;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;},
};

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; acpi_scan_handler pci_root_handler = {
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ids &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= root_device_ids,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;attach &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= acpi_pci_root_add,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;detach &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= acpi_pci_root_remove,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;hotplug &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= {
		.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;enabled &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
		.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;scan_dependent &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= acpi_pci_root_scan_dependent,
	},
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;TODO： 这里留存有疑点，即内核中是如何处理&lt;code&gt;_HID&lt;&#x2F;code&gt;和&lt;code&gt;_CID&lt;&#x2F;code&gt;的关系的。PCIE Host Bridge一般将&lt;code&gt;_CID&lt;&#x2F;code&gt;设置成&lt;code&gt;PNP0A03&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;因此可以发现这里进行设备枚举的代码即为&lt;code&gt;acpi_pci_root_add&lt;&#x2F;code&gt;函数。函数首先通过&lt;code&gt;_SEG&lt;&#x2F;code&gt;确定该PCI Host bridge的segment group。随后通过&lt;code&gt;_CRS&lt;&#x2F;code&gt;里的BusRange类型资源取得该Host Bridge的Secondary总线范围，保存在&lt;code&gt;root-&amp;gt;secondary&lt;&#x2F;code&gt;这个resource中。然后设置基本属性：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	root-&amp;gt;device = device;
	root-&amp;gt;segment = segment &amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0xFFFF&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;strcpy&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;acpi_device_name&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(device), ACPI_PCI_ROOT_DEVICE_NAME);
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;strcpy&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;acpi_device_class&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(device), ACPI_PCI_ROOT_CLASS);
	device-&amp;gt;driver_data = root;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;_CBA&lt;&#x2F;code&gt;对象中可以保存这个PCI Host Bridge的用于MMCONFIG枚举的基址：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	root-&amp;gt;mcfg_addr = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;acpi_pci_root_get_mcfg_addr&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(handle)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;TODO _OSC&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	negotiate_os_control(root, &amp;amp;no_aspm);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;随后，调用&lt;code&gt;pci_acpi_scan_root&lt;&#x2F;code&gt;函数枚举这个Host Bridge上的设备。该函数是一个平台相关的函数，即各个平台独立实现了该函数，下面分析ARM64平台下的实现。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; pci_ecam_ops pci_generic_ecam_ops = {
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;bus_shift	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;20&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pci_ops	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= {
		.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;map_bus	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= pci_ecam_map_bus,
		.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;read		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= pci_generic_config_read,
		.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;write		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= pci_generic_config_write,
	}
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;host-bridgeguan-li&quot;&gt;Host Bridge管理&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;tong-yong-kong-zhi-qi-qu-dong-fen-xi&quot;&gt;通用控制器驱动分析&lt;&#x2F;h2&gt;
&lt;p&gt;这里分析内核中实现的通用控制器驱动，该驱动通过ECAM实现对设备的枚举，在ARM中比较常用。该驱动一般通过设备树进行配置，其设备树bingding位于&lt;code&gt;bindings&#x2F;pci&#x2F;host-generic-pci.txt&lt;&#x2F;code&gt;文件中。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;pci_ecam_ops {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;			bus_shift;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; pci_ops			pci_ops;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int				&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*init)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; pci_config_window *);
};

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;pci_ops {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*add_bus)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; pci_bus *bus);
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*remove_bus)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; pci_bus *bus);
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; __iomem *(*map_bus)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; pci_bus *bus, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; devfn, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; where);
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*read)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; pci_bus *bus, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; devfn, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; where, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; size, u32 *val);
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*write)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; pci_bus *bus, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; devfn, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; where, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; size, u32 val);
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;从名字可以看出pci_ecam_ops是用于操作ECAM空间的一组函数指针。驱动通过填充这组函数指针，可以向通用代码提供一个统一的操作入口。对于&lt;code&gt;pci-host-ecam-generic&lt;&#x2F;code&gt;来说，其操作定义如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; pci_ecam_ops pci_generic_ecam_ops = {
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;bus_shift	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;20&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
	.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pci_ops	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= {
		.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;map_bus	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= pci_ecam_map_bus,
		.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;read		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= pci_generic_config_read,
		.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;write		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= pci_generic_config_write,
	}
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;下面来看进行probe操作的通用函数&lt;code&gt;pci_host_common_probe&lt;&#x2F;code&gt;。事实上这个驱动对于PCI总线一般会进行两个操作：配置与枚举。配置操作即为配置整个PCI总线，分配总线和设备号，而枚举操作即为常规的枚举总线上的设备。在PCI总线已经配置好（如固件配置，或者虚拟机等）的情况下，可以通过chosen节点下配置&lt;code&gt;linux,pci-probe-only&lt;&#x2F;code&gt;让内核跳过配置操作。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>kdump工作机制分析</title>
		<published>2019-11-22T00:00:00+00:00</published>
		<updated>2019-11-22T00:00:00+00:00</updated>
		<link href="https://crab2313.github.io/kdump/" type="text/html"/>
		<id>https://crab2313.github.io/kdump/</id>
		<content type="html">&lt;h2 id=&quot;kdumpctl&quot;&gt;kdumpctl&lt;&#x2F;h2&gt;
&lt;p&gt;kdumpctl是一个shell脚本，用于查看当前kdump的状态和进行kdump相关操作。kdumpctl的入口是main函数，从中可以看到下列命令行参数：&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;命令&lt;&#x2F;th&gt;&lt;th&gt;说明&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;start&lt;&#x2F;td&gt;&lt;td&gt;执行capture内核装入&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;stop&lt;&#x2F;td&gt;&lt;td&gt;卸载capture内核&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;status&lt;&#x2F;td&gt;&lt;td&gt;显示kdump状态&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;restart&lt;&#x2F;td&gt;&lt;td&gt;stop + start&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;propagate&lt;&#x2F;td&gt;&lt;td&gt;将配置文件中设置的ssh-key通过ssh-copy-id拷贝到目标服务器&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;showmem&lt;&#x2F;td&gt;&lt;td&gt;显示内核为dump预留的内存大小&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;首先明确kdumpctl可以工作在两种模式下：kdump和fadump，这里只提kdump模式。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;statusming-ling&quot;&gt;status命令&lt;&#x2F;h3&gt;
&lt;p&gt;status命令直接显示当前是否已经装载了capture内核。具体操作为读取&lt;code&gt;&#x2F;sys&#x2F;kernel&#x2F;kexec_crash_loaded&lt;&#x2F;code&gt;文件，如果文件内容为1则认为capture内核已经装载。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;showmemming-ling&quot;&gt;showmem命令&lt;&#x2F;h3&gt;
&lt;p&gt;即内核为kdump保留的内存空间。从&lt;code&gt;&#x2F;sys&#x2F;kernel&#x2F;kexec_crash_size&lt;&#x2F;code&gt;中读取。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;startming-ling&quot;&gt;start命令&lt;&#x2F;h3&gt;
&lt;p&gt;这里应该是开启kdump服务的操作。但是如果内核的proc中存在&lt;code&gt;&#x2F;proc&#x2F;vmcore&lt;&#x2F;code&gt;，即当前内核为capture内核，则会进行保存core文件的操作。在primary内核中，会进行启动操作，在操作前会进行一系列检查：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;检查内核当前是否支持kdump，操作与status命令一致&lt;&#x2F;li&gt;
&lt;li&gt;检查内核是否为kdump保留了内存空间，操作与showmem命令一致&lt;&#x2F;li&gt;
&lt;li&gt;检查配置文件&lt;code&gt;&#x2F;etc&#x2F;kdump.conf&lt;&#x2F;code&gt;是否合法&lt;&#x2F;li&gt;
&lt;li&gt;检查raw选项配置的硬盘分区中是否保存有上次生成的内核dump，如果有则将其取出保存在默认目录，并清空该分区&lt;&#x2F;li&gt;
&lt;li&gt;如果设置了通过ssh远程保存内核dump，则需要检查ssh服务器是否可用&lt;&#x2F;li&gt;
&lt;li&gt;检查是否需要重新生成capture kernel使用的initrd，如果需要则进行重新生成&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;最后则进行kdump内核装载操作。该操作实际上就是调用了kexec工具，如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;$KEXEC $KEXEC_ARGS $standard_kexec_args \
		--commandl-line=&amp;quot;$KDUMP_COMMANDLINE&amp;quot; \
		--initrd=$TARGET_INITRD $dump_kernel
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;注意到一点是准备内核命令行时加入了&lt;code&gt;disable_cpu_apicid&lt;&#x2F;code&gt;参数，其他没有什么值的注意的了。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;stopming-ling&quot;&gt;stop命令&lt;&#x2F;h3&gt;
&lt;p&gt;这个命令就是简单的调用&lt;code&gt;kexec -p -u&lt;&#x2F;code&gt;将装入的内核卸载。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;propagateming-ling&quot;&gt;propagate命令&lt;&#x2F;h3&gt;
&lt;p&gt;调用ssh-copy-id将&lt;code&gt;kdump.conf&lt;&#x2F;code&gt;文件中配置的ssh-key上传到目标服务器中。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;capture-kernel-initrdsheng-cheng&quot;&gt;capture kernel initrd生成&lt;&#x2F;h3&gt;
&lt;p&gt;该过程在rebuild_kdump_initrd中进行，主要调用如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;$MKDUMPRD $TARGET_INITRD $dump_kver
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其中$MKDUMPRD为&lt;code&gt;&#x2F;sbin&#x2F;mkdumprd -f&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;kexec-tools&quot;&gt;kexec-tools&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;kexecgong-ju-dai-ma-zu-zhi&quot;&gt;kexec工具代码组织&lt;&#x2F;h3&gt;
&lt;p&gt;首先明确该工具有两种典型的应用场景：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;普通场景，即kexec的设计初衷：从现在运行的内核加载新内核&lt;&#x2F;li&gt;
&lt;li&gt;crash模式，即通过kexec获取当前运行内核的coredump信息&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;在该工具中的代码中，用运行kexec_load系统调用时的flags参数里的&lt;code&gt;KEXEC_ON_CRASH&lt;&#x2F;code&gt;标志区分两种情况：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(info-&amp;gt;kexec_flags &amp;amp; KEXEC_ON_CRASH) {
	...
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在本文中只分析crash模式下kexec工具的行为。除此之外，该工具高度与运行平台的架构相关，需要注意区分平台相关与平台无关的代码。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; file_type file_type[] = {
	{&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;vmlinux&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, elf_arm64_probe, elf_arm64_load, elf_arm64_usage},
	{&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Image&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, image_arm64_probe, image_arm64_load, image_arm64_usage},
	{&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;uImage&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, uImage_arm64_probe, uImage_arm64_load, uImage_arm64_usage},
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;struct file_type&lt;&#x2F;code&gt;描述当前体系结构下支持的内核文件格式。probe函数用于验证内核文件合法性，load用于装载内核。后续只分析ELF格式的内核装载。&lt;&#x2F;p&gt;
&lt;p&gt;内核对于kexec特性一共提供了两个系统调用：kexec_load与kexec_file_load，本文重点分析kexec_load。由于kexec_file_load的接口较为简单，其功能主要实现在内核态，该系统调用会在内核代码分析部分提到。kexec_file_load系统调用可以由&lt;code&gt;-s&lt;&#x2F;code&gt;命令行参数强行启用。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;kexec_load&lt;&#x2F;code&gt;系统调用原型如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static inline long &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;kexec_load&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;entry&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nr_segments&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kexec_segment *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;segments&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;flags&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其中entry为指向跳转地址的指针，&lt;code&gt;segments&lt;&#x2F;code&gt;为一个kexec_segment类型的数组，flags在crash模式下一定要设置&lt;code&gt;KEXEC_ON_CRASH&lt;&#x2F;code&gt;标志。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kexec_segment {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*buf;
	size_t bufsz;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*mem;
	size_t memsz;
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;kexec_segment&lt;&#x2F;code&gt;类型数组的目的是向内核描述一串内存区域，其元素的组织为：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;buf &amp;amp;&amp;amp; bufsz： 用户态缓冲区及其长度&lt;&#x2F;li&gt;
&lt;li&gt;mem &amp;amp;&amp;amp; memsz： 物理内存起始地址及其长度&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这个参数的目的是让内核将用户态缓冲区的内容拷贝到物理地址中，因此kexec工具的主要功能就如同一个bootloader，通过kexec_load系统调用将特定内存装载到特定物理地址，然后跳转到entry指针指向的内存执行。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;bi-yao-xin-xi-de-cai-ji&quot;&gt;必要信息的采集&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;crash_get_memory_ranges&lt;&#x2F;code&gt;函数实际上描述如何parse当前系统物理内存layout。函数实质上会输出三个信息：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;system_memory_rgns&lt;&#x2F;li&gt;
&lt;li&gt;usablemem_rgns&lt;&#x2F;li&gt;
&lt;li&gt;elf_info&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;system_memory_rgns和usablemem_rgns是&lt;code&gt;struct memory_ranges&lt;&#x2F;code&gt;类型的数据，其结构简单易懂不再赘述。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;memory_ranges {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; size;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; max_size;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;memory_range *ranges;
};

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;memory_range {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; start, end;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; type;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;RANGE_RAM	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;RANGE_RESERVED	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;RANGE_ACPI	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;RANGE_ACPI_NVS	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;RANGE_UNCACHED	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;RANGE_PMEM		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;RANGE_PRAM		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;11
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;函数简单读取&lt;code&gt;&#x2F;proc&#x2F;iomem&lt;&#x2F;code&gt;文件内容，对其进行解析：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(!usablemem_rgns.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;size&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kexec_iomem_for_each_line&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, iomem_range_callback, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;对该文件每一个条目，调用&lt;code&gt;iomem_range_callback&lt;&#x2F;code&gt;进行处理。该函数将遇到的&lt;code&gt;System RAM&lt;&#x2F;code&gt;区域保存在&lt;code&gt;system_memory_rgns&lt;&#x2F;code&gt;，将&lt;code&gt;Crash kernel&lt;&#x2F;code&gt;区域保存在&lt;code&gt;usablemem_rgns&lt;&#x2F;code&gt;里。函数中可以通过计算得到elf_info的一些字段，elf_info最后用于创建elf文件的header。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;crash_elf_info {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; class;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; data;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; machine;

	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; page_offset;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kern_vaddr_start;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kern_paddr_start;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kern_size;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; lowmem_limit;

	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*get_note_info)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; cpu, uint64_t *addr, uint64_t *len);
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;kern_paddr_start&lt;&#x2F;code&gt;即内核的物理起始地址设置为&lt;code&gt;Kernel code&lt;&#x2F;code&gt;内存区域的起始地址。内核的长度即&lt;code&gt;kern_size&lt;&#x2F;code&gt;可以通过&lt;code&gt;Kernel data&lt;&#x2F;code&gt;的结尾地址减去&lt;code&gt;Kernel code&lt;&#x2F;code&gt;的起始地址获得。&lt;code&gt;kern_vaddr_start&lt;&#x2F;code&gt;为内核的起始虚拟地址，可以通过读取&lt;code&gt;&#x2F;proc&#x2F;kallsym&lt;&#x2F;code&gt;文件中的&lt;code&gt;_text&lt;&#x2F;code&gt;符号地址获取。理解这些参数的获取方法本质上需要理解内核在内存中的layout。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;corexin-xi-segmentzhuang-zai&quot;&gt;core信息segment装载&lt;&#x2F;h3&gt;
&lt;p&gt;首先明确core信息是什么。在capture内核执行时，并没有直接的方式获取原先crash掉的内核的内存布局，因此开发者设计了针对此情况的辅助机制。capture内核启动时，可以通过&lt;code&gt;elfcorehdr&lt;&#x2F;code&gt;命令行参数或者&lt;code&gt;&#x2F;chosen&#x2F;linux,elfcorehdr&lt;&#x2F;code&gt;设备树节点向其传递一个core类型的ELF文件header。该ELF文件header由kexec放置在crashkernel保留的内存区域中，并通过物理内存地址的方式传递给capture内核。该header以program header的形式记录了原内核运行时的内存布局以及内核crash时用于保存crash信息时的内存区域物理地址。&lt;&#x2F;p&gt;
&lt;p&gt;该操作在kexec中由&lt;code&gt;load_crashdump_segments&lt;&#x2F;code&gt;函数实现，其中的核心操作即生成ELF header由&lt;code&gt;crash_create_elf64_headers&lt;&#x2F;code&gt;函数实现。对于每一个处于运行状态的逻辑CPU都有与之对应的一片内存区域，内核crash时，会将对应于该CPU的信息（寄存器，内核栈等）保存于此。这片内存区域的物理地址与大小由：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu[N]&#x2F;crash_notes
&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu[N]&#x2F;crash_notes_size
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这两个文件导出到了用户态供kexec读取。与之类似的还有vmcoreinfo：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&#x2F;sys&#x2F;kernel&#x2F;vmcoreinfo
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;函数会将这些信息以PT_NOTE的形式记录为ELF header的Program header。除此之外，还需要以PT_LOAD的形式记录内核的&lt;code&gt;System RAM&lt;&#x2F;code&gt;内存区域，这些区域可以通过枚举&lt;code&gt;&#x2F;proc&#x2F;iomem&lt;&#x2F;code&gt;文件获取。对于relocatable的内核或者实际放置地址存在偏移量的内核，仍需重复记录一遍内核占用内存区域的内存空间，即需要新增一个PT_LOAD类型的Program header，然后将其pt_vaddr设置为内核起始虚拟地址。&lt;&#x2F;p&gt;
&lt;p&gt;这个ET_CORE类型的ELF header保存在crashkernel保留的内存区域中，并创建对应的kexec_segment。后续会通过修改DTB并加入&lt;code&gt;&#x2F;chosen&#x2F;linux,elfcorehdr&lt;&#x2F;code&gt;的方式传递给capture内核。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;nei-he-segmentzhuang-zai&quot;&gt;内核segment装载&lt;&#x2F;h3&gt;
&lt;p&gt;首先调用&lt;code&gt;arm64_locate_kernel_segment&lt;&#x2F;code&gt;函数获取内核装载的起始地址。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;		hole = (crash_reserved_mem.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;start &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;lt; mem_min ?
				mem_min : crash_reserved_mem.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;start&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
		hole = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_ALIGN_UP&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(hole, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;MiB&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;));
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;注意ARM64内核boot协议中明确要求内核放置地址应该2M对齐。然后调用&lt;code&gt;fixup_elf_header&lt;&#x2F;code&gt;函数，目的是根据实际情况修正ELF格式内核的entry和program headers，使后续处理ELF格式文件的通用代码正确执行。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* load the kernel *&#x2F;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(info-&amp;gt;kexec_flags &amp;amp; KEXEC_ON_CRASH)
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;*
		 * offset addresses in elf header in order to load
		 * vmlinux (elf_exec) into crash kernel&amp;#39;s memory
		 *&#x2F;
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;fixup_elf_addrs&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;ehdr);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们实际上要将位于&lt;code&gt;arm64_mem.phys_offset&lt;&#x2F;code&gt;物理地址上的内核搬运到&lt;code&gt;crash_reserved_mem.start&lt;&#x2F;code&gt;上，搬运偏移量为&lt;code&gt;crash_reserved_mem.start - arm64_mem.phys_offset&lt;&#x2F;code&gt;。对于ELF header里的entry地址和所有PT_LOAD类型的program header对应的虚拟地址，要加上这个偏移量，才能使后续的&lt;code&gt;elf_exec_load&lt;&#x2F;code&gt;函数将其装载到正确的物理地址上。&lt;&#x2F;p&gt;
&lt;p&gt;对于&lt;code&gt;elf_exec_load&lt;&#x2F;code&gt;函数，我们可以忽略其对&lt;code&gt;ET_DYN&lt;&#x2F;code&gt;类型ELF文件的处理，因为ELF格式的内核不是该类型的ELF文件。函数中，对于每一个PT_LOAD类型的program header，都执行如下操作：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;add_segment&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(info,
			phdr-&amp;gt;p_data, size,
			phdr-&amp;gt;p_paddr + base, phdr-&amp;gt;p_memsz);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;该函数定义如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;add_segment&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kexec_info *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;info&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;buf&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, size_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;bufsz&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;base&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, size_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;memsz&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;add_segment_phys_virt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(info, buf, bufsz, base, memsz, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;注意&lt;code&gt;add_segment_phys_virt&lt;&#x2F;code&gt;的最后一个参数为1，这表明应该将传入的地址当作虚拟地址对待，通过&lt;code&gt;virt_to_phys&lt;&#x2F;code&gt;函数将其转换为物理地址。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;nei-he-ming-ling-xing-yu-initrdde-chuan-ru&quot;&gt;内核命令行与initrd的传入&lt;&#x2F;h3&gt;
&lt;p&gt;ARM64内核启动时，要求用x0寄存器传递DTB在内存中的地址。kexec工具支持从命令行传入被装载内核的DTB文件，因此kexec可以从三个地方获取装载内核的DTB文件：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;命令行传入文件&lt;&#x2F;li&gt;
&lt;li&gt;&#x2F;sys&#x2F;firmware&#x2F;fdt&lt;&#x2F;li&gt;
&lt;li&gt;&#x2F;proc&#x2F;device-tree&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;优先级由高到低。获取到DTB之后，需要分别修正三个地方：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&#x2F;chosen&#x2F;bootargs          # 内核命令行&lt;&#x2F;li&gt;
&lt;li&gt;&#x2F;chosen&#x2F;linux,elfcorehdr           # 前面提到的ELF header地址&lt;&#x2F;li&gt;
&lt;li&gt;&#x2F;chosen&#x2F;linux,usable-memory-range     # 可用的内存区域，即crashkernel保留的内存区域&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;然后将initrd装载到一个新的kexec_segment中，然后修正DTB，加入initrd相关的结点：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&#x2F;chosen&#x2F;linux,initrd-start&lt;&#x2F;li&gt;
&lt;li&gt;&#x2F;chosen&#x2F;linux,initrd-end&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;最后将DTB装入自己的kexec_segment中。后面会提到，DTB的地址由purgatory通过x0寄存器传递给capture内核。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;purgatoryji-zhi&quot;&gt;purgatory机制&lt;&#x2F;h3&gt;
&lt;p&gt;前面可能已经注意到了，最终传递给&lt;code&gt;kexec_load&lt;&#x2F;code&gt;系统调用的entry参数并不是直接指向内核的。这说明kexec实现了自己的微型引导程序。kexec中这段微型引导程序被称为purgatory，其作用主要为校验内核镜像的哈希值与跳转到内核执行。该引导程序唯一需要准备的就是内核执行时将x0置为DTB的物理地址，其他ARM64内核boot协议中要求的条件都将由primary内核在crash时准备妥当。&lt;&#x2F;p&gt;
&lt;p&gt;purgatory的实现比较简单，由一小段汇编与一个用于计算内核镜像哈希值的C语言函数组成。程序被编译链接成relocatable的ELF文件镜像，并由kexec工程的编译系统将这个EFL文件填充至一个字节数组中备用。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const char&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; purgatory[] = {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x7f&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x45&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x4c&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x46&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x02&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x01&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x01&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x00&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x00&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x00&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x00&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x00&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x00&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x00&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x00&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x00&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x01&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x00&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x3e&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x00&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x01&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x00&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x00&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x00&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x40&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x07&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x00&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x00&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x00&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x00&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x00&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x00&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
    ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.globl purgatory_start
purgatory_start:

	adr	x19&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.Lstack
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x19

	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;bl	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;purgatory

	&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Start new image. &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
	ldr	x17&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;arm64_kernel_entry
	ldr	x0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;arm64_dtb_addr
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;xzr
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;xzr
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;xzr
	br	x17

size purgatory_start
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;arm64_kernel_entry和arm64_dtb_addr都是64位的指针，由kexec装载purgatory到内存时填充。注意purgatory是relocatable的镜像，在装入内存时需要进行relocate操作，kexec完整了relocatable ELF镜像的loader。ELF文件格式及其装载操作可以参考ELF Spec文档，这里不再赘述。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 读取purgatory_start在内存中relocate后的位置
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	info-&amp;gt;entry = (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;elf_rel_get_addr&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;info-&amp;gt;rhdr, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;purgatory_start&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;);
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; image_base = kernel_segment + arm64_mem.text_offset
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;elf_rel_set_symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;info-&amp;gt;rhdr, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;arm64_kernel_entry&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, &amp;amp;image_base,
		sizeof(image_base));
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 设置装载到内存中的arm64_dtb_addr变量的值
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;elf_rel_set_symbol&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;info-&amp;gt;rhdr, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;arm64_dtb_addr&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, &amp;amp;dtb_base,
		sizeof(dtb_base));
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;capturenei-he-ru-he-huo-qu-vmcore&quot;&gt;capture内核如何获取vmcore&lt;&#x2F;h3&gt;
&lt;p&gt;这个问题的前置问题是：capture内核如何确定自己是capture内核？内核启动时会检测&lt;code&gt;elfcorehdr&lt;&#x2F;code&gt;命令行参数（或者&lt;code&gt;&#x2F;chosen&#x2F;linux,elfcorehdr&lt;&#x2F;code&gt;设备树节点），如果存在则认为自己是capture内核。内核parse完该参数后，会将&lt;code&gt;elfcorehdr&lt;&#x2F;code&gt;的地址保存在&lt;code&gt;elfcorehdr_addr&lt;&#x2F;code&gt;变量中，后续也以该变量的值确认当前的状态。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static inline bool &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;is_kdump_kernel&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; elfcorehdr_addr != ELFCORE_ADDR_MAX;
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;用户态判断当前的内核是否为capture内核的直接方式是确认&lt;code&gt;&#x2F;proc&#x2F;vmcore&lt;&#x2F;code&gt;是否存在。那么分析内核代码时，也需要从这里入手。前面elfcorehdr参数实际上是一个earlyparam，因此在调用&lt;code&gt;__init&lt;&#x2F;code&gt;函数之前就已经完成的处理。内核中注册了位于&lt;code&gt;fs&#x2F;proc&#x2F;vmcore.c&lt;&#x2F;code&gt;中的&lt;code&gt;vmcore_init&lt;&#x2F;code&gt;函数，用于处理从primary内核传入的elfcorehdr。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;fs_initcall&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(vmcore_init);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;该函数在检测到elfcorehdr后会进行处理，然后注册&lt;code&gt;&#x2F;proc&#x2F;vmcore&lt;&#x2F;code&gt;文件。处理过程较为简单，下面主要提及主要步骤：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;将所有的PT_NOTE类型的Program header合并成一个&lt;&#x2F;li&gt;
&lt;li&gt;重新计算所有Program Header类型的大小及偏移量&lt;&#x2F;li&gt;
&lt;li&gt;将所有需要dump内存区域的信息整理成一个链表备用&lt;&#x2F;li&gt;
&lt;li&gt;计算vmcore文件的大小&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;最后用户态读取&lt;code&gt;&#x2F;proc&#x2F;vmcore&lt;&#x2F;code&gt;文件时，对于vmcore的ELF header和PT_NOTE可以直接读取，对于需要读取内存dump时则从原先primary内核的地址空间读取，省去了大片内存的拷贝。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;pt-noteru-he-sheng-cheng&quot;&gt;PT_NOTE如何生成&lt;&#x2F;h3&gt;
&lt;p&gt;前面看到PT_NOTE类型的Program header一共有两类，分别由：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu[N]&#x2F;crash_notes{,_size}
&#x2F;sys&#x2F;kernel&#x2F;vmcoreinfo
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;给出其物理地址。内核crash时应该会向其中写入对应的PT_NOTE类型的Program headers。这种类型的Program header的内容是由不定长的条目组成的，每个条目的header如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Note header in a PT_NOTE section *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typedef struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; elf64_note {
  Elf64_Word n_namesz;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Name size *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;  Elf64_Word n_descsz;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Content size *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;  Elf64_Word n_type;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Content type *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;} Elf64_Nhdr
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在header之后紧随name和desc的字符串，字符串的首尾必须4字节对齐。name与type表示该条目的名称与类型，是由core文件生成方与读取方协定好的。条目的内容存放在desc中，格式也由core文件生成方自行定义，ELF文件spec中没有过多定义。&lt;&#x2F;p&gt;
&lt;p&gt;先看vmcoreinfo，该文件在内核编译时开启了&lt;code&gt;CONFIG_CRASH_CORE&lt;&#x2F;code&gt;时会存在：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#ifdef&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; CONFIG_CRASH_CORE

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ssize_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;vmcoreinfo_show&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kobject *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kobj&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
			       &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kobj_attribute *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;attr&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;char &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;buf&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
	phys_addr_t vmcore_base = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;paddr_vmcoreinfo_note&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sprintf&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(buf, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%p&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, &amp;amp;vmcore_base,
			(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)VMCOREINFO_NOTE_SIZE);
}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;KERNEL_ATTR_RO&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(vmcoreinfo);

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#endif &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* CONFIG_CRASH_CORE *&#x2F;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个PT_NOTE只有一个条目，其name与type为&lt;code&gt;VMCOREINFO&lt;&#x2F;code&gt;和0。desc格式如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{TYPE}({NAME})={VALUE}\n
{TYPE}({NAME})={VALUE}\n
{TYPE}({NAME})={VALUE}\n
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;主要记录内核中一些关键符号的物理地址、关键数据类型的字段偏移量和关键常量的值，具体内容可以参见&lt;a href=&quot;https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;html&#x2F;latest&#x2F;admin-guide&#x2F;kdump&#x2F;vmcoreinfo.html&quot;&gt;内核文档&lt;&#x2F;a&gt;。由于这些信息都是内核的固有信息，因此这些内容在内核初始化是就会自动生成。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;subsys_initcall&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(crash_save_vmcoreinfo_init);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;下面来介绍crash_notes相关的信息。crash_notes应该是每个逻辑CPU对应一个，所以是一个percpu的变量，文件本身的定义在&lt;code&gt;driver&#x2F;base&#x2F;cpu.c&lt;&#x2F;code&gt;中可以找到。可以想象到crash_note是一个buffer的物理地址，这个buffer在&lt;code&gt;kernel&#x2F;kexec_core.c&lt;&#x2F;code&gt;中定义。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;note_buf_t __percpu *crash_notes;

typedef u32 note_buf_t[CRASH_CORE_NOTE_BYTES&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;];
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;该percpu变量由&lt;code&gt;crash_notes_memory_init&lt;&#x2F;code&gt;函数初始化。前面看到，ARM64内核下内核崩溃时会调用&lt;code&gt;machine_crash_shutdown&lt;&#x2F;code&gt;函数，进而调用到&lt;code&gt;crash_save_cpu&lt;&#x2F;code&gt;函数，该函数会填写&lt;code&gt;crash_notes&lt;&#x2F;code&gt;。从中可以发现该函数填写的是标准的PTSTATUS信息，即普通coredump通用的线程信息，其name与type分别为&lt;code&gt;CORE&lt;&#x2F;code&gt;和NT_PRSTATUS（1）。函数只拷贝了当前CPU的运行task的PID与当前CPU的通用寄存器。&lt;&#x2F;p&gt;
&lt;p&gt;crash_save_cpu可能从两条code path被调用。内核崩溃时，触发崩溃的CPU会调用crash_save_cpu，并通过IPI中断告知其他CPU内核已经崩溃。在其他CPU的IPI中断处理函数中也会调用一次crash_save_cpu用以保存其他CPU的现场。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;build-elf-exec-info&quot;&gt;build_elf_exec_info&lt;&#x2F;h3&gt;
&lt;p&gt;函数本质是通过搜集系统信息获取以下结构体的字段，然后对ELF文件进行合法性检查。传入的buf其实就是crash内核解压后的内容。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;mem_ehdr {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ei_class;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ei_data;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; e_type;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; e_machine;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; e_version;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; e_flags;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; e_phnum;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; e_shnum;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; e_shstrndx;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; e_entry;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; e_phoff;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; e_shoff;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; e_notenum;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;mem_phdr *e_phdr;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;mem_shdr *e_shdr;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;mem_note *e_note;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; rel_addr, rel_size;
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;函数内部调用到了&lt;code&gt;build_elf_info&lt;&#x2F;code&gt;，继而调用到了&lt;code&gt;build_mem_ehdr&lt;&#x2F;code&gt;。&lt;code&gt;build_mem_ehdr函数&lt;&#x2F;code&gt;内部基本上就是填充ELF identity相关的字段，然后检查ELF header的合法性，最后根据ELF class的值（elf32或者elf64）将剩余工作委托给&lt;code&gt;build_mem_elf32_ehdr&lt;&#x2F;code&gt;函数或者&lt;code&gt;build_mem_elf64_ehdr&lt;&#x2F;code&gt;。这两个函数内部仅仅是拷贝对应字段，然后转换对应endian到host端endian。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;elf-arm64-load&quot;&gt;elf_arm64_load&lt;&#x2F;h3&gt;
&lt;p&gt;前面可以看到，对于每一个架构，架构相关代码注册该架构能够处理的内核文件格式。该函数就是对应于ELF格式的内核装载函数。函数首先调用&lt;code&gt;build_elf_exec_info&lt;&#x2F;code&gt;将ELF内核相关的ELF headers拷贝出来，其实就是换个格式原样copy，改了下endian。&lt;&#x2F;p&gt;
&lt;p&gt;然后函数开始处理image header，这里的image header指ARM64的内核镜像的image header。可以从内核文档的ARM64 boot protocol中得到该header的信息。我们从内核的连接脚本可以知道ELF格式的内核有两个PT_LOAD类型的segment，分别为code和data。对于这两个segment，尝试从中读取image header。我们知道有个内核特性能够让内核的text段装载地址随机化，这里需要特殊处理一下，否则是找不到image header的。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;		header_offset = ehdr.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;e_entry &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;- phdr-&amp;gt;p_vaddr;

		header = (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; arm64_image_header *)(
			kernel_buf + phdr-&amp;gt;p_offset + header_offset);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在确认ARM64内核的magic无误之后，可以认为读取到了image header。接下来需要从image header中拿出两个值：text_offset和image_size，这两个值对于后面装载内核至关重要。在比较旧的内核（&amp;lt;3.17）中没有这两个值，需要使用默认值，这里需要注意。image_size即ARM64内核镜像的大小，text_offset为内核被放置的偏移量，后面详细说明。&lt;&#x2F;p&gt;
&lt;p&gt;函数后续调用&lt;code&gt;arm64_locate_kernel_segment&lt;&#x2F;code&gt;计算出内核放置的位置。对于crash模式，放置地址需要在crashkernel保留的内存空间中。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	kernel_segment = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;arm64_locate_kernel_segment&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(info);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;		hole = (crash_reserved_mem.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;start &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;lt; mem_min ?
				mem_min : crash_reserved_mem.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;start&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
		hole = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_ALIGN_UP&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(hole, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;MiB&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;));
		hole_end = hole + arm64_mem.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;text_offset &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;+ arm64_mem.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;image_size&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里第二行做这个对齐操作是因为ARM64启动协议要求内核被放置在一个2M对齐的内存区域上。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;nei-he-ji-zhi&quot;&gt;内核机制&lt;&#x2F;h2&gt;
&lt;p&gt;flags中最后一位是&lt;code&gt;KEXEC_ON_CRASH&lt;&#x2F;code&gt;，有无这个flags会严格区分两个code path。由于我们分析kexec的目的是理解kdump的实现机制，因此从&lt;code&gt;KEXEC_ON_CRASH&lt;&#x2F;code&gt;入手进行分析。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;extern struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kimage *kexec_image;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;extern struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kimage *kexec_crash_image;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;内核使用kimage表示一个在内核中的镜像。使用&lt;code&gt;KEXEC_ON_CRASH&lt;&#x2F;code&gt;时，操作的是&lt;code&gt;kexec_crash_image&lt;&#x2F;code&gt;。当&lt;code&gt;kexec_load&lt;&#x2F;code&gt;系统调用传入的&lt;code&gt;nr_segments&lt;&#x2F;code&gt;参数为0时，内核会卸载掉对应的系统镜像。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;kexec-segment&quot;&gt;kexec_segment&lt;&#x2F;h3&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kexec_segment {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;*
	 * This pointer can point to user memory if kexec_load() system
	 * call is used or will point to kernel memory if
	 * kexec_file_load() system call is used.
	 *
	 * Use -&amp;gt;buf when expecting to deal with user memory and use -&amp;gt;kbuf
	 * when expecting to deal with kernel memory.
	 *&#x2F;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;union &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; __user *buf;
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*kbuf;
	};
	size_t bufsz;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; mem;
	size_t memsz;
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个结构体是kexec_load系统调用传入的主要参数之一，总共有两个形态。在&lt;code&gt;kexec_load&lt;&#x2F;code&gt;中，第一个字段为用户态地址，而在&lt;code&gt;kexec_file_load&lt;&#x2F;code&gt;中，其第一个字段为内核地址。&lt;&#x2F;p&gt;
&lt;p&gt;从&lt;code&gt;kimage_load_crash_segment&lt;&#x2F;code&gt;中可以看到，内核对这个结构体的主要处理是将由前两个参数指定的缓冲区的内容复制到由后两个参数指定的物理内存区域中。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;do-kexec-load&quot;&gt;do_kexec_load&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;申请新的kimage&lt;&#x2F;li&gt;
&lt;li&gt;拷贝vmcore_info到新申请的page里(应该不是真的vmcore而是某种指针性质的东西)&lt;&#x2F;li&gt;
&lt;li&gt;调用&lt;code&gt;kimage_load_crash_segment&lt;&#x2F;code&gt;将kexec_segment中指定的buffer拷贝到对应物理内存区域中&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;image_terminate ? TODO&lt;&#x2F;p&gt;
&lt;p&gt;kimage_entry_t kimage-&amp;gt;head&lt;&#x2F;p&gt;
&lt;h3 id=&quot;kimage-entry-t&quot;&gt;kimage_entry_t&lt;&#x2F;h3&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kimage {
	kimage_entry_t head;
	kimage_entry_t *entry;
	kimage_entry_t *last_entry;
    ...
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;kimage结构体的开头三个字段是&lt;code&gt;kimage_entry_t&lt;&#x2F;code&gt;类型的数据。该类型为一个指针类型（unsigned long），但是利用了一个trick，使用指针的低位保存特定flags。该指针的高位应该是用来保存一个page的物理地址。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;kimage_entry_t&lt;&#x2F;code&gt;实际上在crash模式下的kimage中是没有被用到的，但是最后调用cpu_soft_reset时需要将&lt;code&gt;kimage-&amp;gt;head&lt;&#x2F;code&gt;传入当作一个参数，后续读这段汇编代码时需要深入分析。先看初始化代码：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	image-&amp;gt;head = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
	image-&amp;gt;entry = &amp;amp;image-&amp;gt;head;
	image-&amp;gt;last_entry = &amp;amp;image-&amp;gt;head
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上面为&lt;code&gt;do_kimage_alloc_init&lt;&#x2F;code&gt;函数中用于初始化这三个字段操作。首先明确这几个字段正常使用时分别保存了什么：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;head保存申请的内存区域第一个page的物理地址（物理地址）&lt;&#x2F;li&gt;
&lt;li&gt;entry是指向当前保存的最后一个entry的指针（虚拟地址）&lt;&#x2F;li&gt;
&lt;li&gt;last_entry指向申请的内存区域的最后一个entry位置（虚拟地址）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这里可以看到head设置为0，表示这块内存区域还没有申请。后续可以看到，在向kimage增加entry时（kimage_add_entry），会检查是否申请了内存区域，如果没有则进行申请：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(image-&amp;gt;entry == image-&amp;gt;last_entry) {
		kimage_entry_t *ind_page;
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; page *page;

		page = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kimage_alloc_page&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(image, GFP_KERNEL, KIMAGE_NO_DEST);
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(!page)
			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;-ENOMEM;

		ind_page = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;page_address&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(page);
		*image-&amp;gt;entry = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;virt_to_boot_phys&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(ind_page) | IND_INDIRECTION;
		image-&amp;gt;entry = ind_page;
		image-&amp;gt;last_entry = ind_page +
				      ((PAGE_SIZE&#x2F;sizeof(kimage_entry_t)) - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
	}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里尚没有分析这些entry的作用，但是可以确认在crash模式下的kexec并不会使用他们，而是直接使用&lt;code&gt;kimage_terminate&lt;&#x2F;code&gt;标记entry的结尾。后续需要分析普通模式下的kexec时，再做分析。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;crash-kexec&quot;&gt;__crash_kexec&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;__crash_kexec&lt;&#x2F;code&gt;函数是kdump的入口函数，在内核调用panic函数时被调用。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__crash_kexec&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;函数看着比较简单：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(kexec_crash_image) {
			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; pt_regs fixed_regs;

			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;crash_setup_regs&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;fixed_regs, regs);
			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;crash_save_vmcoreinfo&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;machine_crash_shutdown&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;fixed_regs);
			&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;machine_kexec&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(kexec_crash_image);
		}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;首先检查capture kernel是否已经装载，这是后续操作可以进行的前提。&lt;code&gt;crash_setup_regs&lt;&#x2F;code&gt;函数是一段简单的内联汇编，在其第二个参数为NULL时会dump下来当前寄存器的状态。&lt;code&gt;crash_save_vmcoreinfo&lt;&#x2F;code&gt;函数将前面的vmcoreinfo保存下来。&lt;code&gt;machine_crash_shutdown&lt;&#x2F;code&gt;函数会暂停所有CPU的执行，并dump下其寄存器状态。最后&lt;code&gt;machine_kexec&lt;&#x2F;code&gt;函数真正执行kexec的功能，启动crash内核。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;machine-kexec&quot;&gt;machine_kexec&lt;&#x2F;h3&gt;
&lt;p&gt;前面可以看到，装载crash内核时，申请了一个&lt;code&gt;control_code_page&lt;&#x2F;code&gt;。内核在进行kexec操作时，需要尽量不要破坏原有内核的环境，这个control_code_page实质上就是在原先预留出的内存空间中申请出来的page，用于保存relocate内核操作的函数代码。我们可以看到如下操作：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	reboot_code_buffer_phys = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;page_to_phys&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(kimage-&amp;gt;control_code_page);
	reboot_code_buffer = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;phys_to_virt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(reboot_code_buffer_phys);
	
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;memcpy&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(reboot_code_buffer, arm64_relocate_new_kernel, arm64_relocate_new_kernel_size);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;该函数实现在&lt;code&gt;.&#x2F;arch&#x2F;arm64&#x2F;kernel&#x2F;relocate_kernel.S&lt;&#x2F;code&gt;文件中。在完成一些缓存与flags操作之后，重置cpu：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cpu_soft_restart&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(reboot_code_buffer_phys, kimage-&amp;gt;head, kimage-&amp;gt;start, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;cpu-soft-restart&quot;&gt;cpu_soft_restart&lt;&#x2F;h3&gt;
&lt;p&gt;该函数工作本质上由&lt;code&gt;__cpu_soft_restart&lt;&#x2F;code&gt;完成。只不过需要将内核的page table还原成idmap（identity map）状态。可以明确entry参数为前面的&lt;code&gt;reboot_code_buffer_phys&lt;&#x2F;code&gt;即保存了&lt;code&gt;arm64_relocate_new_kernel&lt;&#x2F;code&gt;代码的一个page。剩余部分需要分析汇编代码，当然只看不写的话汇编代码也是比较简单的。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ENTRY(__cpu_soft_restart)
	&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Clear sctlr_el1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;flags&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;. &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
	mrs	x12&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;sctlr_el1
	ldr	x13&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;=SCTLR_ELx_FLAGS
	bic	x12&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x12&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x13
	pre_disable_mmu_workaround
	msr	sctlr_el1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x12
	isb

	cbz	x0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;1f				&#x2F;&#x2F; el2_switch?
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;#HVC_SOFT_RESTART
	hvc	#&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0				&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;&#x2F; no return

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;:	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x18&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x1				&#x2F;&#x2F; entry
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x2				&#x2F;&#x2F; arg0
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x3				&#x2F;&#x2F; arg1
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x4				&#x2F;&#x2F; arg2
	br	x18
ENDPROC(__cpu_soft_restart)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里首先注意&lt;code&gt;.pushsection    .idmap.text, &amp;quot;awx&amp;quot;&lt;&#x2F;code&gt;指令，他将这个函数放置名为&lt;code&gt;.idmap.text&lt;&#x2F;code&gt;的section中，并将其内存属性设置可分配，可写与可执行。函数开头将SCTRL_EL1上的M，A，C，SA，I位清除：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;SCTLR_ELx_FLAGS	(SCTLR_ELx_M | SCTLR_ELx_A | SCTLR_ELx_C | \
			 SCTLR_ELx_SA | SCTLR_ELx_I)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;即关闭命令与数据缓存，关闭对齐检查与栈对齐检查，关闭MMU。然后用isb命令清空指令cache。后面这个调用hvc的code path这里不分析，后续需要结合异常处理代码分析。最后函数将参数保存至x0，x1，x2然后跳转到entry（即前面的arm64_relocate_new_kernel）执行。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;arm64-relocate-new-kernel&quot;&gt;arm64_relocate_new_kernel&lt;&#x2F;h3&gt;
&lt;p&gt;该函数由汇编写成。先总结一个结论，对于crash模式下的kexec，函数基本不执行任何操作，仅仅是清除&lt;code&gt;SCTLR_ELx_FLAGS&lt;&#x2F;code&gt;然后跳转到&lt;code&gt;kimage-&amp;gt;start&lt;&#x2F;code&gt;然后开始执行，跳转时x0-x3参数的值都为0。为了更明确其行为，帮助理解普通kexec下进行的操作，有必要分析这个函数。前面提到函数开头会检测当前是否处于EL2，如果是则会清除对应的flags：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;	&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Clear the sctlr_el2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;flags&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;. &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
	mrs	x0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;CurrentEL
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;cmp	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;#CurrentEL_EL2
	b.ne	1f
	mrs	x0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;sctlr_el2
	ldr	x1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;=SCTLR_ELx_FLAGS
	bic	x0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x1
	pre_disable_mmu_workaround
	msr	sctlr_el2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x0
	isb
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;:
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;函数之后处理kimage-&amp;gt;head，看到这里明白&lt;code&gt;kimage-&amp;gt;head&lt;&#x2F;code&gt;实际上是新kernel进行relocation所需的信息。当然对于crash模式下的kexec来说，&lt;code&gt;kimage-&amp;gt;head&lt;&#x2F;code&gt;是IND_DONE，loop会直接跳出。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;	&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Check if the new image needs relocation. &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
	tbnz	x16&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;IND_DONE_BIT&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.Ldone
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;loop在循环时会检查entry里flags的值：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;IND_DESTINATION：将entry里的page地址设置为拷贝时的目标地址dest&lt;&#x2F;li&gt;
&lt;li&gt;IND_INDIRECTION：循环在遇到这个标志时，会从entry指向的page里读取新的entry。这样可以实现多buffer保存entry&lt;&#x2F;li&gt;
&lt;li&gt;IND_SOURCE：循环遇到这个标志时，会把entry指向的page整个复制到dest指向的page，并将dest的值自增指向dest向后的下个page&lt;&#x2F;li&gt;
&lt;li&gt;IND_DONE: 循环读到这个flag时，会退出执行&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;loop处理完毕时，新内核的relocation也完成了，函数在刷新完缓存后跳转到&lt;code&gt;kimage-&amp;gt;start&lt;&#x2F;code&gt;进行执行。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;	&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Start new image. &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;xzr
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;xzr
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;xzr
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;x3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;xzr
	br	x17
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;</content>
	</entry>
	<entry xml:lang="en">
		<title>Linux设备模型：bus与driver</title>
		<published>2018-04-28T00:00:00+00:00</published>
		<updated>2018-04-28T00:00:00+00:00</updated>
		<link href="https://crab2313.github.io/bus-and-driver/" type="text/html"/>
		<id>https://crab2313.github.io/bus-and-driver/</id>
		<content type="html">&lt;h1 id=&quot;bus-driver&quot;&gt;bus &amp;amp; driver&lt;&#x2F;h1&gt;
&lt;p&gt;bus core的实现在&lt;code&gt;driver&#x2F;base&#x2F;bus.c&lt;&#x2F;code&gt;中，初始化过程由buses_init函数实现，函数中创建了两个kset：bus_kset（name为bus）和system_kset（name为system）。初始化过程这么简单的话bus注册的工作应该就会比较复杂了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;subsys-private&quot;&gt;subsys_private&lt;&#x2F;h2&gt;
&lt;p&gt;为了隐藏bus core内部的状态，每个bus_type都保存一个指向subsys_private结构体的指针，这个数据结构只能由bus core中进行操作。其中subsys即为表示该bus的kset，subsys中还将放置另外两个kset，即结构体中的devices_kset和drivers_kset，很明显这两个kset用于存放驱动和设备。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;subsys_private {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kset subsys;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kset *devices_kset;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; list_head interfaces;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; mutex mutex;

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kset *drivers_kset;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; klist klist_devices;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; klist klist_drivers;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; blocking_notifier_head bus_notifier;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; drivers_autoprobe:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;bus_type *bus;

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kset glue_dirs;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;class *class;
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;bus-register&quot;&gt;bus_register&lt;&#x2F;h2&gt;
&lt;p&gt;这个函数应该是bus core最广为人知的入口了，可以将一个bus_type注册到内核的bus子系统中。抛开大部分内存申请等常规初始化过程不谈，函数中首先创建了一个subsys_private对象，并将其的指针保存到bus-&amp;gt;p中。随即将bus-&amp;gt;p-&amp;gt;kobj的name设置为bus-&amp;gt;name，并将这个kset加入到前面提到的bus_kset中。顺便一提表示一个bus的kset使用bus_ktype作为其类型，后面详细说明。&lt;&#x2F;p&gt;
&lt;p&gt;接下来函数调用kset_create_and_add创建devices_kset和drivers_kset，并将其加入表示bus的kset。在做完以上工作后，函数向表示该bus的kset中加入了三个属性：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;uevent&lt;&#x2F;li&gt;
&lt;li&gt;drivers_autoprobe&lt;&#x2F;li&gt;
&lt;li&gt;drivers_probe&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;而传入bus_register的bus_type-&amp;gt;bus_group也会被当作attribue_group注册到bus对应的sysfs文件夹中。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;busde-san-ge-shu-xing&quot;&gt;bus的三个属性&lt;&#x2F;h2&gt;
&lt;p&gt;前面提到表示bus的kset中加入了三个属性，这里列出他们的定义：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;BUS_ATTR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(uevent, S_IWUSR, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, bus_uevent_store);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;BUS_ATTR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(drivers_probe, S_IWUSR, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, store_drivers_probe);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;BUS_ATTR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(drivers_autoprobe, S_IWUSR | S_IRUGO,
                show_drivers_autoprobe, store_drivers_autoprobe);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这三个属性会作为文件存在于sysfs中。首先drivers_autoprobe是比较好理解的，subsystem_private中保存了一个drivers_autoprobe值，如果为true则进行驱动与设备的自动匹配。向sysfs中一个bus对应文件夹下的drivers_autoprobe写入1或者0则可以改变它的值。&lt;&#x2F;p&gt;
&lt;p&gt;uevent则作为一个调试uevent的接口，通过向该文件写入对应的信息，内核可以调用kobject_synth_uevent函数生成对应的uevent事件。可以直接使用echo进行该操作，而写入字符串的格式如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ACTION [UUID] [KEY1=VALUE1] [KEY2=VALUE2] ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里写入的环境变量会以SYNTH_ARG_KEY=VALUE的形式出现在uevent信息中。最后一个drivers_probe属性可以让总线重新为一个没有匹配到驱动的设备进行驱动匹配。将想要进行匹配的设备名写入到drivers_probe即可进行该操作。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;subsys-system-register&quot;&gt;subsys_system_register&lt;&#x2F;h2&gt;
&lt;p&gt;文档里说这个接口不要在新代码中用，接口本身只做兼容性用途。前面提到了一个system_ket，这里需要提一下它是如何初始化的：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        system_kset = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kset_create_and_add&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;system&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &amp;amp;devices_kset-&amp;gt;kobj);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以猜到devices_kset应该&lt;code&gt;&#x2F;sys&#x2F;devices&lt;&#x2F;code&gt;文件夹，也就是说system_ket的路径为&lt;code&gt;&#x2F;sys&#x2F;devices&#x2F;system&lt;&#x2F;code&gt;。首先函数注册了一个假设备，名字与传入的bus_type一致，然后将这个设备的parent设置成system_kset.kobj，并将bus_type-&amp;gt;dev_root设置刚才注册的那个假设备。总线新注册设备时会将其parent设置成dev_root，因此使用subsys_system_register函数注册的总线（子系统）会被放到&lt;code&gt;&#x2F;sys&#x2F;devices&#x2F;system&#x2F;&amp;lt;bus-name&amp;gt;&#x2F;&lt;&#x2F;code&gt;底下。我们常见的子系统有clocksource，cpu，memory等等。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bustong-zhi-ji-zhi&quot;&gt;bus通知机制&lt;&#x2F;h2&gt;
&lt;p&gt;subsys_private中有一个bus_notifier，他是一个blocking_notifier。内核各个子系统之间为了高效进行信息传递使用注册监听机制，称作notifier。这里使用的是blocking_notifier，其特点是发送事件是可以阻塞。当然，bus core负责事件的发送，所以我们最多进行事件的监听。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bus-add-device&quot;&gt;bus_add_device&lt;&#x2F;h2&gt;
&lt;p&gt;一个bus从逻辑上来讲是要管理设备和驱动的，所以应该提供对应的接口将总线或者驱动加入到bus中来。但是事实上，bus_add_device并没有被export出来，也就是说内核模块是不能调用这个函数的。&lt;&#x2F;p&gt;
&lt;p&gt;每个设备在创建时都应将其bus指针设置成其对应的bus_type，所以函数第一步做的就是将其bus_type取出来。接下来所作大部分是sysfs相关的处理：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;调用device_add_groups将bus-&amp;gt;dev_groups加入到设备中去，翻译成白话就是在设备对应的sysfs文件夹中加入总线自己定义的一些属性。&lt;&#x2F;li&gt;
&lt;li&gt;调用sysfs_create_link创建从设备到bus-&amp;gt;p-&amp;gt;devices_kset的符号连接，也就是在sysfs中建立从设备文件夹到bus&#x2F;devices文件夹下的符号连接。&lt;&#x2F;li&gt;
&lt;li&gt;调用sysfs_create_link在设备文件夹内创建一个名为subsystem的符号连接，该链接指向bus文件夹。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;最后将设备挂入bus维护的设备列表中。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bus-add-driver&quot;&gt;bus_add_driver&lt;&#x2F;h2&gt;
&lt;p&gt;类似于device，driver也有一个bus指针指向它应该属于的bus_type。传进来的device_driver本身没有kobject，bus_add_driver会创建一个嵌入了kobject的driver_private结构体并将其保存在device_driver中。很明显，这个被创建的kobject的kset指针需要被设置成bus-&amp;gt;p-&amp;gt;drivers_kset，即其注册入sysfs时会被放入&lt;code&gt;&#x2F;sys&#x2F;bus&#x2F;&amp;lt;bus-name&amp;gt;&#x2F;drivers&#x2F;&lt;&#x2F;code&gt;文件夹中。&lt;&#x2F;p&gt;
&lt;p&gt;如果bus的drivers_autoprobe为true，则bus_add_driver会尝试进行设备匹配。与bus设备一样，driver也被加入了uevent属性，也就是driver对应的文件夹下也有uevent文件，向其写人对应的命令也能触发uevent事件。类似于device，bus-&amp;gt;drv_groups保存的attribute_group向该bus中的driver追加了bus预先设置好的属性。&lt;&#x2F;p&gt;
&lt;p&gt;如果device_driver里的suppress_bind_attrs不为true，则bus_add_driver应该向其追加两个属性：bind和unbind。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;DRIVER_ATTR_WO&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(unbind);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;DRIVER_ATTR_WO&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(bind);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个文件的作用是相反的：将设备名写入在一个driver文件夹下的unbind文件时，会使driver释放掉该设备，bind文件则会使driver试图匹配该设备。最后可以看一下这一行：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;module_add_driver&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(drv-&amp;gt;owner, drv);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;该函数的主要作用为更新引用计数，并创建两个符号链接：driver文件夹下的module，&lt;code&gt;&amp;lt;module&amp;gt;&#x2F;drivers&#x2F;&lt;&#x2F;code&gt;文件夹下的driver。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;driver-register&quot;&gt;driver_register&lt;&#x2F;h2&gt;
&lt;p&gt;这个函数其实没有做什么事情，大部分工作都由bus承担了。函数首先调用driver_find查找bus上是否已经有了同名驱动，如果有则报错退出。接下来调用bus_add_driver将其注册到bus中去。如果device_driver-&amp;gt;groups不为NULL，则将其添加到自身的属性中。最后触发一个ADD类型的uevent事件。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Linux设备模型：kobject与uevent</title>
		<published>2018-04-28T00:00:00+00:00</published>
		<updated>2018-04-28T00:00:00+00:00</updated>
		<link href="https://crab2313.github.io/kobject-and-uevent/" type="text/html"/>
		<id>https://crab2313.github.io/kobject-and-uevent/</id>
		<content type="html">&lt;h1 id=&quot;kobject&quot;&gt;kobject&lt;&#x2F;h1&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kobj_type {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*release)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kobject *kobj);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;sysfs_ops *sysfs_ops;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;attribute **default_attrs;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kobj_ns_type_operations *(*child_ns_type)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kobject *kobj);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*(*namespace)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kobject *kobj);
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kobj_ns_type_operations {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;enum&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kobj_ns_type type;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*current_may_mount)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*(*grab_current_ns)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*(*netlink_ns)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; sock *sk);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*(*initial_ns)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*drop_ns)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*);
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kobject {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const char              &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*name;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; list_head        entry;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kobject          *parent;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kset             *kset;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kobj_type        *ktype;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;kernfs_node      *sd; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* sysfs directory entry *&#x2F;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kref             kref;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#ifdef&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; CONFIG_DEBUG_KOBJECT_RELEASE
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; delayed_work     release;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#endif
        unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; state_initialized:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; state_in_sysfs:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; state_add_uevent_sent:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; state_remove_uevent_sent:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; uevent_suppress:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;kobject-init&quot;&gt;kobject_init&lt;&#x2F;h2&gt;
&lt;p&gt;初始化时必须传入一个ktype参数，否则无法成功初始化，这个是必然的，每个嵌入kobject的结构体必须在引用计数变为0的时候必须使用ktype中保存的release函数指针进行销毁。kobj中保存了一个state_initialized字段，用以标记该kobject是初始化过的，从这里也能看出申请完kobject结构体之后必须将其全部写零。接下来初始化kobj-&amp;gt;kref作为引用计数，初始化kobj-&amp;gt;entry（这个list_head用于将kobject保存到一个kset中）。最后可以看到kobject还有三个字段用于标记其状态：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;state_in_sysfs&lt;&#x2F;li&gt;
&lt;li&gt;state_add_uevent_sent&lt;&#x2F;li&gt;
&lt;li&gt;state_remove_uevent_sent&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;从名字中即可看出其表示的含义，后两个状态表示对应的uevent事件是否已经发送给用户态。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;kobject-add&quot;&gt;kobject_add&lt;&#x2F;h2&gt;
&lt;p&gt;函数首先检查state_initialized字段，即kobject是否已经通过kobject_init进行初始化。随后设置kobject的name和parent，并确认name不为空。该函数用于将kobject注册到内核中，如果kobject的kset字段已经被设置，则将这个kobject加入到那个kset中。函数最后调用create_dir函数创建kobject对应于sysfs中的文件夹，如果创建成功，则将state_in_sysfs设置为1。&lt;&#x2F;p&gt;
&lt;p&gt;随后来看create_dir函数，首先可以看到函数开头调用了kobject_namespace函数，从这里立即可以看出kobject是namespace-aware的。kboject_namespace的实现如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;kobject_namespace&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kobject *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kobj&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kobj_ns_type_operations *ns_ops = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kobj_ns_ops&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(kobj);

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(!ns_ops || ns_ops-&amp;gt;type == KOBJ_NS_TYPE_NONE)
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kobj-&amp;gt;ktype-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;namespace&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(kobj);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;也就是说，如果kset的kobj_type中的kobj_ns_type_operations-&amp;gt;type不为KOBJ_NS_TYPE_NONE（目前应该只有一个KOB_NS_TYPE_NET）的话就用kobject-&amp;gt;kobj_type中的namespace回调函数给出的namespace标签创建sysfs中对应的文件夹：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        error = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sysfs_create_dir_ns&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(kobj, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kobject_namespace&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(kobj));
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;并利用kobject-&amp;gt;kobj_type-&amp;gt;attributes中保存的属性创建文件夹中的文件，这里具体的实现需要参考sysfs文件系统的实现。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;kobject-get-path&quot;&gt;kobject_get_path&lt;&#x2F;h2&gt;
&lt;p&gt;很明显该函数返回该kobject的path，从代码中可以看出path是指在该kobject所在的树形结构中，从该kobject到树的根节点所经过的路径。函数实现比较简单，首先是遍历一遍树到根结点，计算出整个字符串所占用的空间。然后申请这个字符串，然后再次向上遍历树至根结点，依次从后向前填充每个kobject节点的名字，并以斜杠（“&#x2F;”）作为间隔。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;kobject-release&quot;&gt;kobject_release&lt;&#x2F;h2&gt;
&lt;p&gt;该函数将kobject所占用的系统资源删除。需要注意的是，这个函数并不仅仅释放kboject占用的内存，而是释放嵌入kobject的结构体占用的内存和系统资源。每个kobject的kobj_type-&amp;gt;release不能为NULL，否则kobject的无法在其以用计数为0时释放内存。然后函数首先检查state_add_uevent_sent是否为true，如果是则调用kobject_uevent发送其对应的REMOVE事件到用户态。如果state_in_sysfs为true，则表示该kobject还在sysfs中显示，需要调用kobject_del函数将其从树形结构中删除。最后调用release函数指针将被嵌入这个kobject的结构体删除，当然，不能忘记释放name占用的内存。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;kobject-create&quot;&gt;kobject_create&lt;&#x2F;h2&gt;
&lt;p&gt;该函数创建并初始化一个“动态”的kobject结构体对象。之所以说是动态的，是因为它们没有被嵌入到别的结构体中，而时独立存在的。所以kobject_create在创建kobject之后，给其了一个默认的release函数，即释放kobject本身所占用的内存。kobject_object创建的kobject对象是匿名的，且使用如下的kobj_type：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kobj_type dynamic_kobj_ktype = {
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;release        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= dynamic_kobj_release,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sysfs_ops      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &amp;amp;kobj_sysfs_ops,
};

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;dynamic_kobj_release&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kobject *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kobj&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pr_debug&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;kobject: (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%p&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;): &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, kobj, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;__func__&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kfree&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(kobj);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h1 id=&quot;uevent&quot;&gt;uevent&lt;&#x2F;h1&gt;
&lt;p&gt;uevent的实现可以在&lt;code&gt;lib&#x2F;kobject_uevent.c&lt;&#x2F;code&gt;文件中找到。我们首先注意到的是uevent依赖于网络子系统，如果内核没有开启CONFIG_NET选项，则uevent的很多功能都会受到影响。同时也能猜到uevent是namepsace-aware的，由于uevent依赖于netlink套接字向用户态发送uevent事件，所以每个net namespace都可以有自己独立的uevent事件。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ueventyu-netlink&quot;&gt;uevent与netlink&lt;&#x2F;h2&gt;
&lt;p&gt;uevent使用netlink套接字向用户态发送信息，而netlink是namespace-aware的，所以uevent的初始化必须对每个net namespace区分对待。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; pernet_operations uevent_net_ops = {
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;init   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= uevent_net_init,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;exit   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= uevent_net_exit,
};

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; __init &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;kobject_uevent_init&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;register_pernet_subsys&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;uevent_net_ops);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;register_pernet_subsys是注册net namespace初始化函数的标准方式，每当新的net namespace创建或者销毁的时候，这注册的函数指针就会执行。由于每个net namespace的netlink套接子都是相互独立的，uevent_net_init负责在每个net namepsace中注册对应的netlink套接字，并将其保存在一个列表中。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;uevent_sock {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; list_head list;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;sock *sk;
};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;LIST_HEAD&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(uevent_sock_list);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;ueventshi-jian-lei-xing&quot;&gt;uevent事件类型&lt;&#x2F;h2&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static const char &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*kobject_actions[] = {
        [KOBJ_ADD] =            &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;add&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
        [KOBJ_REMOVE] =         &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;remove&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
        [KOBJ_CHANGE] =         &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;change&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
        [KOBJ_MOVE] =           &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;move&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
        [KOBJ_ONLINE] =         &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;online&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
        [KOBJ_OFFLINE] =        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;offline&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
        [KOBJ_BIND] =           &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;bind&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
        [KOBJ_UNBIND] =         &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;unbind&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;TODO: 从内核设备框架中找到以上事件类型的具体含义和触发方式&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ueventshi-jian-de-chuang-jian&quot;&gt;uevent事件的创建&lt;&#x2F;h2&gt;
&lt;p&gt;uevent事件包括以下三个信息：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;DEVPATH，即设备路径。该设备路径采用前面提到的kobject_get_path函数创建。&lt;&#x2F;li&gt;
&lt;li&gt;ACTION，即uevent事件表示的行为，如设备增加，设备删除等等。&lt;&#x2F;li&gt;
&lt;li&gt;环境变量，类似于进程的环境变量，用于携带其他额外的信息。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;uevent事件的创建由kobject_uevent_env的前半段完成，这里所说的创建是指收集向用户态发送uevent事件所需的全部信息这一过程。前面提到DEVPATH是由kobject_get_path函数从kobject树中创建，而显然ACTION应该是触发uevent事件代码段传入的参数，所以我们只需要看看环境变量是如何生成的。&lt;&#x2F;p&gt;
&lt;p&gt;从代码中直接可以看到每个uevent事件默认携带四个环境变量：ACTION，DEVPATH，SEQNUM和SUBSYSTEM。前面三个顾名思义，SUBSYSTEM比较费解。简而言之，SUBSYSTEM变量是事件目标kobject从kobject树向根结点方向找到的第一个kset的名字。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        top_kobj = kobj;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(!top_kobj-&amp;gt;kset &amp;amp;&amp;amp; top_kobj-&amp;gt;parent)
                top_kobj = top_kobj-&amp;gt;parent;

        kset = top_kobj-&amp;gt;kset;
        uevent_ops = kset-&amp;gt;uevent_ops;

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(uevent_ops &amp;amp;&amp;amp; uevent_ops-&amp;gt;name)
                subsystem = uevent_ops-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(kset, kobj);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;                subsystem = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kobject_name&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;kset-&amp;gt;kobj);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;也就是说内核默认将kset当作一个子系统中看待，kset中可以包含kset，也就是子系统中可以包含另一个子系统。还有一点比较有意思的是内核使用一个单独的uevent_seqnum作为uevent事件的序列号，使用uevent_sock_mutex互斥锁保护这一变量，这告诉我们以下两点：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;从用户态的视角来看，uevent事件的序列号并不是每次都加一的。这是因为uevent是namespace-aware的，并不是所有namespace都会收到。很明显这里说的是net namespace，一个net namespace下的进程并不能看到其他net namespace下的网卡，更不应该收到对应的uevent事件。&lt;&#x2F;li&gt;
&lt;li&gt;kobject_uevent和kobject_uevent_env函数必须在进程上下文调用，因为其内部使用了mutex。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;除了标准的环境变量之外，kobject_uevent_env还接收一个env_ext参数作为其他额外的环境变量。除此之外，kset（也就是kobject所属的SUBSYSTEM）中注册的uevent_ops-&amp;gt;uevent回调函数也可以添加自己的环境变量。函数会去掉UNBIND事件中的MODALIAS变量。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ueventshi-jian-de-fa-song&quot;&gt;uevent事件的发送&lt;&#x2F;h2&gt;
&lt;p&gt;kobject_uevent_env前半段收集完所有所需信息之后，将发送工作交由kobject_uevent_net_broadcast进行。这里首先列举以下kobject_uevent_env中会阻止uevent事件发送的几种情况：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;前面提到的SUBSYSTEM变量没找到，也就是触发uevent事件的kobject没有包含在任何一个kset中，这种情况视为错误，并返回EINVAL。&lt;&#x2F;li&gt;
&lt;li&gt;kobject-&amp;gt;suppress为true，表示这个kobject不应该触发任何uevent事件。&lt;&#x2F;li&gt;
&lt;li&gt;kset中注册的uevent_ops-&amp;gt;filter函数过滤掉了该kobject。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;kobject_uevent_net_broadcast正如你想的一样，向除了kobject所在的net namespace发送uevent事件，如果kobject没有关联的net namespace，则向全体发送。netlink套接字所用的skb_buff按照如下方法构造：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;                        size_t len = strlen(action_string) + strlen(devpath) + 2;
                        char *scratch;

                        skb = alloc_skb(len + env-&amp;gt;buflen, GFP_KERNEL);

                        scratch = skb_put(skb, len);
                        sprintf(scratch, &amp;quot;%s@%s&amp;quot;, action_string, devpath);

                        skb_put_data(skb, env-&amp;gt;buf, env-&amp;gt;buflen);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;因此，用户态收到的数据为如下形式：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;ACTION@DEVPATH\0
ENV1=VALUE2\0
ENV2=VALUE2\0
......
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;</content>
	</entry>
	<entry xml:lang="en">
		<title>USB Hub驱动分析</title>
		<published>2018-02-27T00:00:00+00:00</published>
		<updated>2018-02-27T00:00:00+00:00</updated>
		<link href="https://crab2313.github.io/usb-hub/" type="text/html"/>
		<id>https://crab2313.github.io/usb-hub/</id>
		<content type="html">&lt;h1 id=&quot;usb-hubkuang-jia-fen-xi&quot;&gt;USB hub框架分析&lt;&#x2F;h1&gt;
&lt;p&gt;USB hub框架是usbcore模块里的一个大头5000行代码（5分之一）。同时，USB hub本身在USB协议中又是一个非常重要的组成部分，直接关系到USB的核心功能。理解USB hub框架对于理解usbcore模块至关重要。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;chu-shi-hua&quot;&gt;初始化&lt;&#x2F;h2&gt;
&lt;p&gt;USB hub框架随着USB子系统一起初始化，usb_init函数中直接调用usb_hub_init函数。usb_hub_init函数中只进行了两件事：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;注册hub_driver&lt;&#x2F;li&gt;
&lt;li&gt;申请一个名为hub_wq的workqueue&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;与usb_hub_init函数对应的usb_hub_cleanup函数做了相反的事情。在USB协议中，USB hub也是一个USB设备，也提供了所有USB设备都会提供的通用请求，除此之外也提供了Hub特定的请求。因此，自然而然应该将Hub看作普通USB设备，并提供对应的USB驱动，这样做可以简化实现。可以看到内核中也是这么做的：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; usb_driver hub_driver = {
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;=         &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;hub&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;probe &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;=        hub_probe,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;disconnect &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;=   hub_disconnect,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;suspend &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;=      hub_suspend,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;resume &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;=       hub_resume,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;reset_resume &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= hub_reset_resume,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pre_reset &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;=    hub_pre_reset,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;post_reset &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;=   hub_post_reset,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;unlocked_ioctl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= hub_ioctl,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;id_table &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;=     hub_id_table,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;supports_autosuspend &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;hub_id_table中匹配了bDeviceClass或者bInterfaceClass为USB_CLASS_HUB的设备或者接口。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hub-irq&quot;&gt;hub_irq&lt;&#x2F;h2&gt;
&lt;p&gt;前面提到Hub初始化之后会激活对Status Change Endpoint的轮询操作，为此usb_hub-&amp;gt;urb指针保存了一个Interrupt类型的URB，并将其处理函数设置为hub_irq。也就是说，hub_irq函数的作用是处理该轮询结果。从协议中可以得知，每次轮询成功时返回的数据是一个记录着Hub及Hub上的所有Port状态改变的Bitmap。hub_irq的实现比较简单，主要流程如下：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;每次出现错误状态时增加错误计数器usb_hub-&amp;gt;nerror。计数器超过10之后，设置usb_hub-&amp;gt;error，清零错误计数器，并调用kick_hub_wq。&lt;&#x2F;li&gt;
&lt;li&gt;如果没有错误，则清零错误计数器，然后调用kick_hub_wq&lt;&#x2F;li&gt;
&lt;li&gt;如果usb_hub-&amp;gt;quiescing不为真，则重新提交该URB&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;事实上一旦usb_hub-&amp;gt;error不为0，则kick_hub_wq后续触发的hub_event函数中会对该Hub进行重置操作。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hub-event&quot;&gt;hub_event&lt;&#x2F;h2&gt;
&lt;p&gt;旧的内核中使用一个内核线程轮询读取Hub的状态，而新的内核中换成了前面提到的名为hub_wq的workqueue，该workqueue在USB子系统初始化的时候创建。内核使用hub_event函数轮询Hub的状态，为了向该函数传入参数，每个usb_hub结构体内都嵌入了work_struct（名为events），通过container_of获取对应的usb_hub。&lt;&#x2F;p&gt;
&lt;p&gt;该函数在做完简单的错误处理之后开始枚举PORT状态，枚举机制可以参考USB2.0协议文档中的11.12.3章节。简而言之，驱动程序在轮询Hub的Status Change Endpoint过程中，如果获取到有状态更新事件，那么就会调用kick_hub_wq函数将usb_hub-&amp;gt;events加入到hub_wq中。同一时刻只有一个usb_hub的events能放到hub_wq中，这跟Hub设备的事件通知机制有关，驱动在获取到Hub的事件更新之后，必须手动清除掉一个事件的状态更改位，已使Hub设备不再报告相同的事件。也就是说，没有处理完的事件在下次轮询的时候依然存在。&lt;&#x2F;p&gt;
&lt;p&gt;很显然根据Hub的规范，hub_event函数需要做的就是从Default Control Pipe中调用对应的请求获取Hub或者Port的状态信息，并清除对应的状态位。函数中当然不可能轮询所有的Port和Hub状态，这样做效率太低。事实上，每次轮询Status Change的时候，返回的数据是一个Bitmap，其中第0位置1表示Hub本生状态发生了改变，而后续的第n位置1表示第n个Port的状态发生了改变。如果你阅读Hub规范，则会发现hub_event函数承担的责任并仅仅是处理硬件状态的改变，还包括处理软件状态的改变（即软件控制信息的处理）。也就是说，如果内核需要更改Hub的状态，则会修改usb_hub中的状态，并调用kick_hub_wq函数。&lt;&#x2F;p&gt;
&lt;p&gt;从hub_irq函数中可以看到，内核将前面提到的Bitmap保存在usb_hub-&amp;gt;event_bits中，并调用kick_hub_wq。因此，hub_event函数可以通过这个bitmap来判断是否有硬件事件的发生。hub_event中调用port_event处理Port事件：如果一个Port的change_bits、event_bits、wakeup_bits中的对应位任意一位置一，则需要进行处理。port_event函数开头先清除了event_bits和wakeup_bits，看样子这两个标志仅仅起通知的作用。change_bits则被保存了下来，内核通过这一标志表示逻辑连接状态的改变。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        connect_change = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;test_bit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(port1, hub-&amp;gt;change_bits);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;clear_bit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(port1, hub-&amp;gt;event_bits);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;clear_bit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(port1, hub-&amp;gt;wakeup_bits);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;随后函数从Default Control Pipe读取Port相关的信息并进行处理。可以发现内核对大部分信息仅仅是作为调试信息记录下来，然后将其清除掉，已使下一次轮询时不再获取该信息，真正进行处理的信息不多。首先处理的是USB_PORT_STAT_C_CONNECTION，从名字上看得出是连接状态的改变，因此如果这个标志被发现的话意味着物理连接状态的改变，需要将connect_change直接置一。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(portchange &amp;amp; USB_PORT_STAT_C_CONNECTION) {
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;usb_clear_port_feature&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(hdev, port1, USB_PORT_FEAT_C_CONNECTION);
                connect_change = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
        }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其次就是处理远程唤醒和USB3.0的重置操作。最后如果connect_change为1的话（即Port的逻辑或者物理连接状态改变）则调用hub_port_connect_change函数进行处理。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>inode权限检查</title>
		<published>2018-01-07T00:00:00+00:00</published>
		<updated>2018-01-07T00:00:00+00:00</updated>
		<link href="https://crab2313.github.io/inode-permission/" type="text/html"/>
		<id>https://crab2313.github.io/inode-permission/</id>
		<content type="html">&lt;h1 id=&quot;inode-permissionhan-shu&quot;&gt;inode_permission函数&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;code&gt;inode_permission&lt;&#x2F;code&gt;函数用于对inode进行权限检查，我们传给其一个mask参数，这个参数是一个bitmap，主要有三个标志：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;MAY_READ：inode是否可读&lt;&#x2F;li&gt;
&lt;li&gt;MAY_WRITE：inode是否可写&lt;&#x2F;li&gt;
&lt;li&gt;MAY_EXEC：inode是否可执行（对于文件夹来说意味着是否可以访问文件夹下的文件或文件夹）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;如果该函数的返回值为0，说明检查通过。&lt;code&gt;inode_permission&lt;&#x2F;code&gt;所做的检查主要分为两个部分：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;文件系统级别检查&lt;&#x2F;li&gt;
&lt;li&gt;inode级别检查&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;文件系统级别检查主要是检查文件系统一级的权限，这里只考虑一种情况：文件系统只读，代码如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;unlikely&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(mask &amp;amp; MAY_WRITE)) {
                umode_t mode = inode-&amp;gt;i_mode;

                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Nobody gets write access to a read-only fs. *&#x2F;
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;((sb-&amp;gt;s_flags &amp;amp; MS_RDONLY) &amp;amp;&amp;amp;
                    (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;S_ISREG&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(mode) || &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;S_ISDIR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(mode) || &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;S_ISLNK&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(mode)))
                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;-EROFS;
        }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;也就是说，如果文件系统只读，并且该inode的类型是普通文件、文件夹、链接，那么这个inode是不可写的，注意这里设备文件不受影响。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;inode-permissionhan-shu-1&quot;&gt;__inode_permission函数&lt;&#x2F;h1&gt;
&lt;p&gt;inode级别的检查由&lt;code&gt;__inode_permission&lt;&#x2F;code&gt;函数进行，这个函数首先确保两个情况下inode不能写入：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;inode的标志inode-&amp;gt;i_flags中存在&lt;code&gt;S_IMMUTABLE&lt;&#x2F;code&gt;标志&lt;&#x2F;li&gt;
&lt;li&gt;inode的&lt;code&gt;i_uid&lt;&#x2F;code&gt;或者&lt;code&gt;i_gid&lt;&#x2F;code&gt;非法，这会使得更新mtime的时候将错误的信息写回去。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;接下来通过三个不同的函数检查权限：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;do_inode_permission&lt;&#x2F;li&gt;
&lt;li&gt;devcgroup_inode_permission&lt;&#x2F;li&gt;
&lt;li&gt;security_inode_permission&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;devcgroup_inode_permission涉及到了cgroup子系统，security_inode_permission涉及到LSM子系统，这里不多讲。来看&lt;code&gt;do_inode_permission&lt;&#x2F;code&gt;函数，这个函数首先检查inode-&amp;gt;op是否有.permission函数指针，如果有，直接调用这个函数指针，如果没有则调用通用的检查函数&lt;code&gt;generic_permission&lt;&#x2F;code&gt;。事实上这段代码被运行的频率非常高，需要重点优化，所以使用inode-&amp;gt;i_opflags中的一个&lt;code&gt;IOP_FASTPERM&lt;&#x2F;code&gt;标志表明i_op-&amp;gt;permission是否为NULL，这个缓存使得下次操作不用再次检查。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static inline int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;do_inode_permission&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; inode *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;inode&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;mask&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;unlikely&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(!(inode-&amp;gt;i_opflags &amp;amp; IOP_FASTPERM))) {
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;likely&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(inode-&amp;gt;i_op-&amp;gt;permission))
                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; inode-&amp;gt;i_op-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;permission&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(inode, mask);

                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* This gets set once for the inode lifetime *&#x2F;
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spin_lock&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;inode-&amp;gt;i_lock);
                inode-&amp;gt;i_opflags |= IOP_FASTPERM;
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spin_unlock&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;inode-&amp;gt;i_lock);
        }
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;generic_permission&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(inode, mask);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h1 id=&quot;generic-permissionhan-shu&quot;&gt;generic_permission函数&lt;&#x2F;h1&gt;
&lt;p&gt;只要inode没有单独实现自己的inode-&amp;gt;op-&amp;gt;permission操作，那么就会使用默认&lt;code&gt;generic_permission&lt;&#x2F;code&gt;进行权限检查。这个函数首先调用&lt;code&gt;acl_permission_check&lt;&#x2F;code&gt;进行基本的权限检查，然后处理capabilities。&lt;code&gt;acl_permission_check&lt;&#x2F;code&gt;主要做了如下检查：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;如果fsuid与inode-&amp;gt;i_uid相同，那么直接比较inode-&amp;gt;i_mode中与user相关三位和mask是否匹配&lt;&#x2F;li&gt;
&lt;li&gt;如果fsuid与inode-&amp;gt;i_uid不相同，并且inode所在的文件系统支持POSIX_ACL，那么检查POSIX_ACL，如果检索有结果（无论是允许还是阻止），都会直接返回该结果&lt;&#x2F;li&gt;
&lt;li&gt;如果fsuid与inode-&amp;gt;i_uid不相同，并且POSIX_ACL没有检索结果（包括inode所在文件系统不支持POSIX ACL的情况），但是当前进程属于inode-&amp;gt;i_gid代表的group，那么比较inode-&amp;gt;i_mode中与group相关的三位和mask是否匹配&lt;&#x2F;li&gt;
&lt;li&gt;上述条件都不满足的情况下，比较inode-&amp;gt;i_mode中与other相关的三位和mask是否匹配&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;当&lt;code&gt;acl_permission_check&lt;&#x2F;code&gt;认定当前进程没有权限对inode进行由mask代表的操作时，&lt;code&gt;generic_permission&lt;&#x2F;code&gt;才会继续进行capabilities的检查。涉及到inode权限的capabilities有两个：CAP_DAC_OVERRIDE和CAP_DAC_READ_SEARCH。CAP_DAC_OVERRIDE可以让进程（几乎）无视文件设置的三组权限位，而CAP_DAC_READ_SEARCH赋予进程搜索文件夹和读取文件的权限。由于文件夹的三组权限位与普通文件表示的意义是不一样的，所以这两个capability的行为也是不同的。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;S_ISDIR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(inode-&amp;gt;i_mode)) {
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* DACs are overridable for directories *&#x2F;
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;capable_wrt_inode_uidgid&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(inode, CAP_DAC_OVERRIDE))
                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(!(mask &amp;amp; MAY_WRITE))
                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;capable_wrt_inode_uidgid&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(inode,
                                                     CAP_DAC_READ_SEARCH)
)
                                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;-EACCES;
        }
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;*
         * Read&#x2F;write DACs are always overridable.
         * Executable DACs are overridable when there is
         * at least one exec bit set.
         *&#x2F;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(!(mask &amp;amp; MAY_EXEC) || (inode-&amp;gt;i_mode &amp;amp; S_IXUGO))
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;capable_wrt_inode_uidgid&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(inode, CAP_DAC_OVERRIDE))
                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;*
         * Searching includes executable on directories, else just read.
         *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        mask &amp;amp;= MAY_READ | MAY_WRITE | MAY_EXEC;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(mask == MAY_READ)
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;capable_wrt_inode_uidgid&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(inode, CAP_DAC_READ_SEARCH))
                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;对于文件夹：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;CAP_DAC_OVERRIDE直接pass&lt;&#x2F;li&gt;
&lt;li&gt;CAP_DAC_READ_SEARCH允许MAY_READ和MAY_EXEC&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;对于普通文件：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;CAP_DAC_OVERRIDE对待MAY_EXEC是不同的：如果mask中出现了MAY_EXEC，那么只有三组权限位中至少有一个X位被设置的时候才pass，其余情况全pass。&lt;&#x2F;li&gt;
&lt;li&gt;CAP_DAC_READ_SEARCH只允许MAY_READ&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>eventfd在内核中的实现</title>
		<published>2017-12-19T00:00:00+00:00</published>
		<updated>2017-12-19T00:00:00+00:00</updated>
		<link href="https://crab2313.github.io/eventfd/" type="text/html"/>
		<id>https://crab2313.github.io/eventfd/</id>
		<content type="html">&lt;p&gt;eventfd是一个利用匿名文件描述符实现“等待&#x2F;通知”通信机制的一种方式。它比较方便的一点是，eventfd不仅可以实现用户态与用户态之间的通信，也可以实现内核与用户态的通信。eventfd的实现比较简单易懂，主要在以下两个文件中：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;include&#x2F;linux&#x2F;eventfd.h&lt;&#x2F;li&gt;
&lt;li&gt;fs&#x2F;eventfd.c&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;而关于eventfd的详细说明可以参考man-pages：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;man eventfd
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;由于eventfd的实现很简短（只有500行左右），下面详细地分析在内核中的实现。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;zai-nei-he-zhong-de-biao-shi&quot;&gt;在内核中的表示&lt;&#x2F;h1&gt;
&lt;p&gt;很明显，eventfd需要一个保存特定的状态，内核使用eventfd_ctx来保存一个eventfd的状态信息。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;eventfd_ctx {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; kref kref;
        wait_queue_head_t wqh;
        __u64 count;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; flags;
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到内核使用了一个kref来作为引用计数。使用一个64位的count字段来保存eventfd的内部计数器，使用flags字段保存eventfd的标志位。作为一个“等待&#x2F;通知”机制，等待和唤醒操作是必不可少的，内核中实现这个操作的标准方式是用一个waitqueue，即wqh字段。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;yong-hu-tai-jie-kou&quot;&gt;用户态接口&lt;&#x2F;h1&gt;
&lt;p&gt;从man-pages中可以了解到，内核中提供了两个系统调用：eventfd和eventfd2。当eventfd2存在时，glibc默认使用eventfd2系统调用。这两个系统调用的区别是，eventfd2允许传入flags参数，而eventfd系统调用强制设置flags为0。在&lt;code&gt;fs&#x2F;eventfd.c&lt;&#x2F;code&gt;文件的末尾，我们可以找到这两个系统调用。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;SYSCALL_DEFINE2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(eventfd2, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, count, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, flags)
{        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; fd, error;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; file *file;
        error = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;get_unused_fd_flags&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(flags &amp;amp; EFD_SHARED_FCNTL_FLAGS);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(error &amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; error;
        fd = error;
        file = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eventfd_file_create&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(count, flags);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;IS_ERR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(file)) {
                error = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;PTR_ERR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(file);
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;goto&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; err_put_unused_fd;
        }
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;fd_install&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(fd, file);

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; fd;

err_put_unused_fd:
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;put_unused_fd&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(fd);

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; error;
}

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;SYSCALL_DEFINE1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(eventfd, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, count)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sys_eventfd2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(count, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;简单观察可以发现eventfd是eventfd2的简单包装（将flags设置为0），所以我们集中分析eventfd2做了什么。首先调用&lt;code&gt;get_unused_fd_flags&lt;&#x2F;code&gt;在当前进程中找来一个未使用的文件描述符并返回，同时设置其标志位。可以从eventfd.h文件中发现，&lt;code&gt;EFD_SHARED_FCNTL_FLAGS&lt;&#x2F;code&gt;实际上的定义如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;EFD_CLOEXEC			O_CLOEXEC
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;EFD_NONBLOCK                    O_NONBLOCK
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;EFD_SHARED_FCNTL_FLAGS		(O_NONBLOCK | O_CLOEXEC)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;也就是说，eventfd的&lt;code&gt;EFD_NONBLOCK&lt;&#x2F;code&gt;和&lt;code&gt;EFD_CLOEXEC&lt;&#x2F;code&gt;与fcntl对应的&lt;code&gt;O_*&lt;&#x2F;code&gt;标志位是公用的。然后eventfd2系统调用又调用了&lt;code&gt;eventfd_file_create&lt;&#x2F;code&gt;创建了struct file结构体，最后使用fd_install函数将这个struct file结构体关联到当前的任务中。最后所有的问题都集中到了&lt;code&gt;eventfd_file_create&lt;&#x2F;code&gt;函数中，忽略掉一些sanity check，可以在&lt;code&gt;eventfd_file_create&lt;&#x2F;code&gt;函数中看到以下代码：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; file *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;eventfd_file_create&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;count&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;flags&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; file *file;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; eventfd_ctx *ctx;
        ......
        ctx = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kmalloc&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(sizeof(*ctx), GFP_KERNEL);
        ......
        file = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;anon_inode_getfile&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;[eventfd]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, &amp;amp;eventfd_fops, ctx,
                                  O_RDWR | (flags &amp;amp; EFD_SHARED_FCNTL_FLAGS));
        ......
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; file;
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;即使用了比较常见的&lt;code&gt;anon_inode_getfile&lt;&#x2F;code&gt;函数创建了一个匿名的inode，打开这个inode得到struct file结构体，对应的fops为eventfd_fops。接下来分析这VFT中注册的回调函数的行为。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;eventfdde-hui-diao-han-shu&quot;&gt;eventfd的回调函数&lt;&#x2F;h1&gt;
&lt;p&gt;紧接上一节，我们得到了一个名为&lt;code&gt;eventfd_fops&lt;&#x2F;code&gt;的&lt;code&gt;file_operations&lt;&#x2F;code&gt;，如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static const struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; file_operations eventfd_fops = {

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#ifdef&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; CONFIG_PROC_FS
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;show_fdinfo    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= eventfd_show_fdinfo,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#endif
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;release        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= eventfd_release,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;poll           &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= eventfd_poll,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;read           &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= eventfd_read,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;write          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= eventfd_write,
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;llseek         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= noop_llseek,
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;.llseek是一个空的占位函数，可以不去理会。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;release&quot;&gt;release&lt;&#x2F;h1&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;eventfd_ctx_put&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; eventfd_ctx *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ctx&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kref_put&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;ctx-&amp;gt;kref, eventfd_free);
}

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;eventfd_release&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; inode *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;inode&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; file *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;file&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; eventfd_ctx *ctx = file-&amp;gt;private_data;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;wake_up_poll&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;ctx-&amp;gt;wqh, POLLHUP);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eventfd_ctx_put&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(ctx);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;还是比较好懂的，首先使用POLLHUP作为key调用&lt;code&gt;wake_up_poll&lt;&#x2F;code&gt;唤醒waitqueue，然后将&lt;code&gt;eventfd_ctx&lt;&#x2F;code&gt;的引用计数减一。如果引用计数为0，那么就调用kfree直接释放掉&lt;code&gt;eventfd_ctx&lt;&#x2F;code&gt;占用的内存。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;du-qu-cao-zuo&quot;&gt;读取操作&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;code&gt;eventfd_read&lt;&#x2F;code&gt;回调函数中并没有做太多事情，简单的检查了参数之后，就将所有工作委托给了&lt;code&gt;eventfd_ctx_read&lt;&#x2F;code&gt;函数。现在先描述一下这个函数的行为，然后解释它的实现细节。&lt;&#x2F;p&gt;
&lt;p&gt;函数首先根据传进来的no_wait参数确定是否应该做阻塞操作，阻塞停止的判断标准是&lt;code&gt;ctx-&amp;gt;count &amp;gt; 0&lt;&#x2F;code&gt;，也就是如果eventfd内部的计数器为大于0的话，就会停止阻塞。随后函数调用&lt;code&gt;eventfd_ctx_do_read&lt;&#x2F;code&gt;更新eventfd计数器的值，并根据ctx-&amp;gt;wqh是否正常工作以POLLOUT为参数调用&lt;code&gt;wake_up_locked_poll&lt;&#x2F;code&gt;函数通知还在ctx-&amp;gt;wqh上做poll操作的任务。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;eventfd_ctx_do_read&lt;&#x2F;code&gt;的行为比较简单：如果ctx-&amp;gt;flags中有EFD_SEMAPHORE标志，那么就将ctx-&amp;gt;count减去1，否则就清零。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;eventfd_ctx_do_read&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; eventfd_ctx *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ctx&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, __u64 *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cnt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        *cnt = (ctx-&amp;gt;flags &amp;amp; EFD_SEMAPHORE) ? &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: ctx-&amp;gt;count;
        ctx-&amp;gt;count -= *cnt;
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到&lt;code&gt;eventfd_ctx&lt;&#x2F;code&gt;中没有自己的锁，所以它用的是wqh.lock这个spinlock，这个spinlock是与waitqueue共用的，所以&lt;code&gt;eventfd_ops.poll&lt;&#x2F;code&gt;操作的实现需要考虑很多data race出现的情况。为了实现等待操作，函数首先将自身任务放入ctx-&amp;gt;wqh中，然后进入一个死循环，在循环开始将自身运行状态设置为&lt;code&gt;TASK_INTERRUPTIBLE&lt;&#x2F;code&gt;，这标志着任务进入等待状态，并可以接收信号。接下来检查ctx-&amp;gt;count是否大于0，如果是则宣告等待结束。最后检测当前任务是否有到来的信号，如果有，那么此次等待操作失败，返回-ERESTARTSYS，文件系统层会重新进行此次操作。注意我们是不能拿着spinlock做上下文切换的，所以调用schedule前应该要把spinlock放回去，在schedule返回的时候再重新持有spinlock。死循环结束时，将当前任务从ctx-&amp;gt;wqh中移除，并重置当前运行状态为TASK_RUNNING。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;xie-ru-cao-zuo&quot;&gt;写入操作&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;code&gt;eventfd_write&lt;&#x2F;code&gt;的实现和&lt;code&gt;eventfd_read&lt;&#x2F;code&gt;非常相似，没有什么需要过多解释的细节。&lt;code&gt;ctx-&amp;gt;count&lt;&#x2F;code&gt;可以保存的最大值是0xfffffffffffffffe即&lt;code&gt;UULONG_MAX-1&lt;&#x2F;code&gt;，每次&lt;code&gt;eventfd_write&lt;&#x2F;code&gt;操作会增加&lt;code&gt;ctx-&amp;gt;count&lt;&#x2F;code&gt;的值，如果ctx-&amp;gt;count的值增加之后会超过&lt;code&gt;UULONG_MAX-1&lt;&#x2F;code&gt;那么&lt;code&gt;eventfd_write&lt;&#x2F;code&gt;会根据&lt;code&gt;O_NONBLOCK&lt;&#x2F;code&gt;是否设置决定是阻塞等待还是直接返回&lt;code&gt;-EAGAIN&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;pollcao-zuo&quot;&gt;POLL操作&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;code&gt;eventfd_poll&lt;&#x2F;code&gt;函数看起来是最短最简单的一个，其实是最复杂的一个。前面提到，&lt;code&gt;eventfd_ctx&lt;&#x2F;code&gt;直接将&lt;code&gt;ctx-&amp;gt;wqh.lock&lt;&#x2F;code&gt;当作自己的锁，这与poll操作是冲突的，因为&lt;code&gt;poll_wait函数&lt;&#x2F;code&gt;会先获取&lt;code&gt;ctx-&amp;gt;wqh.lock&lt;&#x2F;code&gt;。为了保证函数功能正确，必须考虑所有情况。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static unsigned int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;eventfd_poll&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; file *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;file&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, poll_table *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;wait&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; eventfd_ctx *ctx = file-&amp;gt;private_data;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; events = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
        u64 count;

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;poll_wait&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(file, &amp;amp;ctx-&amp;gt;wqh, wait);
        count = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;READ_ONCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(ctx-&amp;gt;count);

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(count &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
                events |= POLLIN;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(count == ULLONG_MAX)
                events |= POLLERR;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(ULLONG_MAX - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt; count)
                events |= POLLOUT;

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; events;
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;首先可以确定的是，&lt;code&gt;eventfd_poll&lt;&#x2F;code&gt;不能像read和write那样在开头获取&lt;code&gt;ctx-&amp;gt;wqh.lock&lt;&#x2F;code&gt;。原因前面提到了，&lt;code&gt;poll_wait&lt;&#x2F;code&gt;里面调用了&lt;code&gt;add_wait_queue&lt;&#x2F;code&gt;，也会去拿这个spinlock。在已经持有锁的情况下再去获取这个锁，就会造成死锁。从代码中可以看到，从&lt;code&gt;poll_wait&lt;&#x2F;code&gt;以下的代码是没有锁保护的，这就需要确定所有情况保证代码不出现竞争。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;READ_ONCE&lt;&#x2F;code&gt;是一个特殊的宏，可以保证对&lt;code&gt;ctx-&amp;gt;count&lt;&#x2F;code&gt;的读取有且只有一次。由于指令重排的作用，这一行：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        count = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;READ_ONCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(ctx-&amp;gt;count);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可能会向上移动到&lt;code&gt;poll_wait&lt;&#x2F;code&gt;中的&lt;code&gt;add_wait_queue&lt;&#x2F;code&gt;的临界区里，但是不会移动到临界区之上。这是因为spinlock在ACCQUIRE操作时的语义隐含：所有在持有操作之后的内存操作都会在持有操作之后完成。翻译成白话就是在获取spinlock之后做的内存操作都不会重排到获取spinlock操作之前。可能出现的竞争为：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;         *     poll                               write
         *     -----------------                  ------------
         *     lock ctx-&amp;gt;wqh.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lock &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(in poll_wait)
         *     count = ctx-&amp;gt;count
         *     __add_wait_queue
         *     unlock ctx-&amp;gt;wqh.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lock
         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*                                        lock ctx-&amp;gt;qwh.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lock
         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*                                        ctx-&amp;gt;count += n
         *                                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(waitqueue_active)
         *                                          wake_up_locked_poll
         *                                        unlock ctx-&amp;gt;qwh.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lock
         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*     eventfd_poll returns &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个是安全的，因为write的&lt;code&gt;wake_up_locked_poll&lt;&#x2F;code&gt;函数还会把在poll的任务唤醒一次。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;nei-he-tong-zhi-ji-zhi&quot;&gt;内核通知机制&lt;&#x2F;h1&gt;
&lt;p&gt;内核可以使用&lt;code&gt;eventfd_signal&lt;&#x2F;code&gt;函数从内核一侧实现write操作，可以使用&lt;code&gt;eventfd_etx_remove_wait_queue&lt;&#x2F;code&gt;实现内核端的read操作，代码比较简单：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__u64 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;eventfd_signal&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; eventfd_ctx *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ctx&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, __u64 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; flags;

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spin_lock_irqsave&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;ctx-&amp;gt;wqh.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lock&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, flags);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(ULLONG_MAX - ctx-&amp;gt;count &amp;lt; n)
                n = ULLONG_MAX - ctx-&amp;gt;count;
        ctx-&amp;gt;count += n;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;waitqueue_active&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;ctx-&amp;gt;wqh))
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;wake_up_locked_poll&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;ctx-&amp;gt;wqh, POLLIN);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spin_unlock_irqrestore&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;ctx-&amp;gt;wqh.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lock&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, flags);

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; n;
}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;eventfd_ctx_remove_wait_queue&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; eventfd_ctx *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ctx&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, wait_queue_t *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;wait&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
                                  __u64 *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cnt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; flags;

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spin_lock_irqsave&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;ctx-&amp;gt;wqh.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lock&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, flags);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eventfd_ctx_do_read&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(ctx, cnt);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__remove_wait_queue&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;ctx-&amp;gt;wqh, wait);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*cnt != &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;waitqueue_active&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;ctx-&amp;gt;wqh))
                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;wake_up_locked_poll&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;ctx-&amp;gt;wqh, POLLOUT);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;spin_unlock_irqrestore&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;ctx-&amp;gt;wqh.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lock&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, flags);

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*cnt != &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;? &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: -EAGAIN;
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;</content>
	</entry>
</feed>
