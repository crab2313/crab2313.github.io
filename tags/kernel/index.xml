<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>kernel on crab2313's blog</title><link>/tags/kernel/</link><description>Recent content in kernel on crab2313's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 11 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="/tags/kernel/index.xml" rel="self" type="application/rss+xml"/><item><title>DRM框架分析（五）：任务调度</title><link>/post/drm-scheduler/</link><pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate><guid>/post/drm-scheduler/</guid><description>本文分析的这个DRM调度器实际上是在2018年左右由AMD的部分代码演变出来的，即由AMD私用变成DRM子系统共用的了。目前有三四个驱动使用</description></item><item><title>Linux在RISC-V平台下的模块实现</title><link>/post/kernel-module/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate><guid>/post/kernel-module/</guid><description>因为上次碰到了模块ABI改变导致的模块加载异常问题，虽然通过分析发现了问题，也认为解决方法是模块跟着ABI走，重新编译，但是认为模块的实现还</description></item><item><title>Linux内核在RISC-V平台下的static key机制</title><link>/post/static-key/</link><pubDate>Wed, 09 Jun 2021 00:00:00 +0000</pubDate><guid>/post/static-key/</guid><description>这两天在邮件列表中看到了使用static key对内核hot path进行优化的补丁，突然有了兴趣看看内核的底层实现。原理不多说，很容易懂，细节</description></item><item><title>Linux内核在RISC-V架构下的spinlock实现</title><link>/post/riscv-spinlock/</link><pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate><guid>/post/riscv-spinlock/</guid><description>本文分析linux内核下对于spinlock的实现，具体到RISC-V体系结构。由于RISC-V体系结构下目前只是简单的实现了一个基于TAS</description></item><item><title>Linux内核中ARP协议的实现</title><link>/post/arp/</link><pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate><guid>/post/arp/</guid><description>本文对内核中ARP协议相关的事件进行分析。本文是原先分析文档的整理，后续会进行相应复习与补足。 初始化 1 2 3 4 5 6 7 8 9 10 11 void __init arp_init(void) { neigh_table_init(NEIGH_ARP_TABLE, &amp;amp;arp_tbl); dev_add_pack(&amp;amp;arp_packet_type); arp_proc_init(); #ifdef</description></item><item><title>DRM框架分析（四）：Atomic KMS</title><link>/post/drm-atomic-kms/</link><pubDate>Wed, 31 Mar 2021 00:00:00 +0000</pubDate><guid>/post/drm-atomic-kms/</guid><description>首先Atomic Mode Setting（后续简称A-KMS）是DRM子系统最近的一次比较大的改动，其目的是填补当前API的不足。由于原先的API不</description></item><item><title>DRM框架分析（三）：显存管理</title><link>/post/drm-vram/</link><pubDate>Sun, 28 Mar 2021 00:00:00 +0000</pubDate><guid>/post/drm-vram/</guid><description>GEM GEM与TTM之间的关系 TTM是内核最初的DRM显存管理器，其设计思想是试图为所有的显卡驱动提供一个公共的API。TTM后面被认为是失败的</description></item><item><title>DRM框架分析（一）：简介</title><link>/post/drm-intro/</link><pubDate>Sun, 28 Mar 2021 00:00:00 +0000</pubDate><guid>/post/drm-intro/</guid><description>真的没有想到真的有人能看到这篇东西，所以我准备抽出时间把这个东西整理完。本文是我阅读内核DRM子系统的一些随笔，其目的是记录我对内核代码的阅</description></item><item><title>DRM框架分析（二）：KMS</title><link>/post/drm-legacy-kms/</link><pubDate>Fri, 26 Mar 2021 00:00:00 +0000</pubDate><guid>/post/drm-legacy-kms/</guid><description>KMS全称是Kernel Mode Setting，这里的mode是指显示控制器的mode，详见下面对drm_mode的分析。与KMS相对应的是Use</description></item><item><title>Linux内核组播包接收流程分析</title><link>/post/multicast/</link><pubDate>Mon, 08 Mar 2021 00:00:00 +0000</pubDate><guid>/post/multicast/</guid><description>本文直接分析组播接收的流程细节。由于工作需要，暂且分析2.6.32内核的相关细节，并将分析文档记录于此。 驱动层 TCP/IP协议栈是典型的ti</description></item><item><title>Linux内核在RISC-V架构下的内存屏障与原子操作</title><link>/post/riscv-atomic-barrier-bitops/</link><pubDate>Fri, 14 Aug 2020 00:00:00 +0000</pubDate><guid>/post/riscv-atomic-barrier-bitops/</guid><description>内存一致性模型是一个体系结构中至关重要的一部分，本质上为软件与硬件之间的契约。软件开发人员可以从内存一致性模型中得知硬件进行内存操作时可能的</description></item><item><title>Linux内核在RISC-V架构下的setup_arch与异常处理</title><link>/post/riscv-setup-arch-exception/</link><pubDate>Wed, 05 Aug 2020 00:00:00 +0000</pubDate><guid>/post/riscv-setup-arch-exception/</guid><description>在分析完Linux内核在RISC-V架构下的启动流程后，我们分析Linux下与RISC-V相关的架构相关实现。很明显，这类知识都是非常零散的</description></item><item><title>Linux内核在RISC-V架构下的构建与启动</title><link>/post/riscv-build-and-boot/</link><pubDate>Sat, 25 Jul 2020 00:00:00 +0000</pubDate><guid>/post/riscv-build-and-boot/</guid><description>本文分析RISC-V的linux移植是如何完成的，并给出具体的入手方法，希望对后来者有所启发。RISC-V是一个比较新的体系结构，截至目前已</description></item><item><title>TTM内存分配器分析</title><link>/post/ttm/</link><pubDate>Sun, 26 Apr 2020 00:00:00 +0000</pubDate><guid>/post/ttm/</guid><description>TTM 本文结合QXL内的实现分析内核DRM框架中提供的TTM内存管理器。 BO BO是Buffer Object的缩写，与Buffer是有区别的。个人理</description></item><item><title>SMMU内核驱动分析</title><link>/post/smmu/</link><pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate><guid>/post/smmu/</guid><description>IOMMU核心框架层 IOMMU核心框架是管理IOMMU设备的一个通用框架，IOMMU设备通过实现特定的回调函数并将自身注册到IOMMU核心框</description></item><item><title>PCI驱动框架分析</title><link>/post/pci/</link><pubDate>Wed, 19 Feb 2020 00:00:00 +0000</pubDate><guid>/post/pci/</guid><description>PCI 分析流程： 硬件文档 PCI框架核心层 PCI框架热插拔 vfio iommu vfio接口层与用户态使用cloud-hypervisor 一共十一万行代码。 从ACP</description></item><item><title>kdump工作机制分析</title><link>/post/kdump/</link><pubDate>Fri, 22 Nov 2019 00:00:00 +0000</pubDate><guid>/post/kdump/</guid><description>kdumpctl kdumpctl是一个shell脚本，用于查看当前kdump的状态和进行kdump相关操作。kdumpctl的入口是main函数，从中可以</description></item><item><title>Linux设备模型：bus与driver</title><link>/post/bus-and-driver/</link><pubDate>Sat, 28 Apr 2018 00:00:00 +0000</pubDate><guid>/post/bus-and-driver/</guid><description>bus &amp;amp; driver bus core的实现在driver/base/bus.c中，初始化过程由buses_init函数实现，函数中创建了两个kset：bus_k</description></item><item><title>Linux设备模型：kobject与uevent</title><link>/post/kobject-and-uevent/</link><pubDate>Sat, 28 Apr 2018 00:00:00 +0000</pubDate><guid>/post/kobject-and-uevent/</guid><description>kobject 1 2 3 4 5 6 7 struct kobj_type { void (*release)(struct kobject *kobj); const struct sysfs_ops *sysfs_ops; struct attribute **default_attrs; const struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj); const void *(*namespace)(struct kobject *kobj); }; 1 2 3 4 5 6 7 8 struct kobj_ns_type_operations { enum kobj_ns_type type; bool (*current_may_mount)(void); void *(*grab_current_ns)(void); const void *(*netlink_ns)(struct sock *sk); const void *(*initial_ns)(void); void (*drop_ns)(void *); }; 1 2 3 4 5 6</description></item><item><title>USB Hub驱动分析</title><link>/post/usb-hub/</link><pubDate>Tue, 27 Feb 2018 00:00:00 +0000</pubDate><guid>/post/usb-hub/</guid><description>USB hub框架分析 USB hub框架是usbcore模块里的一个大头5000行代码（5分之一）。同时，USB hub本身在USB协议中又是一个非常重要</description></item><item><title>inode权限检查</title><link>/post/inode-permission/</link><pubDate>Sun, 07 Jan 2018 00:00:00 +0000</pubDate><guid>/post/inode-permission/</guid><description>inode_permission函数 inode_permission函数用于对inode进行权限检查，我们传给其一个mask参数，这个参数是</description></item><item><title>eventfd在内核中的实现</title><link>/post/eventfd/</link><pubDate>Tue, 19 Dec 2017 00:00:00 +0000</pubDate><guid>/post/eventfd/</guid><description>eventfd是一个利用匿名文件描述符实现“等待/通知”通信机制的一种方式。它比较方便的一点是，eventfd不仅可以实现用户态与用户态之间</description></item></channel></rss>