<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>crab2313&#x27;s blog - risc-v</title>
	<link href="https://crab2313.github.io/tags/risc-v/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://crab2313.github.io"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2020-08-14T00:00:00+00:00</updated>
	<id>https://crab2313.github.io/tags/risc-v/atom.xml</id>
	<entry xml:lang="en">
		<title>Linux内核在RISC-V架构下的内存屏障与原子操作</title>
		<published>2020-08-14T00:00:00+00:00</published>
		<updated>2020-08-14T00:00:00+00:00</updated>
		<link href="https://crab2313.github.io/riscv-atomic-barrier-bitops/" type="text/html"/>
		<id>https://crab2313.github.io/riscv-atomic-barrier-bitops/</id>
		<content type="html">&lt;p&gt;内存一致性模型是一个体系结构中至关重要的一部分，本质上为软件与硬件之间的契约。软件开发人员可以从内存一致性模型中得知硬件进行内存操作时可能的行为，这是多线程共享内存操作正确性的基石。RISC-V的内存模型被称作RVWMO（RISC-V Weak Memory Order），本质上是&lt;code&gt;Release Consistency&lt;&#x2F;code&gt;与&lt;code&gt;Relaxed Consistency&lt;&#x2F;code&gt;的结合体。本文试图从Linux对内存一致性模型的抽象API入手，分析这些抽象API的用法用例以及对应RISC-V体系结构的实现。&lt;&#x2F;p&gt;
&lt;p&gt;题外话，来总结一下想要理解这部分内容需要哪些知识储备：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;GCC內联汇编基础。上述提到的抽象API有很大一部分都是使用具体体系结构下的汇编代码实现，因此掌握GCC提供的扩展內联汇编是读懂对应实现的必要基础。建议看这本&lt;a href=&quot;https:&#x2F;&#x2F;0xax.gitbooks.io&#x2F;linux-insides&#x2F;content&#x2F;Theory&#x2F;linux-theory-3.html&quot;&gt;简易教程&lt;&#x2F;a&gt;和&lt;a href=&quot;https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc-10.2.0&#x2F;gcc&#x2F;Extended-Asm.html&quot;&gt;GCC官方文档&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;计算机体系结构相关理论。这里没什么多说的，目前大部分体系结构手册都假定读者具有扎实的计算机体系结构理论基础。这里推荐&lt;a href=&quot;https:&#x2F;&#x2F;www.morganclaypool.com&#x2F;doi&#x2F;10.2200&#x2F;S00962ED2V01Y201910CAC049&quot;&gt;《A Primer on Memory Consistency and Cache Coherence, 2nd》&lt;&#x2F;a&gt;，里面有引用一些paper，建议一读。&lt;&#x2F;li&gt;
&lt;li&gt;对应体系结构手册。说到底，内存一致性是体系结构不可分离的一部分，因此熟读体系结构手册是理解对应操作的有力途径。&lt;&#x2F;li&gt;
&lt;li&gt;阅读内核文档。内核的&lt;code&gt;memory-barrier.txt&lt;&#x2F;code&gt;、&lt;code&gt;atomic_t.txt&lt;&#x2F;code&gt;以及&lt;code&gt;atomic_bitops.txt&lt;&#x2F;code&gt;都是极其重要的说明文档。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;nei-cun-ping-zhang&quot;&gt;内存屏障&lt;&#x2F;h2&gt;
&lt;p&gt;RISC-V的内存屏障全部由&lt;code&gt;fence&lt;&#x2F;code&gt;指令实现，第一次读RISC-V手册的人一般会难以相信&lt;code&gt;fence&lt;&#x2F;code&gt;的设计竟然这么简单。&lt;code&gt;fence&lt;&#x2F;code&gt;指令形式如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fence &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;iorw&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;], [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;iorw&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其中&lt;code&gt;[iorw]&lt;&#x2F;code&gt;为&lt;code&gt;iorw&lt;&#x2F;code&gt;中的任选几个字母，其中：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;i：设备内存输入（读取）&lt;&#x2F;li&gt;
&lt;li&gt;o: 设备内存输出（写入）&lt;&#x2F;li&gt;
&lt;li&gt;r：普通内存读取&lt;&#x2F;li&gt;
&lt;li&gt;w：普通内存写入&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;整个指令&lt;code&gt;fence [set1], [set2]&lt;&#x2F;code&gt;的语义为：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;定义predecessor集合为该&lt;code&gt;fence&lt;&#x2F;code&gt;指令之前所有属于&lt;code&gt;[set1]&lt;&#x2F;code&gt;类型的指令之集合&lt;&#x2F;li&gt;
&lt;li&gt;定义successor集合为该&lt;code&gt;fence&lt;&#x2F;code&gt;指令之后所有属于&lt;code&gt;[set2]&lt;&#x2F;code&gt;类型的指令之集合&lt;&#x2F;li&gt;
&lt;li&gt;则其他RISC-V Hart或者外部设备不会观测到successor集合中的指令在predecessor集合中的指令之前发生&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Linux内核中，内存屏障相关的定义都在体系结构对应文件夹下的&lt;code&gt;include&#x2F;asm&#x2F;barrier.h&lt;&#x2F;code&gt;中。其中，对于&lt;code&gt;fence&lt;&#x2F;code&gt;指令的抽象如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;RISCV_FENCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;p&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) \
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;__asm__ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__volatile__ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;fence &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; #p &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; #s : : : &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;memory&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;很显然是一条简单的內联汇编，&lt;code&gt;__volatile__&lt;&#x2F;code&gt;与&lt;code&gt;memory&lt;&#x2F;code&gt;都是用于阻止编译器进行优化的常规操作。后续的实现都是围绕这个宏进行的。&lt;&#x2F;p&gt;
&lt;p&gt;内核中对这些宏的实现策略比较简单，基本原理如下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;asm-generic&lt;&#x2F;code&gt;中的&lt;code&gt;barrier.h&lt;&#x2F;code&gt;中定义默认实现，如果目标架构没有对应实现，则启动默认实现&lt;&#x2F;li&gt;
&lt;li&gt;在&lt;code&gt;arch&#x2F;include&#x2F;asm&#x2F;barrier.h&lt;&#x2F;code&gt;中定义架构特定实现，一般为内联汇编定义&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;mb-rmb-wmb&quot;&gt;mb &amp;amp;&amp;amp; rmb &amp;amp;&amp;amp; wmb&lt;&#x2F;h3&gt;
&lt;p&gt;这三个操作与其对应的&lt;code&gt;smp_*&lt;&#x2F;code&gt;之间最大的区别就是需要对设备内存也生效，所以它们的实现如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;mb&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RISCV_FENCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(iorw,iorw)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;rmb&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RISCV_FENCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(ir,ir)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;wmb&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RISCV_FENCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(ow,ow)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;smp-mb-smp-rmb-smp-wmb&quot;&gt;smp_mb &amp;amp;&amp;amp; smp_rmb &amp;amp;&amp;amp; smp_wmb&lt;&#x2F;h3&gt;
&lt;p&gt;首先一定明确&lt;code&gt;smp_&lt;&#x2F;code&gt;前缀所代表的含义，即“用于SMP（symmetric multi-processor）的”。因此，在内核支持SMP时，它们被定义为其对应的&lt;code&gt;__smp_*&lt;&#x2F;code&gt;，反之则定义为&lt;code&gt;barrier()&lt;&#x2F;code&gt;，即普通的编译器内存屏障，防止编译器进行内存访问重排。前面也提到了，这几个操作并不需要考虑到设备内存，因此它们定义如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__smp_mb&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RISCV_FENCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(rw,rw)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__smp_rmb&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RISCV_FENCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(r,r)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__smp_wmb&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RISCV_FENCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(w,w)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;smp-load-acquire-smp-store-release&quot;&gt;smp_load_acquire &amp;amp;&amp;amp; smp_store_release&lt;&#x2F;h3&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__smp_store_release&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;p&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;v&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)					\
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{									\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;compiletime_assert_atomic_type&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*p);				\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RISCV_FENCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(rw,w);						\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;WRITE_ONCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*p, v);						\
} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__smp_load_acquire&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;p&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)						\
({									\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;typeof&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*p) ___p1 = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;READ_ONCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*p);				\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;compiletime_assert_atomic_type&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*p);				\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RISCV_FENCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(r,rw);						\
	___p1;								\
})
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;还是跟前面提到的一样，带&lt;code&gt;smp_&lt;&#x2F;code&gt;前缀的宏都是只在&lt;code&gt;CONFIG_SMP&lt;&#x2F;code&gt;开启时有定义，否则为空操作。&lt;code&gt;load acquire&lt;&#x2F;code&gt;的定义就是在这个&lt;code&gt;barrier&lt;&#x2F;code&gt;之后的读写不能出现在它之前，且&lt;code&gt;load acquire&lt;&#x2F;code&gt;是读取操作，所以自然使用&lt;code&gt;RISCV_FENCE(r, rw)&lt;&#x2F;code&gt;。&lt;code&gt;store release&lt;&#x2F;code&gt;同理。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yuan-zi-cao-zuo&quot;&gt;原子操作&lt;&#x2F;h2&gt;
&lt;p&gt;可以从&lt;code&gt;arch&#x2F;riscv&#x2F;Kconfig&lt;&#x2F;code&gt;中看到RISC-V平台在非64位时会选择&lt;code&gt;CONFIG_GENERIC_ATOMIC64&lt;&#x2F;code&gt;，如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;config RISCV
        def_bool y
        select ARCH_CLOCKSOURCE_INIT
        select ARCH_SUPPORTS_ATOMIC_RMW
        ......
        select GENERIC_ATOMIC64 if !64BIT   &amp;lt;== 
        select GENERIC_CLOCKEVENTS
        ......
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这点很好理解：在32位下RISC-V架构无法保证64位操作的原子性，因此内核使用通用的64位原子操作实现，通过自旋锁实现64位原子操作，这在&lt;code&gt;arch&#x2F;riscv&#x2F;include&#x2F;asm&#x2F;atomic.h&lt;&#x2F;code&gt;开头中有体现：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#ifdef&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; CONFIG_GENERIC_ATOMIC64
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;# include &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;asm-generic&#x2F;atomic64.h&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#else
# if&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; (__riscv_xlen &amp;lt; 64)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#  error &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;64-bit atomics require XLEN to be at least 64&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;# endif
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#endi
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;原子变量的定义是跨平台的，位于&lt;code&gt;include&#x2F;linux&#x2F;types.h&lt;&#x2F;code&gt;中：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typedef struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; counter;
} atomic_t;

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#ifdef&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; CONFIG_64BIT
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typedef struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
	s64 counter;
} atomic64_t;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#endif
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个原子性由硬件保证，一般来说，一个架构的word大小数据在对齐访问的情况下是可以保证原子性的，具体需要翻看手册。随后是&lt;code&gt;fence&lt;&#x2F;code&gt;指令实现的&lt;code&gt;release acquire&lt;&#x2F;code&gt;语义：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__atomic_acquire_fence&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()					\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;__asm__ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__volatile__&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(RISCV_ACQUIRE_BARRIER &amp;quot;&amp;quot; ::: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;memory&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;)

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__atomic_release_fence&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()					\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;__asm__ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__volatile__&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(RISCV_RELEASE_BARRIER &amp;quot;&amp;quot; ::: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;memory&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个用于&lt;code&gt;atomic-fallback.h&lt;&#x2F;code&gt;中自动生成的函数。对于读写这种&lt;code&gt;non-RMW&lt;&#x2F;code&gt;操作，如你所见就是这么简单：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; __always_inline &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;atomic_read&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; atomic_t *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;v&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;READ_ONCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(v-&amp;gt;counter);
}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; __always_inline &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;atomic_set&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(atomic_t *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;v&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;i&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;WRITE_ONCE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(v-&amp;gt;counter, i);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;还是那句话，硬件保证原子性，内核只要保证生成的指令不走样就行了，这也是使用&lt;code&gt;READ_ONCE&lt;&#x2F;code&gt;和&lt;code&gt;WRITE_ONCE&lt;&#x2F;code&gt;的原因。接下来就是重头戏：对于&lt;code&gt;RMW&lt;&#x2F;code&gt;操作实现。RISC-V中定义了原子操作指令，即被称为&lt;code&gt;A&lt;&#x2F;code&gt;的扩展，Linux内核默认要求其已被实现。内核中通过內联汇编模板的方式实现这些操作，也算是比较简洁的了。&lt;&#x2F;p&gt;
&lt;p&gt;对于&lt;code&gt;RMW&lt;&#x2F;code&gt;类的原子操作，我们主要关注其：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;功能正确性&lt;&#x2F;li&gt;
&lt;li&gt;内存序正确性&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;zhi-ling-jian-jie&quot;&gt;指令简介&lt;&#x2F;h3&gt;
&lt;p&gt;先来简单介绍一下RISC-V的原子操作指令。很简单，几句话就可以描述清楚：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;RISC-V的原子操作指令命名类如&lt;code&gt;amo{op}.{w&#x2F;d}.{rl&#x2F;aq&#x2F;aqrl}&lt;&#x2F;code&gt;。第一部分描述功能，如&lt;code&gt;amoadd&lt;&#x2F;code&gt;和&lt;code&gt;amoswap&lt;&#x2F;code&gt;等等，其中&lt;code&gt;amo&lt;&#x2F;code&gt;是&lt;code&gt;atomic memory operation&lt;&#x2F;code&gt;的缩写。第二部分为操作数据的长度，w（word）表示32位，d（double word）表示32位。第三部分比较有意思，RISC-V的原子操作指令中encode了两位，分别&lt;code&gt;acquire&lt;&#x2F;code&gt;和&lt;code&gt;release&lt;&#x2F;code&gt;，使其具有了内存序属性，看得出来是对OS进行了高度优化的。&lt;&#x2F;li&gt;
&lt;li&gt;RISC-V的原子操作指令编码了三个寄存器：&lt;code&gt;rs1&lt;&#x2F;code&gt;、&lt;code&gt;rs2&lt;&#x2F;code&gt;和&lt;code&gt;rd&lt;&#x2F;code&gt;。其中&lt;code&gt;rs1&lt;&#x2F;code&gt;为原子变量的内存地址，&lt;code&gt;rs2&lt;&#x2F;code&gt;是该操作的另一个操作数（operand）。指令执行时，首先从&lt;code&gt;rs1&lt;&#x2F;code&gt;指向的内存中取出原子变量的值，保存在&lt;code&gt;rd&lt;&#x2F;code&gt;寄存器，然后与&lt;code&gt;rs2&lt;&#x2F;code&gt;进行操作，最后将结果保存回&lt;code&gt;rs1&lt;&#x2F;code&gt;指向的内存地址。这里注意RISC-V的原子操作可以将变量的地址保存在&lt;code&gt;rd&lt;&#x2F;code&gt;寄存器，如果不需要可用&lt;code&gt;zero&lt;&#x2F;code&gt;寄存器当作&lt;code&gt;rd&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;wu-fan-hui-zhi-yuan-zi-cao-zuo-han-shu&quot;&gt;无返回值原子操作函数&lt;&#x2F;h3&gt;
&lt;p&gt;顾名思义，就是没有返回值的&lt;code&gt;RMW&lt;&#x2F;code&gt;类原子操作函数，注意这类函数在内核中是没有内存序要求的。可以看到这类函数使用一个通用的模板生成：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ATOMIC_OP&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;op&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;asm_op&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;I&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;asm_type&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;c_type&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;prefix&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)		\
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; __always_inline							\
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; atomic##prefix##_##&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;op&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(c_type i, atomic##prefix##_t *v)		\
{									\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;__asm__ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__volatile__ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(						\
		&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;	amo&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; #asm_op &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; #asm_type &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt; zero, %1, %0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;	\
		: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;+A&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (v-&amp;gt;counter)					\
		: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (I)						\
		: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;memory&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;);						\
}			
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;很简单，唯一需要注意的就是这个&lt;code&gt;+A&lt;&#x2F;code&gt;。从GCC官方的&lt;a href=&quot;https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc&#x2F;Machine-Constraints.html#Machine-Constraints&quot;&gt;文档&lt;&#x2F;a&gt;中可以看到，&lt;code&gt;A&lt;&#x2F;code&gt;是RISC-V中单独定义的，表示一个存放着内存地址的寄存器变量。且返回值寄存器被设置成&lt;code&gt;zero&lt;&#x2F;code&gt;，以示忽略。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ATOMIC_OPS&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;op&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;asm_op&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;I&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)					\
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ATOMIC_OP &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(op, asm_op, I, w, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,   )				\
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ATOMIC_OP &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(op, asm_op, I, d, s64, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;64&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#endif

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ATOMIC_OPS&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(add, add,  i)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ATOMIC_OPS&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(sub, add, -i)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ATOMIC_OPS&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(and, and,  i)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ATOMIC_OPS&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;( or,  or,  i)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ATOMIC_OPS&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(xor, xor,  i)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;you-fan-hui-zhi-yuan-zi-cao-zuo-han-shu&quot;&gt;有返回值原子操作函数&lt;&#x2F;h3&gt;
&lt;p&gt;内核中，有返回值原子操作函数分为&lt;code&gt;fetch&lt;&#x2F;code&gt;和&lt;code&gt;return&lt;&#x2F;code&gt;。这二者的区别为&lt;code&gt;fetch&lt;&#x2F;code&gt;返回原子变量原有的值，而&lt;code&gt;return&lt;&#x2F;code&gt;返回原子变量经过操作的值。我们可以从内核中的&lt;code&gt;atomic_t.txt&lt;&#x2F;code&gt;文档中知道，默认情况下，有返回值的原子操作函数都是有内存序的。且函数具有一些加了特殊后缀的变体，可以指定内存序语义，如&lt;code&gt;_relaxed&lt;&#x2F;code&gt;、&lt;code&gt;_acquire&lt;&#x2F;code&gt;和&lt;code&gt;_release&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ATOMIC_FETCH_OP&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;op&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;asm_op&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;I&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;asm_type&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;c_type&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;prefix&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)	\
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; __always_inline							\
c_type atomic##prefix##_fetch_##op##&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_relaxed&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(c_type i,			\
					     atomic##prefix##_t *v)	\
{									\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;register&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; c_type ret;						\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;__asm__ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__volatile__ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(						\
		&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;	amo&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; #asm_op &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; #asm_type &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt; %1, %2, %0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;	\
		: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;+A&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (v-&amp;gt;counter), &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;=r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (ret)				\
		: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (I)						\
		: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;memory&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;);						\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ret;							\
}									\
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; __always_inline							\
c_type atomic##prefix##_fetch_##&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;op&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(c_type i, atomic##prefix##_t *v)	\
{									\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;register&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; c_type ret;						\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;__asm__ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__volatile__ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(						\
		&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;	amo&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; #asm_op &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; #asm_type &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.aqrl  %1, %2, %0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;	\
		: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;+A&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (v-&amp;gt;counter), &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;=r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (ret)				\
		: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (I)						\
		: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;memory&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;);						\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ret;							\
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到&lt;code&gt;fetch&lt;&#x2F;code&gt;函数的內联汇编模板也分两套，对于&lt;code&gt;_relaxed&lt;&#x2F;code&gt;函数，没有加上&lt;code&gt;.aqrl&lt;&#x2F;code&gt;，即不指定内存序语义。&lt;code&gt;return&lt;&#x2F;code&gt;函数实际上就是&lt;code&gt;fetch&lt;&#x2F;code&gt;函数返回值经过重新计算得出，不再赘述，注意想清楚&lt;code&gt;atomic&lt;&#x2F;code&gt;的操作究竟在哪，就不会有&lt;code&gt;return&lt;&#x2F;code&gt;函数不是原子操作的错觉。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;atomic-fetch-add-unless-atomic-sub-if-positive&quot;&gt;atomic_fetch_add_unless &amp;amp;&amp;amp; atomic_sub_if_positive&lt;&#x2F;h3&gt;
&lt;p&gt;RISC-V结构下对这两个函数做了实现，且都是利用了&lt;code&gt;LR&#x2F;SC&lt;&#x2F;code&gt;指令。先来看一下它们实现的功能：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;atomic_fetch_add_unless&lt;&#x2F;code&gt;有两个额外参数&lt;code&gt;a&lt;&#x2F;code&gt;和&lt;code&gt;u&lt;&#x2F;code&gt;，进行操作时，如果原子变量的值与&lt;code&gt;u&lt;&#x2F;code&gt;不相等，则将其加上&lt;code&gt;a&lt;&#x2F;code&gt;，并返回原先的值。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;atomic_sub_if_positive&lt;&#x2F;code&gt;从名字上就可以看出来功能：如果原子变量的值是正的，则将其减去参数传入的值，并返回最后的结果。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;前面提到这两个操作是&lt;code&gt;LR&#x2F;SC&lt;&#x2F;code&gt;指令实现的，那么先简介一下这对指令是如何工作的：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;LR指令是&lt;code&gt;load reserved&lt;&#x2F;code&gt;的缩写，它首先会读取一个内存地址的值，然后在该内存地址做标记。&lt;&#x2F;li&gt;
&lt;li&gt;SC指令是&lt;code&gt;store conditional&lt;&#x2F;code&gt;的缩写，它的作用写将一个值写入一个内存地址。对于同一个&lt;code&gt;HART&lt;&#x2F;code&gt;，&lt;code&gt;SC&lt;&#x2F;code&gt;首先检查标记的值是否正确，如果正确才进行写入操作，否则返回错误。注意无论如何对应地址的标记都会被&lt;code&gt;SC&lt;&#x2F;code&gt;指令清除。&lt;&#x2F;li&gt;
&lt;li&gt;LR和SC配合使用，其意义在于：如果SC指令成功执行，则意味着在LR到SC指令这一段时间内，没有其他的&lt;code&gt;HART&lt;&#x2F;code&gt;对这个地址进行访问（因为标记没有失效）。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;__asm__ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__volatile__ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(
		&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;0:	lr.w     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%[p]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%[c]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
		&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;	beq      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%[p]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%[u]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;, 1f&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
		&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;	add      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%[rc]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%[p]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%[a]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
		&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;	sc.w.rl  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%[rc]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%[rc]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%[c]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
		&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;	bnez     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%[rc]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;, 0b&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
		&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;	fence    rw, rw&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
		&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;1:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
		: [p]&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;=&amp;amp;r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (prev), [rc]&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;=&amp;amp;r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (rc), [c]&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;+A&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (v-&amp;gt;counter)
		: [a]&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (a), [u]&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot; (u)
		: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;memory&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到本质是通过循环调用&lt;code&gt;LR&#x2F;SC&lt;&#x2F;code&gt;对，不断尝试，如果成功，则说明这段时间内没有人访问原子变量，操作成功独占，故而肯定是原子的。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Linux内核在RISC-V架构下的setup_arch与异常处理</title>
		<published>2020-08-05T00:00:00+00:00</published>
		<updated>2020-08-05T00:00:00+00:00</updated>
		<link href="https://crab2313.github.io/riscv-setup-arch-exception/" type="text/html"/>
		<id>https://crab2313.github.io/riscv-setup-arch-exception/</id>
		<content type="html">&lt;p&gt;在分析完Linux内核在RISC-V架构下的启动流程后，我们分析Linux下与RISC-V相关的架构相关实现。很明显，这类知识都是非常零散的，这里使用的入手点为&lt;code&gt;setup_arch&lt;&#x2F;code&gt;的实现。&lt;&#x2F;p&gt;
&lt;p&gt;在开始分析之前，一定要对Linux内核的架构相关代码有一定的认识，这里做一个原理性的说明。Linux内核的codebase可以简单分成两个部分：架构相关部分和架构无关部分。为了支持多个架构，且最大限度地公用代码，又保留架构相关实现的灵活性，Linux内核的实现经过了精细的设计。内核底层对一些架构相关的操作进行了抽象，向内核通用代码提供了公共的接口。每一个内核支持的架构都对应一个&lt;code&gt;arch&#x2F;&lt;&#x2F;code&gt;下的文件夹，里面存放着本架构相关的代码。&lt;&#x2F;p&gt;
&lt;p&gt;接下来简要介绍一下内核实现多架构支持的手段：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;条件编译。这个方法主要用在一些极端特殊场合，多用于驱动对特定平台的区别操作。内核提供了一些宏，用于检测当前架构。&lt;&#x2F;li&gt;
&lt;li&gt;weak函数。这个方法利用了ELF object文件中的&lt;code&gt;weak symbol&lt;&#x2F;code&gt;，具有这个属性的&lt;code&gt;symbol&lt;&#x2F;code&gt;在链接时，如果链接器可以在所有进行链接的object文件中找到同名&lt;code&gt;symbol&lt;&#x2F;code&gt;，则会用这个&lt;code&gt;symbol&lt;&#x2F;code&gt;把&lt;code&gt;weak symbol&lt;&#x2F;code&gt;顶替掉。内核使用&lt;code&gt;__weak&lt;&#x2F;code&gt;（本质就是一个GCC扩展）标记weak函数。内核可以对所有架构实现一个通用的weak函数，如果有架构需要一个自己的版本，则可以直接定义，并将其顶替。&lt;&#x2F;li&gt;
&lt;li&gt;平台相关函数。这类函数为强平台相关，内核一般定义一个共同函数原型及函数语意，由各架构自行实现该函数。这里其实也包括一部分宏。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;setup-arch&quot;&gt;setup_arch&lt;&#x2F;h2&gt;
&lt;p&gt;阅读过任何一本内核书的人对这个函数一定不陌生。这个函数主要做架构相关的初始化操作。函数首先设置&lt;code&gt;init_mm&lt;&#x2F;code&gt;上的四个变量，前面提到过，&lt;code&gt;_stext&lt;&#x2F;code&gt;等变量是通过链接脚本放到内核二进制文件特定地址的，通过他们可以获取内核内存布局的范围。注意这里已经开启MMU了，且RISC-V内核使用的是PC相对寻址，因此这时获取的是对应的虚拟地址。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	init_mm.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;start_code &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) _stext;
	init_mm.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;end_code   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) _etext;
	init_mm.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;end_data   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) _edata;
	init_mm.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;brk        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) _end;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;she-bei-shu-yu-can-shu-jie-xi&quot;&gt;设备树与参数解析&lt;&#x2F;h3&gt;
&lt;p&gt;在这个阶段，设备树并没有完全进行解析，内核只需要提取一小部分重要信息即可。回顾原先的分析，&lt;code&gt;_start_kernel&lt;&#x2F;code&gt;在调用&lt;code&gt;start_kernel&lt;&#x2F;code&gt;前调用了&lt;code&gt;parse_dtb&lt;&#x2F;code&gt;函数，如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; __init &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;parse_dtb&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;early_init_dt_scan&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(dtb_early_va))
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;

	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pr_err&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;No DTB passed to the kernel&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#ifdef&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; CONFIG_CMDLINE_FORCE
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;strlcpy&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(boot_command_line, CONFIG_CMDLINE, COMMAND_LINE_SIZE);
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pr_info&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Forcing kernel command line to: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, boot_command_line);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#endif
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个函数简单调用了设备树（OF）模块的通用函数&lt;code&gt;early_init_dt_scan&lt;&#x2F;code&gt;，从设备树中解析并设置一些基本的信息。这里简单分析一下获取了哪些信息。在简单检查设备树的合法性之后，可以看到进行了如下操作：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Retrieve various information from the &#x2F;chosen node *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	rc = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;of_scan_flat_dt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(early_init_dt_scan_chosen, boot_command_line);
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(!rc)
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pr_warn&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;No chosen node found, continuing without&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;);

	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Initialize {size,address}-cells info *&#x2F;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;of_scan_flat_dt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(early_init_dt_scan_root, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);

	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Setup memory, calling early_init_dt_add_memory_arch *&#x2F;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;of_scan_flat_dt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(early_init_dt_scan_memory, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;总结如下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;扫描设备树的&lt;code&gt;chosen&lt;&#x2F;code&gt;节点，获取内核命令行，initrd等关键信息，其中内核并命令行被保存在&lt;code&gt;boot_command_line&lt;&#x2F;code&gt;字符数组中&lt;&#x2F;li&gt;
&lt;li&gt;扫描&lt;code&gt;&#x2F;&lt;&#x2F;code&gt;节点下的&lt;code&gt;#address-cells&lt;&#x2F;code&gt;，&lt;code&gt;#size-cells&lt;&#x2F;code&gt;等信息并记录&lt;&#x2F;li&gt;
&lt;li&gt;扫描&lt;code&gt;memory&lt;&#x2F;code&gt;节点信息，获取设备树中关于内存的描述，并调用&lt;code&gt;early_init_dt_add_memory_arch&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;code&gt;early_init_dt_add_memory_arch&lt;&#x2F;code&gt;函数RISC-V使用了内核默认的实现，即将内核区域添加到&lt;code&gt;memblock&lt;&#x2F;code&gt;中。也就是说，RISC-V架构下的启动内存管理器是memblock，memblock的实现比较独立，另开文档进行分析。&lt;&#x2F;p&gt;
&lt;p&gt;在&lt;code&gt;setup_arch&lt;&#x2F;code&gt;中调用了&lt;code&gt;parse_early_param&lt;&#x2F;code&gt;通用函数，用于解析&lt;code&gt;early param&lt;&#x2F;code&gt;。内核中的&lt;code&gt;early param&lt;&#x2F;code&gt;都会特殊标记起来，保存在一个特殊的section里，在内核启动初期从内核命令行解析出来。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;memblockchu-shi-hua&quot;&gt;memblock初始化&lt;&#x2F;h3&gt;
&lt;p&gt;前面看到，内核中设备树解析的通用代码将设备树中设定的可用内存区域传递给&lt;code&gt;memblock&lt;&#x2F;code&gt;进行管理。而在&lt;code&gt;setup_arch&lt;&#x2F;code&gt;中则调用&lt;code&gt;setup_bootmem&lt;&#x2F;code&gt;初始化memblock。&lt;&#x2F;p&gt;
&lt;p&gt;前面已经看到，从设备树中读取到的可用物理内存范围已经在内核默认的&lt;code&gt;early_init_dt_add_memory_arch&lt;&#x2F;code&gt;中加入到了memblock管理器中。此时，memblock还需要进行一些别的操作，使其可用。首当其冲的就是保留特定物理内存，这一点是比较容易想到的。一般情况下，设备树描述的是整个板子可用的物理内存区域，内核二进制，设备树二进制装载进内存时也会占用其中一部分空间，这就需要&lt;code&gt;setup_bootmem&lt;&#x2F;code&gt;函数手动保留这些区域。&lt;&#x2F;p&gt;
&lt;p&gt;如果读过设备树的标准，则应该知道，设备树中存在&lt;code&gt;reserved memory&lt;&#x2F;code&gt;的描述，因此&lt;code&gt;setup_bootmem&lt;&#x2F;code&gt;调用&lt;code&gt;early_init_fdt_scan_reserved_mem&lt;&#x2F;code&gt;函数进行扫描，然后将对应参数进行保留。最后函数将所有物理内存区域的NUMA节点设置为0。&lt;&#x2F;p&gt;
&lt;p&gt;这里还有一个点可以稍微提一下：在RISC-V体系结构下，如果开启两级页表，那么最大能够支持的物理内存大小是2GB，如果可用物理内存大小超过了2GB，页表是无法进行映射的。&lt;code&gt;setup_bootmem&lt;&#x2F;code&gt;函数因此进行了一项修复，即将超出最大支持范围的物理内存区域从bootmem中移除，避免对其的访问。对二进制比较敏感的话，可以想到，这一大小正好是&lt;code&gt;-PAGE_OFFSET&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;paging-init&quot;&gt;paging_init&lt;&#x2F;h3&gt;
&lt;p&gt;从名字上就可以看出这个函数是干什么的：初始化页表。前一篇文档看到内核在&lt;code&gt;setup_vm&lt;&#x2F;code&gt;中初始化了一个&lt;code&gt;early_pg_dir&lt;&#x2F;code&gt;页表，仅仅映射了内核所占用内存和一个FDT的fixmap，而&lt;code&gt;paging_init&lt;&#x2F;code&gt;中的&lt;code&gt;setup_vm_final&lt;&#x2F;code&gt;则是该操作的延续。首先明确使用两级初始化的原因：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;在没有读取设备树之前，内核是不知道物理内存的大小的。如果非要缩成一步，那么只能从内核所在内存结尾处开始，猜一个大小然后进行映射。这种实现有巨大的不确定性，并不是一个好的选择&lt;&#x2F;li&gt;
&lt;li&gt;紧接上一条，这么做有可能需要映射一些不存在的内存区域，使得页表占用更多空间&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;所以&lt;code&gt;setup_vm_final&lt;&#x2F;code&gt;的操作本质上就是将memblock中管理的内存添加到到&lt;code&gt;swapper_pg_dir&lt;&#x2F;code&gt;页表中，然后启用该页表。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;paging_init&lt;&#x2F;code&gt;随后初始化&lt;code&gt;Sparse Memory&lt;&#x2F;code&gt;，当然我们这里没有开启其对应支持，不予分析。&lt;code&gt;setup_zero_page&lt;&#x2F;code&gt;函数将内核预先在BSS中预留的一个page进行初始化操作（全写0）。&lt;code&gt;zone_size_init&lt;&#x2F;code&gt;函数实现比较简单，但是原先分析时漏掉了一点，这里补上。&lt;&#x2F;p&gt;
&lt;p&gt;目前的内核已经把bootmem去掉了，但是它的影响依然在内核中。&lt;code&gt;setup_bootmem&lt;&#x2F;code&gt;函数中设置了几个变量，如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;set_max_mapnr&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;PFN_DOWN&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(mem_size));
	max_pfn = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;PFN_DOWN&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;memblock_end_of_DRAM&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;());
	max_low_pfn = max_pfn;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这几个静态变量的意义如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;    min_low_pfn - the lowest PFN that is available in the system
    max_low_pfn - the highest PFN that may be addressed by low memory (ZONE_NORMAL)
    max_pfn - the last PFN available to the system.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;zone_size_init&lt;&#x2F;code&gt;如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; __init &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;zone_sizes_init&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; max_zone_pfns[MAX_NR_ZONES] = { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, };

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#ifdef&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; CONFIG_ZONE_DMA32
	max_zone_pfns[ZONE_DMA32] = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;PFN_DOWN&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;min&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;UL &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* SZ_1G,
			(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;PFN_PHYS&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(max_low_pfn)));
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#endif
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	max_zone_pfns[ZONE_NORMAL] = max_low_pfn;

	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;free_area_init_nodes&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(max_zone_pfns);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到&lt;code&gt;ZONE_DMA32&lt;&#x2F;code&gt;的边界为4GB，这基本就是废话。记住这里初始化了&lt;code&gt;pg_data_t&lt;&#x2F;code&gt;就行了。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;unflatten-device-tree&quot;&gt;unflatten_device_tree&lt;&#x2F;h3&gt;
&lt;p&gt;该函数为OF模块的代码，目的是将设备树转换成更高效的内存中表示。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;sbi-init-setup-smp-riscv-fill-hwcap&quot;&gt;sbi_init &amp;amp;&amp;amp; setup_smp &amp;amp;&amp;amp; riscv_fill_hwcap&lt;&#x2F;h3&gt;
&lt;p&gt;这些非常独立的部分单独进行分析。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jin-cheng-guan-li&quot;&gt;进程管理&lt;&#x2F;h2&gt;
&lt;p&gt;进程管理与体系结构相关的地方基本就是上下文切换了，在内核一般被称为switch。为了高速进行上下文切换，这个过程涉及的一部分数据结构和相关操作是与体系结构强相关的。&lt;strong&gt;任务&lt;&#x2F;strong&gt;上下文切换的基本执行操作由&lt;code&gt;__switch_to&lt;&#x2F;code&gt;完成，一般会再包装一层&lt;code&gt;switch_to&lt;&#x2F;code&gt;，现在以这个函数入手，分析RISC-V平台下对应的实现。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;__switch_to&lt;&#x2F;code&gt;在各个体系结构下有对应的实现，是体系结构强相关的。这是因为其基本行为就是保存当前CPU的执行状态，然后再装载一个其他的执行状态，这其中涉及到的寄存器保存等操作在每个体系结构都不一样。&lt;code&gt;__switch_to&lt;&#x2F;code&gt;函数在RISC-V下由汇编实现，位于&lt;code&gt;arch&#x2F;riscv&#x2F;kernel&#x2F;entry.S&lt;&#x2F;code&gt;中，如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ENTRY(__switch_to)
        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Save context &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;into &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;prev&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&amp;gt;thread &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        li    a4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_THREAD_RA
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;a3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;a0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;a4
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;a4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;a1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;a4
        REG_S ra&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_THREAD_RA_RA(a3)
        REG_S &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_THREAD_SP_RA(a3)
        REG_S s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_THREAD_S0_RA(a3)
        REG_S s1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_THREAD_S1_RA(a3)
        REG_S s2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_THREAD_S2_RA(a3)
        ...
        REG_S s11&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_THREAD_S11_RA(a3)
        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Restore context from next&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&amp;gt;thread &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        REG_L ra&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_THREAD_RA_RA(a4)
        REG_L &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_THREAD_SP_RA(a4)
        REG_L s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_THREAD_S0_RA(a4)
        REG_L s1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_THREAD_S1_RA(a4)
        ...
        REG_L s11&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_THREAD_S11_RA(a4)
        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Swap the &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;CPU &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;entry around. &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        lw a3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_TI_&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;CPU&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(a0)
        lw a4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_TI_&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;CPU&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(a1)
        sw a3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_TI_&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;CPU&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(a1)
        sw a4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_TI_&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;CPU&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(a0)
#if TASK_TI != &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;#error &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;TASK_TI != 0: tp will contain a &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;struct thread_info&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;#39;, not a &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;struct task_struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;#39; so get_current() won&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;t work.&amp;quot;
        addi tp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;a1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_TI
#else
        move tp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;a1
#endif
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ret
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ENDPROC(__switch_to)

&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;实现是比较简单的，这里稍微解读一下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a0&lt;&#x2F;code&gt;和&lt;code&gt;a1&lt;&#x2F;code&gt;分别为进行上下文切换的两个&lt;code&gt;task_struct&lt;&#x2F;code&gt;地址&lt;&#x2F;li&gt;
&lt;li&gt;需要保存的执行状态被称作&lt;code&gt;thread_struct&lt;&#x2F;code&gt;，与体系结构相关，被定义在&lt;code&gt;asm&#x2F;processor.h&lt;&#x2F;code&gt;中。或许有人会奇怪为什么保存的寄存器这么少，只有&lt;code&gt;ra&lt;&#x2F;code&gt;，&lt;code&gt;sp&lt;&#x2F;code&gt;，&lt;code&gt;s0&lt;&#x2F;code&gt;-&lt;code&gt;s11&lt;&#x2F;code&gt;。这个解释比较简单，注意它们在RISC-V ABI中被称作&lt;code&gt;Callee-Saved&lt;&#x2F;code&gt;寄存器，被调用函数方需要保存的寄存器，反之就是其他寄存器已经被调用方保存过了（栈上）。也就是说&lt;code&gt;__switch_to&lt;&#x2F;code&gt;只需要保存这些没有被保存的寄存器，结合栈上原有的寄存器，即可还原处理器状态。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;tp&lt;&#x2F;code&gt;寄存器全称&lt;code&gt;thread pointer&lt;&#x2F;code&gt;，在内核态中用于保存当前&lt;code&gt;task_struct&lt;&#x2F;code&gt;的指针。上下文切换时，需要更改该寄存器。&lt;&#x2F;li&gt;
&lt;li&gt;注意&lt;code&gt;__switch_to&lt;&#x2F;code&gt;函数有返回值，返回值为&lt;code&gt;a0&lt;&#x2F;code&gt;。注意&lt;code&gt;a0&lt;&#x2F;code&gt;从头到尾没有变化，正确理解这个行为其实就是正确理解上下文切换的关键。&lt;&#x2F;li&gt;
&lt;li&gt;最后一个细节，&lt;code&gt;TASK_TI_CPU&lt;&#x2F;code&gt;等常量是哪里来的呢。这个问题本质为C与汇编的互通有无问题，如果想要在汇编中访问结构体的字段，其常规操作为结构体指针加上一个偏移量。&lt;code&gt;Kbuild&lt;&#x2F;code&gt;提供了&lt;code&gt;asm-offsets.h&lt;&#x2F;code&gt;机制，开发者只需要在&lt;code&gt;asm-offsets.c&lt;&#x2F;code&gt;中定义macro和其对应的结构体和结构体中的字段，内核的&lt;code&gt;Kbuild&lt;&#x2F;code&gt;即可自行生成&lt;code&gt;asm-offsets.h&lt;&#x2F;code&gt;供汇编代码引用。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* CPU-specific state of a task *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;thread_struct {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Callee-saved registers *&#x2F;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; ra;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; sp;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Kernel mode stack *&#x2F;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned long&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; s[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;];	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* s[0]: frame pointer *&#x2F;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; __riscv_d_ext_state fstate;
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上面是不是少了什么东西？很明显少了浮点和向量寄存器的处理。很多书上其实写明白了，内核中并不使用浮点或者向量指令，因此这两类指令相关的寄存器管理是需要区别对待的。这方面一个比较普遍的优化原理就是内核对用户态进程对于浮点或者向量指令的使用进行检测，仅当用户态使用了时才在上下文切换时记录对应的状态。来看RISC-V是如何实现真正的上下文入口&lt;code&gt;switch_to&lt;&#x2F;code&gt;的：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;switch_to&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;prev&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;next&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;last&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)			\
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{							\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; task_struct *__prev = (prev);		\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; task_struct *__next = (next);		\
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(has_fpu)					\
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__switch_to_aux&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(__prev, __next);	\
	((last) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__switch_to&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(__prev, __next));		\
} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;和其他体系结构大同小异，&lt;code&gt;switch_to&lt;&#x2F;code&gt;是一个宏，它的参数意义大部分书中都有涉及，这里只详细解释一下&lt;code&gt;last&lt;&#x2F;code&gt;参数的行为在RISC-V下是如何实现的。首先一定要明确&lt;code&gt;__prev&lt;&#x2F;code&gt; 和&lt;code&gt;__next&lt;&#x2F;code&gt;这两个变量的声明，这两个变量是保存在&lt;strong&gt;栈上&lt;&#x2F;strong&gt;的，只要栈（指针）发生了改变，那么这两个变量的值就会发生改变。调用&lt;code&gt;__switch_to&lt;&#x2F;code&gt;函数时，参数通过&lt;code&gt;a0&lt;&#x2F;code&gt;传入，因此&lt;code&gt;__switch_to&lt;&#x2F;code&gt;的&lt;code&gt;a0&lt;&#x2F;code&gt;一定是上一次上下文切换时的&lt;code&gt;task_struct&lt;&#x2F;code&gt;，假设其为A。而当&lt;code&gt;__switch_to&lt;&#x2F;code&gt;执行完毕之后，由于栈指针发生了改变，变为A被上下文切换时的栈指针，此时的&lt;code&gt;__prev&lt;&#x2F;code&gt;变为了A被上下文切换时处理器执行的前一个任务。&lt;&#x2F;p&gt;
&lt;p&gt;回归重点，即当&lt;code&gt;has_fpu&lt;&#x2F;code&gt;为&lt;code&gt;true&lt;&#x2F;code&gt;时的&lt;code&gt;__switch_to_aux&lt;&#x2F;code&gt;路径。内核提供&lt;code&gt;CONFIG_FPU&lt;&#x2F;code&gt;选项配置内核对FPU的支持，在支持FPU的情况下，如果&lt;code&gt;status&lt;&#x2F;code&gt;寄存器的&lt;code&gt;SD&lt;&#x2F;code&gt;位被设置，说明需要保存FPU状态，此时内核调用&lt;code&gt;fstate_save&lt;&#x2F;code&gt;函数将FPU寄存器保存。如果被切换到的任务的浮点寄存器已被使用，则将其状态恢复：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static inline void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fstate_restore&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; task_struct *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;task&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
				  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; pt_regs *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;regs&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;((regs-&amp;gt;status &amp;amp; SR_FS) != SR_FS_OFF) {
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__fstate_restore&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(task);
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__fstate_clean&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(regs);
	}
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h2 id=&quot;zhong-duan-yi-chang-yu-xi-tong-diao-yong&quot;&gt;中断、异常与系统调用&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;code&gt;start_kernel&lt;&#x2F;code&gt;函数的开头会调用&lt;code&gt;local_irq_disable&lt;&#x2F;code&gt;将当前CPU的中断处理关闭，这是非常正常的，毕竟这个阶段内核没有做好处理中断的准备，而此时的中断向量也是&lt;code&gt;head.S&lt;&#x2F;code&gt;中利用&lt;code&gt;trampoline&lt;&#x2F;code&gt;进行虚拟地址跳跃时设置的。RISC-V下的中断向量是&lt;code&gt;trap_init&lt;&#x2F;code&gt;中设置的，定义在&lt;code&gt;arch&#x2F;riscv&#x2F;traps.c&lt;&#x2F;code&gt;中，如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;trap_init&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;*
	 * Set sup0 scratch register to 0, indicating to exception vector
	 * that we are presently executing in the kernel
	 *&#x2F;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;csr_write&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(CSR_SCRATCH, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Set the exception vector address *&#x2F;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;csr_write&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(CSR_TVEC, &amp;amp;handle_exception);
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Enable interrupts *&#x2F;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;csr_write&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(CSR_IE, IE_SIE);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;对于&lt;code&gt;CSR_SCRATCH&lt;&#x2F;code&gt;寄存器的设计用途，RISC-V的手册中讲的不明所以，这在后续的代码分析中就会明晰。&lt;code&gt;traps_init&lt;&#x2F;code&gt;函数随后将中断向量设置为&lt;code&gt;handle_exception&lt;&#x2F;code&gt;函数的地址，并将软件中断打开。在处理器不同状态之间跳转的代码一般实现在体系结构对应的&lt;code&gt;entry.S&lt;&#x2F;code&gt;中，RISC-V也不例外。这里注意&lt;code&gt;CSR_TVEC&lt;&#x2F;code&gt;的最低两位是中断处理模式，由于RISC-V指令为4字节对齐，那么这个模式位必为0，也就是所有的中断都会由&lt;code&gt;handle_exception&lt;&#x2F;code&gt;处理。&lt;&#x2F;p&gt;
&lt;p&gt;传统意义上的I&#x2F;O中断，异常，以及系统调用都由&lt;code&gt;handle_exception&lt;&#x2F;code&gt;进行处理，这就意味着该函数的实现相对复杂，需要好好梳理。从这个函数中我们也可以分析出&lt;code&gt;CSR_SCRATCH&lt;&#x2F;code&gt;寄存器是如何使用的。Linux内核使用&lt;code&gt;CSR_SCRATCH&lt;&#x2F;code&gt;寄存器保存当前特权级对立特权级（内核态对应用户态，用户态对应内核态）的&lt;code&gt;tp&lt;&#x2F;code&gt;寄存器的值，且如果&lt;code&gt;CSR_SCRATCH&lt;&#x2F;code&gt;为0则表示中断是在内核态触发的。函数开头如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ENTRY(handle_exception)
	&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*
	 * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;If coming from userspace&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;preserve the user thread pointer &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;and &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;load
	 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;the kernel thread pointer.  If we came from the kernel&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;the scratch
	 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;register will contain &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;and &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;we should continue on the current TP.
	 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
	csrrw tp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;CSR_SCRATCH&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;tp
	bnez tp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;_save_context

_restore_kernel_tpsp:
	csrr tp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;CSR_SCRATCH
	REG_S &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_TI_KERNEL_SP(tp)
_save_context:
	...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;即先将当前&lt;code&gt;tp&lt;&#x2F;code&gt;的值与&lt;code&gt;CSR_SCRATCH&lt;&#x2F;code&gt;的值进行交换，如果发现&lt;code&gt;CSR_SCRATCH&lt;&#x2F;code&gt;的值为0，则明显是由内核态跳入异常处理的，此时需要将&lt;code&gt;tp&lt;&#x2F;code&gt;寄存器的值还原，并将此时的内核栈指针保存在&lt;code&gt;struct thread_info&lt;&#x2F;code&gt;的&lt;code&gt;kernel_sp&lt;&#x2F;code&gt;字段中。从函数中可以看到，&lt;code&gt;thread_info-&amp;gt;kernel_sp&lt;&#x2F;code&gt;的值在每次进入异常处理时都会被写掉，但由于&lt;code&gt;handle_exception&lt;&#x2F;code&gt;记录了&lt;code&gt;pt_regs&lt;&#x2F;code&gt;，因此异常退出时该值可以被还原。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;_save_context&lt;&#x2F;code&gt;本质上是在栈上保存一个&lt;code&gt;pt_regs&lt;&#x2F;code&gt;，不赘述。随后&lt;code&gt;CSR_SCRATCH&lt;&#x2F;code&gt;被写0用以标记内核态，如前面所述。接下来装载&lt;code&gt;gp&lt;&#x2F;code&gt;寄存器，这对C语言运行环境是至关重要的。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;	&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Load the &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;global &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;pointer &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
.option &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;push
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.option norelax
	la gp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__global_pointer$
.option po
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;注意&lt;code&gt;norelax&lt;&#x2F;code&gt;属性可以要求链接器不对标记区域的指令进行重排优化操作。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhong-duan&quot;&gt;中断&lt;&#x2F;h3&gt;
&lt;p&gt;可以通过&lt;code&gt;CSR_CAUSE&lt;&#x2F;code&gt;的最高位确定当前是否是中断，所以有如下实现：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;	la ra&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ret_from_exception
	&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*
	 * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;MSB of cause differentiates between
	 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;interrupts &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;and &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;exceptions
	 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
	bge s4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;zero&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;1f

	&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Handle interrupts &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
	move a0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;pt_regs &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
	tail do_IRQ
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;函数&lt;code&gt;do_IRQ&lt;&#x2F;code&gt;的返回地址被设置成了&lt;code&gt;ret_from_exception&lt;&#x2F;code&gt;，如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ret_from_exception:
	REG_L s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;PT_STATUS(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;)
	csrc CSR_STATUS&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;SR_IE
#ifdef CONFIG_RISCV_M_MODE
	&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;the MPP value is too large to be used as an immediate arg for addi &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
	li t0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;SR_MPP
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;and &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;t0
#else
	andi s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;SR_SPP
#endif
	bnez s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;resume_kernel
resume_userspace:
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;通过&lt;code&gt;CSR_STATUS&lt;&#x2F;code&gt;上的&lt;code&gt;SPP&lt;&#x2F;code&gt;位可以获取到&lt;code&gt;handle_exception&lt;&#x2F;code&gt;跳转执行时原先CPU位于的特权级，对于内核态和用户态需要区分对待。实际上这两者最本质的区别就是对抢占的处理，&lt;code&gt;resume_kernel&lt;&#x2F;code&gt;会根据内核编译时是否支持抢占执行对应的操作：如果支持抢占，则检查当前任务的&lt;code&gt;preempt_count&lt;&#x2F;code&gt;和&lt;code&gt;TIF_NEED_RESCHED&lt;&#x2F;code&gt;标志，进行抢占操作，反之则直接返回。注意这里这个&lt;code&gt;ret_from_exception&lt;&#x2F;code&gt;是由多个路径共享的。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;do_IRQ&lt;&#x2F;code&gt;中根据&lt;code&gt;CSR_CAUSE&lt;&#x2F;code&gt;的值确定中断来源：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;switch &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(regs-&amp;gt;cause &amp;amp; ~CAUSE_IRQ_FLAG) {
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;case&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; RV_IRQ_TIMER:
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;riscv_timer_interrupt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;break&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#ifdef&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; CONFIG_SMP
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;case&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; RV_IRQ_SOFT:
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;*
		 * We only use software interrupts to pass IPIs, so if a non-SMP
		 * system gets one, then we don&amp;#39;t know what to do.
		 *&#x2F;
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;riscv_software_interrupt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;break&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#endif
	case&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; RV_IRQ_EXT:
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;handle_arch_irq&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(regs);
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;break&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;default&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;:
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pr_alert&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;unexpected interrupt cause 0x&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;%lx&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, regs-&amp;gt;cause);
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;BUG&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
	}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其中，&lt;code&gt;handle_arch_irq&lt;&#x2F;code&gt;是中断控制器驱动通过调用&lt;code&gt;set_handle_irq&lt;&#x2F;code&gt;注册的中断处理函数。Linux内核中对于RISC-V专门实现了对应的时钟源：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* called directly from the low-level interrupt handler *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;riscv_timer_interrupt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; clock_event_device *evdev = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this_cpu_ptr&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;riscv_clock_event);

	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;csr_clear&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(CSR_IE, IE_TIE);
	evdev-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;event_handler&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(evdev);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;而&lt;code&gt;riscv_software_interrupt&lt;&#x2F;code&gt;只用于处理IPI中断，有机会的话单独分析。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;xi-tong-diao-yong&quot;&gt;系统调用&lt;&#x2F;h3&gt;
&lt;p&gt;系统调用的实现非常简单，如果&lt;code&gt;handle_exception&lt;&#x2F;code&gt;判断进入异常的原因为系统调用，则会：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;检查系统调用号合法性&lt;&#x2F;li&gt;
&lt;li&gt;处理系统调用tracer&lt;&#x2F;li&gt;
&lt;li&gt;通过&lt;code&gt;sys_call_table&lt;&#x2F;code&gt;和系统调用号拿到系统调用的函数指针，并跳转执行&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;	li t1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;beq a7&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;t1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ret_from_syscall_rejected
	blt a7&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;t1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;1f
	&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Call syscall &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
	la s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;sys_call_table
	slli t0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;a7&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;RISCV_LGPTR
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;t0
	REG_L s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(s0)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;:
	jalr s0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;qi-ta-yi-chang&quot;&gt;其他异常&lt;&#x2F;h3&gt;
&lt;p&gt;除了系统调用和中断之外的异常处理通过&lt;code&gt;excp_vect_table&lt;&#x2F;code&gt;之中注册的函数指针完成：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;	&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Handle other exceptions &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
	slli t0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;s4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;RISCV_LGPTR
	la t1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;excp_vect_table
	la t2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;excp_vect_table_end
	move a0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;pt_regs &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;t0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;t1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;t0
	&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Check if exception code lies within bounds &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
	bgeu t0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;t2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;1f
	REG_L t0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(t0)
	jr t0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;</content>
	</entry>
	<entry xml:lang="en">
		<title>Linux内核在RISC-V架构下的构建与启动</title>
		<published>2020-07-25T00:00:00+00:00</published>
		<updated>2020-07-25T00:00:00+00:00</updated>
		<link href="https://crab2313.github.io/riscv-build-and-boot/" type="text/html"/>
		<id>https://crab2313.github.io/riscv-build-and-boot/</id>
		<content type="html">&lt;p&gt;本文分析RISC-V的linux移植是如何完成的，并给出具体的入手方法，希望对后来者有所启发。RISC-V是一个比较新的体系结构，截至目前已经完成了非特权级Spec和特权级Spec（不包含hypervisor）的修订，由于后发优势，加上设计得当，RISC-V的设计相当简洁易懂，是学习体系结构以及Linux内核的良好素材。借助RISC-V，我们可以通读与RISC-V体系结构相关的Linux内核代码，这在其他体系结构上对于初学者是很难做到的。&lt;&#x2F;p&gt;
&lt;p&gt;首先我们需要通读RISC-V的手册，两本加起来不到三百页，对于稍有基础的人来说可能只需要两天就能够读完。RISC-V的汇编语言也非常简洁，设计独到，简化了程序开发人员的许多工作，推荐目前正在施工的&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;riscv&#x2F;riscv-asm-manual&#x2F;blob&#x2F;master&#x2F;riscv-asm.md&quot;&gt;官方教程&lt;&#x2F;a&gt;。本文尽量假定读者不熟悉内核的一些tricks，会做适当说明，至少会给出对应关键字，用以查找学习。&lt;&#x2F;p&gt;
&lt;p&gt;体系结构相关代码一般放置于&lt;code&gt;arch&#x2F;${arch}&#x2F;&lt;&#x2F;code&gt;文件夹下，主要涉及内核中与体系结构相关的部分，每个文件夹下的内容只在特定的体系结构中使用。我们主要研究其中的如下部分：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;内核的构建&lt;&#x2F;li&gt;
&lt;li&gt;内核的启动&lt;&#x2F;li&gt;
&lt;li&gt;内核体系结构相关函数的实现&lt;&#x2F;li&gt;
&lt;li&gt;内存一致性模型的映射&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;nei-he-de-gou-jian&quot;&gt;内核的构建&lt;&#x2F;h2&gt;
&lt;p&gt;很多与内核相关的书中都没有具体提到内核是如何构建的，最多介绍一下内核的大致内存布局。这里我主要介绍一下内核构建的大致原理。这里涉及的大部分内容实质上为ELF格式、编译器、链接器以及装载器的原理。Linux内核实质上为一个巨大的二进制可执行文件，这个可执行文件的格式一般是不确定的，与体系结构有关。这个格式实质上是与bootloader的约定，bootloader可以检测并识别特定的内核格式，然后将其装载到内存中并执行。这个约定一般被明确写在&lt;code&gt;Documentation&#x2F;${arch}&#x2F;&lt;&#x2F;code&gt;下的某个文件中，被称作&lt;code&gt;Boot Protocol&lt;&#x2F;code&gt;，即启动协议。特化到RISC-V体系结构，这个格式为与ARM64体系结构相同的PE格式，该格式的一个显著优势是可以作为UEFI Executable由UEFI直接执行，即我们熟知的UEFI stub启动方式。&lt;&#x2F;p&gt;
&lt;p&gt;熟悉了上面的概念后，我们来看内核的&lt;code&gt;Makefile&lt;&#x2F;code&gt;是如何生成RISC-V下的内核的。首先找到最显眼的文件&lt;code&gt;arch&#x2F;riscv&#x2F;Makefile&lt;&#x2F;code&gt;，可以看到如下定义：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# Default target when executing plain make
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;boot            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;:= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;arch&#x2F;riscv&#x2F;boot
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;KBUILD_IMAGE    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;:= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;boot&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;Image.gz

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;...

ifeq (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;CONFIG_RISCV_M_MODE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;CONFIG_SOC_KENDRYTE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;,yy)
KBUILD_IMAGE &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;:= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;boot&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;loader.bin
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;else
KBUILD_IMAGE &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;boot&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;Image.gz
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;endif
BOOT_TARGETS &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;= Image Image.gz loader loader.bin

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;all&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;:    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;notdir &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;KBUILD_IMAGE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;))

$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;BOOT_TARGETS&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: vmlinux
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Q&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;MAKE&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;) $(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;build&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;boot&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;) $(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;boot&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$@
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        @&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kecho&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt; &amp;#39;  Kernel&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;boot&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;$@&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt; is ready&amp;#39;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;不难得出如下结论：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;在非勘智SOC（K210）下，默认执行make后生成的文件为&lt;code&gt;Image.gz&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;对于由&lt;code&gt;BOOT_TARGETS&lt;&#x2F;code&gt;中定义的几种镜像名称，可以在&lt;code&gt;arch&#x2F;riscv&#x2F;boot&lt;&#x2F;code&gt;下的&lt;code&gt;Makefile&lt;&#x2F;code&gt;中找到生成方式&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;我们现在就来看&lt;code&gt;Image&lt;&#x2F;code&gt;是如何生成的：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;OBJCOPYFLAGS_Image &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;=-O binary -R .note -R .note.gnu.build-id -R .comment -S

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;obj&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;Image&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;vmlinux FORCE
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;call &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;if_changed&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,objcopy&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)

$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;obj&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;Image.gz&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;obj&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;Image FORCE
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;$(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;call &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;if_changed&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,gzip&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到&lt;code&gt;Image&lt;&#x2F;code&gt;实质上就是由vmlinux通过&lt;code&gt;objcopy -O binary&lt;&#x2F;code&gt;生成的binary格式。具有嵌入式开发经验的人对这个操作会比较熟悉，binary格式实质上就是ELF装载到内存后的内存dump，即以ELF起始装载地址指向的物理地址为起始地址的整片内存区域转储。而这样就比较有趣了，看到这里你一定能猜出&lt;code&gt;vmlinux&lt;&#x2F;code&gt;用了什么特殊手段将其内存布局安排的明明白白，使其通过objcopy后，可以得到一个PE格式的可执行程序。这个手段就是&lt;strong&gt;链接脚本&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;关于链接脚本的解读就不赘述了，建议通读&lt;code&gt;GNU ld&lt;&#x2F;code&gt;的文档。我们可以在&lt;code&gt;arch&lt;&#x2F;code&gt;文件夹下找到生成链接脚本的模板文件：&lt;code&gt;arch&#x2F;riscv&#x2F;kernel&#x2F;vmlinux.ld.S&lt;&#x2F;code&gt;。之所以称其为模板文件，是因为这个文件通过C语言的预处理后，可以生成最终的链接脚本&lt;code&gt;vmlinux.ld&lt;&#x2F;code&gt;。脚本的内容比较简单，我们先来看前几行：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;OUTPUT_ARCH(riscv)
ENTRY(_start)

jiffies = jiffies_64&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这几行比较常规，可以知道：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;输出的ELF为riscv体系结构&lt;&#x2F;li&gt;
&lt;li&gt;输出的ELF的entry point为&lt;code&gt;_start&lt;&#x2F;code&gt;符号的地址&lt;&#x2F;li&gt;
&lt;li&gt;符号&lt;code&gt;jiffies&lt;&#x2F;code&gt;与&lt;code&gt;jiffies_64&lt;&#x2F;code&gt;共用一个地址。这里可以参考其它文档中对于时间子系统的描述，这个trick可以让我们在内核中通过&lt;code&gt;jiffies&lt;&#x2F;code&gt;变量访问&lt;code&gt;jiffies_64&lt;&#x2F;code&gt;变量的低32位。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;接下来就是最关键的部分：&lt;code&gt;SECTIONS&lt;&#x2F;code&gt;定义，它能精确控制链接器的行为，按照你的需求合并section，并控制内存布局。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;LOAD_OFFSET PAGE_OFFSET
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#include &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;asm&#x2F;vmlinux.lds.h&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;

...

SECTIONS
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Beginning of code and text segment *&#x2F;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;. = LOAD_OFFSET;
        _start = .;
        HEAD_TEXT_SECTION
        . = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ALIGN&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(PAGE_SIZE);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到，整个内存的布局由&lt;code&gt;LOAD_OFFSET&lt;&#x2F;code&gt;，即&lt;code&gt;PAGE_OFFSET&lt;&#x2F;code&gt;地址开始，而&lt;code&gt;PAGE_OFFSET&lt;&#x2F;code&gt;大部分书中都有所涉及，这里不再提它是什么。我们可以看到&lt;code&gt;_start&lt;&#x2F;code&gt;符号的地址被定义为&lt;code&gt;PAGE_OFFSET&lt;&#x2F;code&gt;，即vmlinux虚拟地址空间的最开头，这也是其名字的由来，在内核中可以通过&lt;code&gt;&amp;amp;_start&lt;&#x2F;code&gt;获取其地址。&lt;&#x2F;p&gt;
&lt;p&gt;如果对ELF格式有一定理解，这一段可以跳过不看。这里&lt;code&gt;SECTIONS&lt;&#x2F;code&gt;中定义的是虚拟内存的布局，事实上ELF格式中是严格区分物理地址（在链接器的定义中称为装载地址&lt;code&gt;LMA&lt;&#x2F;code&gt;）和虚拟地址的，这一点要铭记。在大多数情况下，这两个地址是相同的，但由于内核会将其位于的物理地址通过页表映射到PAGE_OFFSET上位置（不是绝对，有偏移量随机化实现），所以需要严格区分这两种情况。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* Section used for early init (in .S files) *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;HEAD_TEXT  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;KEEP&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(*(.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;head&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;text&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;))

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;HEAD_TEXT_SECTION                                                       \
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;head&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;text &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;AT&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ADDR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;head&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;text&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) - LOAD_OFFSET) {               \
                HEAD_TEXT                                               \
        }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;HEAD_TEXT_SECTION&lt;&#x2F;code&gt;定义如上，很简单，即将所有&lt;code&gt;.o&lt;&#x2F;code&gt;文件名为&lt;code&gt;.head.text&lt;&#x2F;code&gt;的section合并成vmlinux名为&lt;code&gt;.head.text&lt;&#x2F;code&gt;的section。这里注意两个trick：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;链接脚本中可以通过AT属性指定section的装载地址，这里可以看到&lt;code&gt;.head.text&lt;&#x2F;code&gt;的装载地址是0x0&lt;&#x2F;li&gt;
&lt;li&gt;链接器需要对最终生成的ELF进行优化，有可能会删除section没有被应用的符号，这里使用KEEP阻止链接器进行这个操作&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;很明显这个名为&lt;code&gt;.head.text&lt;&#x2F;code&gt;的section就是objcopy后得到的&lt;code&gt;Image&lt;&#x2F;code&gt;镜像的开头部分。我们已经知道了&lt;code&gt;Image&lt;&#x2F;code&gt;是一个PE兼容的镜像，所以这里一定定义了PE header。这里稍微有一点经验的人即可猜到&lt;code&gt;.head.text&lt;&#x2F;code&gt;是定义在&lt;code&gt;head.S&lt;&#x2F;code&gt;文件中的，这也是其名字的由来。对于内核内的汇编代码文件，&lt;code&gt;linux&#x2F;init.h&lt;&#x2F;code&gt;中定义了多个helper，用以简化section的定义：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* For assembly routines *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__HEAD          .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;section        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.head.text&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ax&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__INIT          .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;section        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.init.text&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ax&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__FINIT         .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;previous

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__INITDATA      .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;section        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.init.data&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;aw&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,%progbits
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__INITRODATA    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;section        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.init.rodata&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;,%progbits
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__FINITDATA     .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;previous

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__MEMINIT        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;section       &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.meminit.text&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ax&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__MEMINITDATA    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;section       &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.meminit.data&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;aw&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;__MEMINITRODATA  .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;section       &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.meminit.rodata&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;接着我们在&lt;code&gt;arch&#x2F;riscv&#x2F;kernel&#x2F;head.S&lt;&#x2F;code&gt;文件中看到这个section的定义：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__HEAD
ENTRY(_start)
        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*
         * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Image header expected by Linux boot&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;loaders. The image header data
         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;structure is described &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;asm&#x2F;image.h.
         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;Do &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;not &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;modify it without modifying the structure &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;and &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;all bootloaders
         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;th&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;at &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;expects this header form&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;at&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;!!
         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;jump to start kernel &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        j _start_kernel
        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;reserved &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;word &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.balign &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;#if __riscv_xlen == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;64
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Image load offset(2MB) from start of RAM &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dword &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x200000
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;#else
        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Image load offset(4MB) from start of RAM &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dword &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x400000
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;#endif
        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Effective size of kernel image &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dword &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;_end &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;_start
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dword &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__HEAD_FLAGS
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;word &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;RISCV_HEADER_VERSION
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;word &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dword &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.ascii RISCV_IMAGE_MAGIC
        .balign &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.ascii RISCV_IMAGE_MAGIC2
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;word &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到该section开头即为精心构建的PE header。至此，内核的构建方式已经比较明了，即利用链接脚本，精心设置整个vmlinux文件的布局，将&lt;code&gt;.head.text&lt;&#x2F;code&gt;放置到最前，并在其开头填充PE header，最后用objcopy导出这个带有PE header的二进制&lt;code&gt;Image&lt;&#x2F;code&gt;镜像。原理非常简单，但是其中涉及的技术比较非常规，对应用层开发人员来说并不常见。总的来说，其构建过程&lt;strong&gt;与ARM64基本一致&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;nei-he-qi-dong&quot;&gt;内核启动&lt;&#x2F;h2&gt;
&lt;p&gt;前面的分析其实已经起了个头，按照前面提到的，我们可以找到RISC-V架构的启动协议&lt;code&gt;Documentation&#x2F;riscv&#x2F;boot-image-header.txt&lt;&#x2F;code&gt;。事实上这个文件只是简单介绍了一下&lt;code&gt;Image&lt;&#x2F;code&gt;文件header的结构，更详细的启动协议还是处于TODO状态，我们需要从代码进行分析。前面提到RISC-V内核比较类似于ARM64内核的格式，如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        u32 code0;                &#x2F;* Executable code *&#x2F;
        u32 code1;                &#x2F;* Executable code *&#x2F;
        u64 text_offset;          &#x2F;* Image load offset, little endian *&#x2F;
        u64 image_size;           &#x2F;* Effective Image size, little endian *&#x2F;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;从bootloader的角度，装载并执行&lt;code&gt;Image&lt;&#x2F;code&gt;类型的内核只需要做两件事情：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;将整个&lt;code&gt;Image&lt;&#x2F;code&gt;文件放置到内存起始处向后偏移&lt;code&gt;text_offset&lt;&#x2F;code&gt;的内存地址&lt;&#x2F;li&gt;
&lt;li&gt;跳转到&lt;code&gt;code0&lt;&#x2F;code&gt;的地址进行执行&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;后续的事情，内核自理。我们看到&lt;code&gt;head.S&lt;&#x2F;code&gt;中有如下代码：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ENTRY(_start)
        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*
         * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Image header expected by Linux boot&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;loaders. The image header data
         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;structure is described &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;asm&#x2F;image.h.
         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;Do &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;not &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;modify it without modifying the structure &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;and &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;all bootloaders
         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;th&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;at &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;expects this header form&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;at&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;!!
         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;jump to start kernel &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        j _start_kernel
        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;reserved &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;很明显&lt;code&gt;code0&lt;&#x2F;code&gt;和&lt;code&gt;code1&lt;&#x2F;code&gt;放置的就是&lt;code&gt;j _start_kernel&lt;&#x2F;code&gt;生成的指令。那么我们就需要从&lt;code&gt;_start_kernel&lt;&#x2F;code&gt;开始看起。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;start-kernel&quot;&gt;_start_kernel&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;_start_kernel&lt;&#x2F;code&gt;可以看到，一开始主要做了三件事：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;关闭所有的中断&lt;&#x2F;li&gt;
&lt;li&gt;设置gp寄存器指向对应的地址（该寄存器为ABI相关，用于存放&lt;code&gt;__global_pointer$&lt;&#x2F;code&gt;的地址，即GOT的位置，可以参考&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;riscv&#x2F;riscv-elf-psabi-doc&#x2F;blob&#x2F;master&#x2F;riscv-elf.md&quot;&gt;RISCV调用协定&lt;&#x2F;a&gt;）&lt;&#x2F;li&gt;
&lt;li&gt;关闭FPU，内核中是不用任何浮点指令的&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;我们可以看到一个名为&lt;code&gt;CONFIG_RISCV_M_MODE&lt;&#x2F;code&gt;的内核配置，该选项启用时，内核默认自己从&lt;code&gt;Machine&lt;&#x2F;code&gt;特权级启动。该选项用于内核支持K210 SoC，我们默认该选项没有开启。这里注意，bootloader将控制权交给内核时，&lt;code&gt;a0&lt;&#x2F;code&gt;寄存器保存的值即为当前CPU执行单元的ID（RISC-V中称为HART ID）。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;_start_kernel&lt;&#x2F;code&gt;接下来就开始执行一个简单的&lt;code&gt;Boot Protocol&lt;&#x2F;code&gt;，选出一个用于启动内核的CPU，其他CPU进入等待状态。RISC-V处理器在reset之后，所有的处理单元（HART）都会一起开始执行，而Linux内核启动时为主从模型，因此需要挑选出其中一个完成部分内核启动工作，之后告知其他的处理器继续执行开始处理任务。首先确定CPU ID是否合法，即有没有超出内核编译时选择的最大支持CPU数，如果超过则非法：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;#ifdef CONFIG_SMP
        li t0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;CONFIG_NR_CPUS
        blt a0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;t0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.Lgood_cores
        tail .Lsecondary_park
.Lgood_cores:
#endif
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;.Lsecondary_park&lt;&#x2F;code&gt;分支实质上是循环调用&lt;code&gt;wfi&lt;&#x2F;code&gt;指令。接下来内核使用一个简单的策略选出用于启动的主CPU：先到先得。&lt;code&gt;setup.c&lt;&#x2F;code&gt;中定义了一个原子变量：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;atomic_t hart_lottery &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;__section&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sdata&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;经过codepath的所有CPU都会试图通过原子操作将这个变量加1。RISC-V的原子操作指令会将原子变量的原有值保存在原子变量的目标寄存器中，也就是说，如果操作后目标寄存器的值为0的CPU为第一对其进行操作的CPU。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Pick one hart to run the main boot sequence &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        la a3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;hart_lottery
        li a2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;amoadd.w a3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;a2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(a3)
        bnez a3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.Lsecondary_start
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;对于所有竞争失败的CPU，我们在后面进行分析，目前还是顺着主CPU进行分析。随后主CPU的操作基本如下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;清空bss段，写为0&lt;&#x2F;li&gt;
&lt;li&gt;设置临时内核栈与&lt;code&gt;task_struct&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;依次调用&lt;code&gt;setup_vm&lt;&#x2F;code&gt;以及&lt;code&gt;relocate&lt;&#x2F;code&gt;设置内核的虚拟内存&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;最后调用C语言通用代码启动内核：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Start the kernel &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;call &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;soc_early_init
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;call &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;parse_dtb
        tail start_kernel
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;setup-vmyu-relocate&quot;&gt;setup_vm与relocate&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;setup_vm&lt;&#x2F;code&gt;函数位于&lt;code&gt;arch&#x2F;riscv&#x2F;mm&#x2F;init.c&lt;&#x2F;code&gt;中，其目的是设置一个最小的页表，让内核开启&lt;code&gt;MMU&lt;&#x2F;code&gt;并工作在虚拟内存之下，为后续的内存初始化做准备。注意&lt;code&gt;setup_vm&lt;&#x2F;code&gt;在被调用时很明显是没有设置好页表的，也就是说&lt;code&gt;setup_vm&lt;&#x2F;code&gt;函数生成汇编时的引用必须为&lt;code&gt;PC-relative&lt;&#x2F;code&gt;的，由于目前内核在RISC-V体系结构下全局使用&lt;code&gt;-cmodel=medany&lt;&#x2F;code&gt;进行编译，因此这一点是满足的。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;setup_vm&lt;&#x2F;code&gt;函数执行的操作在各个体系结构中没有本质区别，都为设置一个最简单的页表，将内核所在的物理地址映射到PAGE_OFFSET所在虚拟地址区域（即将内核二进制所在的物理地址加上一个PAGE_OFFSET减去_start所的的偏移量）。因此，这里的任务实质上是建立一个临时页表，即内核临时的虚拟地址空间映射，：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;MAX_EARLY_MAPPING_SIZE	SZ_128M

pgd_t early_pg_dir[PTRS_PER_PGD] __initdata &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__aligned&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(PAGE_SIZE);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;来挖细节，确定这个临时页表里初始化了哪些东西。首先明确一点，RISC-V支持多种页表结构，我们只分析64位的Sv39，目前内核在RISC-V 64位下就支持这一种模式。随后应该想到，setup_vm的运行环境里并没有初始化任何内存，因此必须静态定义一些变量，预留出一些内存供我们使用。先看&lt;code&gt;setup_vm&lt;&#x2F;code&gt;里用到的两个helper函数：&lt;code&gt;create_pgd_mapping&lt;&#x2F;code&gt; &amp;amp;&amp;amp; &lt;code&gt;create_pmd_mapping&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;当前在RISC-V下的内核并不支持四级页表，那么自然没有PUD。&lt;code&gt;early_pmd&lt;&#x2F;code&gt;数组用于满足在MMU还没有开启时存放PMD表的需求：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#if&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; MAX_EARLY_MAPPING_SIZE &amp;lt; PGDIR_SIZE
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;NUM_EARLY_PMDS		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;UL
#else
#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;NUM_EARLY_PMDS		(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;UL &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;+ MAX_EARLY_MAPPING_SIZE &#x2F; PGDIR_SIZE)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#endif
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;pmd_t early_pmd[PTRS_PER_PMD * NUM_EARLY_PMDS] __initdata &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__aligned&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(PAGE_SIZE);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在64位下，&lt;code&gt;NUM_EARLY_PMDS&lt;&#x2F;code&gt;始终为1。可以通过&lt;code&gt;alloc_pmd&lt;&#x2F;code&gt;函数申请一个PMD表：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; phys_addr_t __init &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;alloc_pmd&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(uintptr_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;va&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
	uintptr_t pmd_num;

	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(mmu_enabled)
		&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;memblock_phys_alloc&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(PAGE_SIZE, PAGE_SIZE);

	pmd_num = (va - PAGE_OFFSET) &amp;gt;&amp;gt; PGDIR_SHIFT;
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;BUG_ON&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(pmd_num &amp;gt;= NUM_EARLY_PMDS);
	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(uintptr_t)&amp;amp;early_pmd[pmd_num * PTRS_PER_PMD];
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里能很明显看到，在MMU使能之前使用&lt;code&gt;early_pmd&lt;&#x2F;code&gt;的空间，而使能之后则使用memblock中分配的内存。&lt;code&gt;create_pgd_mapping&lt;&#x2F;code&gt;函数原型如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; __init &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;create_pgd_mapping&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(pgd_t *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pgdp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
				      uintptr_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;va&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, phys_addr_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pa&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;,
				      phys_addr_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sz&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, pgprot_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;prot&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里仔细看实现，不要误解了&lt;code&gt;va&lt;&#x2F;code&gt;和&lt;code&gt;pa&lt;&#x2F;code&gt;的意思。va是你想进行映射的&lt;strong&gt;虚拟地址&lt;&#x2F;strong&gt;，&lt;code&gt;pa&lt;&#x2F;code&gt;是你要往PGD中给这个虚拟地址对应的表项存放的&lt;strong&gt;下一级页表&lt;&#x2F;strong&gt;的&lt;strong&gt;物理地址&lt;&#x2F;strong&gt;。&lt;code&gt;sz&lt;&#x2F;code&gt;是你要映射的内存区域的大小，必须小于&lt;code&gt;PGDIR_SIZE&lt;&#x2F;code&gt;，可以为下面一级表项可以映射内存区域的长度。如果&lt;code&gt;create_pgd_mapping&lt;&#x2F;code&gt;函数发现&lt;code&gt;sz&lt;&#x2F;code&gt;小于&lt;code&gt;PGDIR_SIZE&lt;&#x2F;code&gt;，则会递归的创建更下一级的页表。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;early_pg_dir&lt;&#x2F;code&gt;页表内包含两类映射：内核和FIXMAP。其中内核映射是将内核自身处于的连续物理内存区域映射到位于&lt;code&gt;PAGE_OFFSET&lt;&#x2F;code&gt;的虚拟内存地址上。而FIXMAP映射并没有映射全部的FIXMAP，而是仅仅影射了FIX_FDT部分，让后续的代码可以访问设备树。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;setup_vm&lt;&#x2F;code&gt;并不是仅仅只创建了一个&lt;code&gt;early_pg_dir&lt;&#x2F;code&gt;页表，还创建了&lt;code&gt;trampoline_pg_dir&lt;&#x2F;code&gt;页表。这个页表将&lt;code&gt;PAGE_OFFSET&lt;&#x2F;code&gt;后长为&lt;code&gt;PMD_SIZE&lt;&#x2F;code&gt;的区域映射到&lt;code&gt;load_pa&lt;&#x2F;code&gt;，即内核起始被装载后的起始物理内存地址。&lt;code&gt;trampoline_pg_dir&lt;&#x2F;code&gt;页表的作用我们随后就会看到。&lt;&#x2F;p&gt;
&lt;p&gt;分析完&lt;code&gt;setup_vm&lt;&#x2F;code&gt;函数后，又回到汇编代码中，这次来看relocate函数。函数只有一个参数&lt;code&gt;a0&lt;&#x2F;code&gt;寄存器，用于传递一个页表的物理地址。这个&lt;code&gt;relocate&lt;&#x2F;code&gt;函数原理听着很简单，但是真到自己写的时侯则是满满的细节。首先我们知道我们要在该函数中开启MMU，这就说明调用函数时保存的&lt;code&gt;ra&lt;&#x2F;code&gt;寄存器，即函数返回地址中的地址已经失效，需要将其修改为对应的虚拟地址。这个原理比较简单，首先通过PC相对寻址得到&lt;code&gt;_start&lt;&#x2F;code&gt;的物理地址，然后将其与&lt;code&gt;PAGE_OFFSET&lt;&#x2F;code&gt;相减，即得到物理地址与虚拟地址的偏移量。&lt;&#x2F;p&gt;
&lt;p&gt;接下来就到前面设置的&lt;code&gt;trampoline_pg_dir&lt;&#x2F;code&gt;上场的时间了，我们需要借助&lt;code&gt;trampoline&lt;&#x2F;code&gt;页表通过中断向量的方式从物理地址跳转到虚拟地址，原理如下：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;首先将中断向量设置到&lt;code&gt;relocate&lt;&#x2F;code&gt;函数的后半段需要跳转的地方&lt;&#x2F;li&gt;
&lt;li&gt;然后将&lt;code&gt;trampoline_pg_dir&lt;&#x2F;code&gt;的地址设置到STVEC寄存器，设置完成MMU被启用，这使得访问原有物理地址时触发异常并跳转到中断向量&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;事实上，这个&lt;code&gt;trampoline&lt;&#x2F;code&gt;是多余的，我不知道上游为什么不删除它，也许是因为CPU热插拔支持的缘故。&lt;code&gt;relocate&lt;&#x2F;code&gt;最终会装载&lt;code&gt;early_pg_dir&lt;&#x2F;code&gt;页表，此时内核已经位于正确的虚拟地址空间上。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;lin-shi-nei-he-zhan-yu-task-struct&quot;&gt;临时内核栈与task_struct&lt;&#x2F;h3&gt;
&lt;p&gt;回到&lt;code&gt;_start_kernel&lt;&#x2F;code&gt;，当&lt;code&gt;relocate&lt;&#x2F;code&gt;执行完毕之后，内核需要初始化一个内核线程的运行环境。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Initialize page tables &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;and &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;relocate to virtual addresses &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&#x2F;
        la &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;init_thread_union &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;THREAD_SIZE
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里init_thread_union是通过链接脚本留出的一个PAGE（riscv平台上为4KB）大小的区域，用以充当临时内核栈。随后程序按照riscv的C程序调用协定保存两个Caller需要保存的寄存器，即：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;a0：当前hart（Hardware Thread，即RISCV术语中的最小执行单元，即一个逻辑CPU）的id&lt;&#x2F;li&gt;
&lt;li&gt;a1：指向设备树的指针&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这两个参数都是bootloader传进来的。到达这一步之后，内核调用setup_vm()函数，设置一个基本的页表，进而为后续打开分页机制做准备。&lt;&#x2F;p&gt;
&lt;p&gt;进入内核C语言环境的最后一个步骤是设置&lt;code&gt;tp&lt;&#x2F;code&gt;寄存器。我们知道内核初始化时，自身运行的上下文为init_task，即内核的第一个任务（&lt;code&gt;init&#x2F;init_task.c&lt;&#x2F;code&gt;）。该task_struct是静态初始化的，因此我们唯一需要做得就是修改当前CPU的运行上下文，使其认为他当前是在运行init_task任务。内核的进程上下文切换是一个及其架构相关的操作，我们来看看riscv平台是如果进行这个操作的。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        la tp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;init_task
        sw s0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TASK_TI_&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;CPU&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(tp) # 将当前&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;CPU &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ID表存在task_struct中
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果读过riscv的C语言调用约定一定会知道tp寄存器的存在，事实上文档中并没有写的较为详细。但是现在我们在这里看到在Supervisor模式下的用途：保存当前CPU运行的进程上下文，即&lt;code&gt;task_struct&lt;&#x2F;code&gt;结构体。查看&lt;code&gt;asm&#x2F;current.h&lt;&#x2F;code&gt;也可以发现这一事实：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;create_pte_mappingstatic __always_inline &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; task_struct *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;get_current&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;)
{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;register struct&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; task_struct *tp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;__asm__&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;tp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;);
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; tp;
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;</content>
	</entry>
</feed>
