<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>MESA源码分析：VC4驱动 - 编译器实现 - crab2313's blog</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="crab2313"><meta name=description content="这里先笼统的概括一下编译器部分的工作原理，细节后面再探讨。整个vc4的编译器后端一共进行了两次转换，多级优化，并实现了shader cache"><meta name=keywords content="blog,kernel"><meta name=generator content="Hugo 0.109.0 with theme even"><link rel=canonical href=/post/mesa-vc4-compiler/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="MESA源码分析：VC4驱动 - 编译器实现"><meta property="og:description" content="这里先笼统的概括一下编译器部分的工作原理，细节后面再探讨。整个vc4的编译器后端一共进行了两次转换，多级优化，并实现了shader cache"><meta property="og:type" content="article"><meta property="og:url" content="/post/mesa-vc4-compiler/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-01-07T00:00:00+00:00"><meta property="article:modified_time" content="2023-01-10T09:56:16+08:00"><meta itemprop=name content="MESA源码分析：VC4驱动 - 编译器实现"><meta itemprop=description content="这里先笼统的概括一下编译器部分的工作原理，细节后面再探讨。整个vc4的编译器后端一共进行了两次转换，多级优化，并实现了shader cache"><meta itemprop=datePublished content="2023-01-07T00:00:00+00:00"><meta itemprop=dateModified content="2023-01-10T09:56:16+08:00"><meta itemprop=wordCount content="12267"><meta itemprop=keywords content="mesa,gallium3d,vc4,"><meta name=twitter:card content="summary"><meta name=twitter:title content="MESA源码分析：VC4驱动 - 编译器实现"><meta name=twitter:description content="这里先笼统的概括一下编译器部分的工作原理，细节后面再探讨。整个vc4的编译器后端一共进行了两次转换，多级优化，并实现了shader cache"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>crab2313's blog</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>crab2313's blog</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>MESA源码分析：VC4驱动 - 编译器实现</h1><div class=post-meta><span class=post-time>2023-01-07</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#qir>QIR</a></li><li><a href=#nir转换为qir>NIR转换为QIR</a></li><li><a href=#寄存器分配器>寄存器分配器</a><ul><li><a href=#寄存器集合构建>寄存器集合构建</a></li><li><a href=#冲突图构建>冲突图构建</a></li></ul></li><li><a href=#指令构造器>指令构造器</a></li><li><a href=#code-emitter>Code Emitter</a><ul><li><a href=#queue>Queue</a></li><li><a href=#vc4_generate_code_block>vc4_generate_code_block</a></li><li><a href=#vpm>VPM</a></li><li><a href=#vc4_generate_code>vc4_generate_code</a></li></ul></li><li><a href=#指令调度器>指令调度器</a><ul><li><a href=#基本设计>基本设计</a></li><li><a href=#dag构建>DAG构建</a><ul><li><a href=#raddr依赖计算>raddr依赖计算</a></li><li><a href=#waddr依赖计算>waddr依赖计算</a></li><li><a href=#mux依赖计算>MUX依赖计算</a></li><li><a href=#condition依赖计算>Condition依赖计算</a></li><li><a href=#延迟计算>延迟计算</a></li></ul></li><li><a href=#指令调度>指令调度</a></li></ul></li><li><a href=#mesa接口>Mesa接口</a></li></ul></nav></div></div><div class=post-content><p>这里先笼统的概括一下编译器部分的工作原理，细节后面再探讨。整个vc4的编译器后端一共进行了两次转换，多级优化，并实现了shader cache。从代码中可以发现，对一个shader编译是非常昂贵的操作，挑选特定的关键字（即shader的特征状态），根据关键字确定一个shader的唯一性，从而实现cache shader的操作，能极大的减少shader的编译次数，提升总体性能和帧率稳定性。这里列举一下想要进行分析的后端功能点：</p><ul><li>多级转换，最终生成shader二进制指令</li><li>shader cache的工作原理</li><li>多级优化（lowering）的实现原理</li></ul><p>对于多级转换，实际上进行了如下几个转换操作：</p><ul><li>NIR转换成QIR。NIR是目前Mesa主流的IR，是Mesa的GLSL编译器生成TGSI中间表示后，一般要转换而成的中间表示。以前的Mesa驱动一般直接处理TGSI，而现在的Mesa驱动一般将TGSI通过共用功能模块转换成NIR后进行处理。NIR是一种比较便于优化的SSA表示方法。而QIR则是vc4根据自身的QPU特性设计出来的IR表示，这一转换阶段则直接将优化过的NIR转换为QIR表示。</li><li>QIR转换成二进制表示。vc4中实现了code emitter，通过读取QIR，而emit出最终的二进制指令。整个emit过程基本是按照相应的模板进行翻译操作。最后通过优化的方式将ALU A和ALU M相关的操作整合到一起，形成最终的二进制程序。</li></ul><h1 id=qir>QIR</h1><p>QIR是vc4编译器后端的IR表示。NIR经过几轮优化之后，转换成QIR，进一步通过code emitter生成最终的shader指令程序。QIR的指令使用<code>qinst</code>表示，可以看到qinst提供了list_head用于串到一个链表上，且提供了一个op，表示操作类型，并存在source operand和dest operand，以及多个flag。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>qinst</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>list_head</span> <span class=n>link</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>enum</span> <span class=n>qop</span> <span class=n>op</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>qreg</span> <span class=n>dst</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>qreg</span> <span class=n>src</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=n>sf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=n>cond_is_exec_mask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint8_t</span> <span class=n>cond</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>operand的类型为<code>struct qreg</code>，本质上是寄存器，至于为什么这么抽象，是因为QPU本质上不支持MMIO，而是只支持register mapped I/O。也就是I/O实际上是通过读取累加器或者寄存器实现的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>qreg</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>enum</span> <span class=n>qfile</span> <span class=n>file</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint32_t</span> <span class=n>index</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>pack</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p><code>struct qreg</code>中使用qfile字段表示寄存器位于的存储区域，举上几个例子：</p><ul><li>使用TEMP类型标志临时的寄存器类型</li><li>使用VARY表示从VARYING差值硬件中读取出来的数据</li><li>使用UNIF表示从UNIFORM变量中读取出来的类型</li><li>使用VPM表示存VPM存储区域中读取出来的数据</li></ul><p>除此之外，还有很多类型，这里不一一列举。对于临时寄存器，<code>qir_get_temp</code>函数负责申请一个这样的临时寄存器。<code>vc4_compile</code>中记录的所有的临时寄存器的申请指令，使得我们可以根据临时寄存器快速定位到申请这个临时寄存器的指令。最后一提，这个映射关系存储在<code>vc4_compile->defs</code>数组中。在这里可以看出，vc4_compile本质上就是记录QIR编译结果的结构体。</p><p>所有的指令生成操作从概念上是像一个<code>vc4_compile</code>中的特定block添加一个指令，即emit。emit类型的操作实际上使用类似<code>qir_&lt;OP-NAME></code>这个的函数名称，通过特定的模板生成而来，如<code>QIR_ALU0</code>和<code>QIR_ALU1</code>等，具体可以参考源码。这里只以其中一个举例其原理，<code>QIR_ALU1</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define QIR_ALU1(name)                                                   \
</span></span></span><span class=line><span class=cl><span class=cp>static inline struct qreg                                                \
</span></span></span><span class=line><span class=cl><span class=cp>qir_##name(struct vc4_compile *c, struct qreg a)                         \
</span></span></span><span class=line><span class=cl><span class=cp>{                                                                        \
</span></span></span><span class=line><span class=cl><span class=cp>        return qir_emit_def(c, qir_inst(QOP_##name, c-&gt;undef,            \
</span></span></span><span class=line><span class=cl><span class=cp>                                        a, c-&gt;undef));                   \
</span></span></span><span class=line><span class=cl><span class=cp>}                                                                        \
</span></span></span><span class=line><span class=cl><span class=cp>static inline struct qinst *                                             \
</span></span></span><span class=line><span class=cl><span class=cp>qir_##name##_dest(struct vc4_compile *c, struct qreg dest,               \
</span></span></span><span class=line><span class=cl><span class=cp>                  struct qreg a)                                         \
</span></span></span><span class=line><span class=cl><span class=cp>{                                                                        \
</span></span></span><span class=line><span class=cl><span class=cp>        return qir_emit_nondef(c, qir_inst(QOP_##name, dest, a,          \
</span></span></span><span class=line><span class=cl><span class=cp>                                           c-&gt;undef));                   \
</span></span></span><span class=line><span class=cl><span class=cp>}
</span></span></span></code></pre></td></tr></table></div></div><p>先明白<code>qir_emit_def</code>和<code>qir_emit_nodef</code>的区别：上面看到对于新的TEMP寄存器，需要定义他的指令的地址，这个记录通过<code>vc4_compile->defs</code>数组进行记录。所以<code>qir_emit_def</code>就很好理解，这里的<code>_def</code>后缀指添加的这条指令定义了一个新的TEMP寄存器变量。具有dest的指令不需要定义一个新的TEMP寄存器，因为他已经有操作的destination了，而不需要重新定义一个。这里的<code>QIR_ALU1</code>是指有一个source operand的ALU指令。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>qir_emit</span><span class=p>(</span><span class=k>struct</span> <span class=n>vc4_compile</span> <span class=o>*</span><span class=n>c</span><span class=p>,</span> <span class=k>struct</span> <span class=n>qinst</span> <span class=o>*</span><span class=n>inst</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>list_addtail</span><span class=p>(</span><span class=o>&amp;</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>link</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>cur_block</span><span class=o>-&gt;</span><span class=n>instructions</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Updates inst to write to a new temporary, emits it, and notes the def. */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>qreg</span>
</span></span><span class=line><span class=cl><span class=nf>qir_emit_def</span><span class=p>(</span><span class=k>struct</span> <span class=n>vc4_compile</span> <span class=o>*</span><span class=n>c</span><span class=p>,</span> <span class=k>struct</span> <span class=n>qinst</span> <span class=o>*</span><span class=n>inst</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>assert</span><span class=p>(</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>dst</span><span class=p>.</span><span class=n>file</span> <span class=o>==</span> <span class=n>QFILE_NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>inst</span><span class=o>-&gt;</span><span class=n>dst</span> <span class=o>=</span> <span class=nf>qir_get_temp</span><span class=p>(</span><span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>dst</span><span class=p>.</span><span class=n>file</span> <span class=o>==</span> <span class=n>QFILE_TEMP</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>c</span><span class=o>-&gt;</span><span class=n>defs</span><span class=p>[</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>dst</span><span class=p>.</span><span class=n>index</span><span class=p>]</span> <span class=o>=</span> <span class=n>inst</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>qir_emit</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>inst</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>inst</span><span class=o>-&gt;</span><span class=n>dst</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>qreg</span>
</span></span><span class=line><span class=cl><span class=nf>qir_get_temp</span><span class=p>(</span><span class=k>struct</span> <span class=n>vc4_compile</span> <span class=o>*</span><span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>qreg</span> <span class=n>reg</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>reg</span><span class=p>.</span><span class=n>file</span> <span class=o>=</span> <span class=n>QFILE_TEMP</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span><span class=p>.</span><span class=n>index</span> <span class=o>=</span> <span class=n>c</span><span class=o>-&gt;</span><span class=n>num_temps</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span><span class=p>.</span><span class=n>pack</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    	<span class=c1>// .......
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>reg</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>从commit信息中可以看到QIR是一个基于SSA的通用IR。上面也看到SSA的特有结构，即TEMP寄存器，后面会分析PHI节点是如何实现的。但是SSA的另一个特征是通过block（或者准确来说basic block）组织的，下面来分析QIR中这一部分怎么实现。</p><p>QIR中，使用<code>struct qblock</code>来表示一个block，这个结构体的内容比较零散，目前我们只需要知道：</p><ul><li>每一个block创建的时候会有一个唯一的整数index</li><li>block中存在instructions链表用于保存block中的指令</li><li>QIR中使用<code>qir_new_block</code>创建并添加一个新的block</li><li><code>vc4_compile</code>存在blocks字段记录这个编译结果中所有的blocks，并使用<code>cur_block</code>指针指向当前添加指令时的目标block</li></ul><h1 id=nir转换为qir>NIR转换为QIR</h1><p>经过优化后的NIR通过<code>nir_to_qir</code>函数转换为QIR。</p><p>NIR在经过各种优化之后，在<code>vc4_shader_ntq</code>函数中调用<code>nir_to_qir</code>转换成QIR。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>nir_to_qir</span><span class=p>(</span><span class=k>struct</span> <span class=n>vc4_compile</span> <span class=o>*</span><span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>stage</span> <span class=o>==</span> <span class=n>QSTAGE_FRAG</span> <span class=o>&amp;&amp;</span> <span class=n>c</span><span class=o>-&gt;</span><span class=n>s</span><span class=o>-&gt;</span><span class=n>info</span><span class=p>.</span><span class=n>fs</span><span class=p>.</span><span class=n>uses_discard</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>c</span><span class=o>-&gt;</span><span class=n>discard</span> <span class=o>=</span> <span class=nf>qir_MOV</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=nf>qir_uniform_ui</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=mi>0</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>ntq_setup_inputs</span><span class=p>(</span><span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>ntq_setup_outputs</span><span class=p>(</span><span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Find the main function and emit the body. */</span>
</span></span><span class=line><span class=cl>        <span class=nf>nir_foreach_function</span><span class=p>(</span><span class=n>function</span><span class=p>,</span> <span class=n>c</span><span class=o>-&gt;</span><span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>assert</span><span class=p>(</span><span class=nf>strcmp</span><span class=p>(</span><span class=n>function</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>,</span> <span class=s>&#34;main&#34;</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=nf>assert</span><span class=p>(</span><span class=n>function</span><span class=o>-&gt;</span><span class=n>impl</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=nf>ntq_emit_impl</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>function</span><span class=o>-&gt;</span><span class=n>impl</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>其中ntq应该就是<code>Nir To Qir</code>的缩写。这里行为的核心思想：</p><ul><li>QIR已经比较贴近真正的程序了，程序的输入要从VPM中读取，所以转换NIR到QIR的时候，要生成读取参数的QIR指令</li><li>同样，以vertex shader为例，shader执行完毕后，其进行的输出应该写回VPM，NIR到QIR的转换也要生成相应的QIR指令</li><li>NIR和QIR都是SSA中间表示，所以其转换也是类似直接转换</li></ul><p><code>ntq_setup_inputs</code>的功能比较直观，配置好QIR程序的输入。我们知道shader程序应该有多个输入变量的，这里要将他们从NIR映射到QIR中。</p><ul><li>ntq_setup_inputs本质上是生成指令，将输入shader参数读取到一部分TEMP变量中</li><li>ntq_setup_outputs本质上通过</li></ul><h1 id=寄存器分配器>寄存器分配器</h1><p>这里先谈谈我对寄存器分配器的理解，然后结合vc4的实现进行分析。一般情况下IR会假定寄存器个数是无限多个，但是实际上可用的物理寄存器的个数是有限的。所以code generation中比较重要的一环就是将IR中使用的临时（虚拟）寄存器进行转换，将物理寄存器分配到相应的虚拟寄存器上。实现这个过程的代码单元被称作寄存器分配器。</p><p>经过多年的改进，寄存器分配的实现比较固定了，是通过一个图论问题进行抽象的。以所有临时寄存器为顶点，对于任意两个顶点（即临时寄存器），如果他们的生命周期重叠（即在同一时刻，他们俩都活着需要被下面的语句使用），那么将这两个顶点连起来。在这个图被构造出来之后，寄存器分配的问题即转换成了一个着色问题：假设物理寄存器的个数为k，那么找出一种着色方案，使得相邻的两个顶点没有相同的颜色。</p><p>这个问题是一个NR-hard的问题，没有有效的算法，但是实际上大家都使用一个比较经典的经验算法。外加，这个问题在经验算法失效的时候，存在另一种解决方案，即将虚拟寄存器的值缓存到内存中，从而进一步简化问题。所以实践中，这个问题是比较好解决的。</p><p>在GPU场景下，上面的抽象忽略了一个重要的问题，即GPU的寄存器往往不是统一个架构，也就是说很多情况下，GPU的寄存器不能仅仅看成相等的一类寄存器，即每个寄存器都是相同的可以互相替换，存在各种形式的专用寄存器。针对这种情况，有人提出了class的概念，并扩展了原先的图论问题。可以参考这篇<a href=https://user.it.uu.se/~svenolof/wpo/AllocSCOPES2003.20030626b.pdf>论文</a>，事实上Mesa的寄存器分配器也是根据这篇论文实现的。</p><p>这个方法实质上清晰的定义了寄存器的“目标模型”：&lt;Regs, Conflict, Classes></p><ul><li>Regs是寄存器集合。寄存器集合中的寄存器名，实质上不是物理寄存器的集合，而是一个概念上的寄存器集合。只要指令集中有对该寄存器名称的操作，那么这个寄存器名称就可以添加到这个寄存器集合中。毕竟很明显，会出现寄存器重叠的情况，比如x86下就有单独操64位寄存器的低32位寄存器的寄存器别名。</li><li>Conflict是一个relation（离散数学里的概念），是对称和自反性的，作用与寄存器集合。这个relation实际上描述一组不能同时分配出去的寄存器，和上面一样，典型的场景就是寄存器重叠，即两个寄存器名字对应的物理寄存器在一个区域上，还是上面x86的那个例子。</li><li>Classes是一组寄存器类，每个寄存器类是一个寄存器集合的子集。寄存器类这个概念比较难理解，简单来讲，有些指令集operation限制其operand于一个特定的寄存器集合子集中，说成白话，就是有些指令会要求指令结果必须是只能保存在某些特定的寄存器，即对operand的寄存器选择有限制。</li></ul><p>从工程概念的角度上来看，明白上面这些实际上已经能够理解Mesa中对寄存器分配器的使用了。但是我还想具体写下这个算法的实现原理。简单来说，算法首先构建这个图，然后在图中找一个顶点，这个顶点满足特定的属性要求，即local colorable。这个属性实际上意味着，对于任意这个顶点的相邻顶点的着色分配，我们可以找出一个新的颜色，使这个顶点与其他相邻顶点没有颜色冲突。</p><p>一旦找到这个属性的节点，那么就可以将这个顶点从图中去除掉，然后获得一个新图。重复这个过程，直到最后得到一个没有顶点的空图。然后反向将原来去除的节点依次添加回图（最后去除的最先添加），并给新添加的这个顶点赋予一个与其相邻节点都不相同的颜色。重复这个过程，即得到一个完成着色的图，按照图的定义，我们即得到了一个寄存器分配。这个过程中实际上存在情况，找不到local colorable属性的顶点，碰到这样的情况，我们就根据经验方法从图中去掉一个顶点，把这个顶点对应的temp寄存器放到内存空间中暂存，这个操作称作spill。去除掉一个顶点后得到的新图，重头开始这样的算法。最后一个问题就是怎么判断local colorable属性，论文中提出了pq test，可以参考论文的描述与证明。</p><h2 id=寄存器集合构建>寄存器集合构建</h2><p>回到Mesa中，Mesa实现了上述基于class的寄存器分配器，并作为公共代码被大部分驱动所用。从原理上，我们可以理解，想要使用这样的寄存器分配器，我们实际上需要：</p><ul><li>定义寄存器集合</li><li>定义寄存器集合中的冲突</li><li>定义寄存器class</li><li>计算temp变量的生命周期，并获取冲突情况</li></ul><p><code>vc4_register_allocate.c</code>文件中实现vc4的寄存器分配。其中，<code>vc4_alloc_reg_set</code>函数中进行了寄存器的定义。函数中可以看到，<code>ra_alloc_reg_set</code>用于申请寄存器集合，得到一个<code>struct ra_regs</code>对象。<code>ra_alloc_contig_reg_class</code>函数用于申请class，得到<code>struct ra_class</code>对象。从函数中可以看到，定义了如下的寄存器：</p><ul><li>QPU中的累加器R0-R4</li><li>寄存器bank A中的0-31号寄存器</li><li>寄存器bank B中的0-31号寄存器</li></ul><p>并定义了如下的class：</p><ul><li>reg_class_any[i] R4 A0-A13 A15 (A16-A31) B0-B13 B15 (B16-B31)</li><li>reg_class_a_or_b[i] - A0-A13 A15 (A16-A31) B0-B13 B15 (B16-B31)</li><li>reg_class_a_or_b_or_acc[i] - R0-R3 A0-A13 A15 (A16-A31) B0-B13 B15 (B16-B31)</li><li>reg_class_r4_or_a[i] - R4 A0-A13 A15 (A16-A31)</li><li>reg_class_a[i] - A0-A13 A15 (A16-A31)</li><li>reg_class_r0_r3 - R0-R3</li></ul><p>其中的[i]表示这个class分为0和1两个，分别对应整个bank的空间与bank的下半部空间，括号里的是0号class中才有的。这是因为threaded fragment shader场景下会将整个bank分成上下部分，分别给运行在QPU两个线程上的fragment shader使用。</p><p>函数最后调用<code>ra_set_finalize</code>函数，进行了pq test的预计算工作。</p><h2 id=冲突图构建>冲突图构建</h2><p>得到寄存器集合，以及class的定义之后，构建图：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>ra_graph</span> <span class=o>*</span><span class=n>g</span> <span class=o>=</span> <span class=nf>ra_alloc_interference_graph</span><span class=p>(</span><span class=n>vc4</span><span class=o>-&gt;</span><span class=n>regs</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                         <span class=n>c</span><span class=o>-&gt;</span><span class=n>num_temps</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>得到<code>struct ra_graph</code>结构体。从上面对整个算法的原理上的理解，构建这个图要做的事情如下：</p><ul><li>得到冲突关系。事实上vc4的寄存器没有定义寄存器冲突关系，也就是寄存器没有重叠关系。那么仅剩的冲突关系就是由于temp寄存器生命周期冲突导致的寄存器分配冲突关系。要得到这个冲突关系，我们首先要计算temp寄存器的生命周期，然后通过比对得到冲突关系。</li><li>为每一个顶点分配寄存器类。每个顶点都有其对应的寄存器类，表明这个顶点所表示的temp寄存器可以选择的寄存器类型。后面可以看到，vc4驱动中通过枚举qir指令，根据指令的类型为temp寄存器指定其对应的寄存器类。</li></ul><p><code>qir_calculate_live_intervals</code>函数用于计算临时变量的生命周期。一个temp变量的生命周期由两个变量表示，分别是生命周期的开始和结束：temp_start和temp_end函数。</p><p>可以看到进行一个简单的优化：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>c</span><span class=o>-&gt;</span><span class=n>num_temps</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>map</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>temp</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>map</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>priority</span> <span class=o>=</span> <span class=n>c</span><span class=o>-&gt;</span><span class=n>temp_end</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=n>c</span><span class=o>-&gt;</span><span class=n>temp_start</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>qsort</span><span class=p>(</span><span class=n>map</span><span class=p>,</span> <span class=n>c</span><span class=o>-&gt;</span><span class=n>num_temps</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>map</span><span class=p>[</span><span class=mi>0</span><span class=p>]),</span> <span class=n>node_to_temp_priority</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>c</span><span class=o>-&gt;</span><span class=n>num_temps</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>temp_to_node</span><span class=p>[</span><span class=n>map</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>temp</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>大概意思就是，计算每个temp变量的生命周期长度，根据生命周期长度进行一个排序，然后得到一个temp变量到顶点的映射。由于Mesa中的寄存器分配器优先分配低标号寄存器给低标号顶点（temp变量），这导致程序中最初的变量会被分配给累加器，一般是shader程序的输入参数，这使得shader参数长期占用累加器。通过排序，做这个重映射，使得生命周期短的temp变量优先分配累加器，尽可能多的利用累加器，使整个程序的寄存器冲突减小，分配更高效。从而提升了整体性能。</p><p>顶点的class定义实现比较简单，驱动为每一个temp寄存器（即顶点）定义一个class_bit变量，形成一个数组。每一个class_bit的值是下面几个flags的组合：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define CLASS_BIT_A			(1 &lt;&lt; 0)
</span></span></span><span class=line><span class=cl><span class=cp>#define CLASS_BIT_B			(1 &lt;&lt; 1)
</span></span></span><span class=line><span class=cl><span class=cp>#define CLASS_BIT_R4			(1 &lt;&lt; 2)
</span></span></span><span class=line><span class=cl><span class=cp>#define CLASS_BIT_R0_R3			(1 &lt;&lt; 4)
</span></span></span></code></pre></td></tr></table></div></div><p>初始情况下，这四个flag是都设置了的，每一个flag实质上表示这个temp寄存器可以使用的物理寄存器类型，如<code>CLASS_BIT_R4</code>表示这个temp寄存器可以使用寄存器R4。随后遍历所有的指令，根据规则消减相应的flag，我们首先可以看到对R4的处理：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=nf>qir_writes_r4</span><span class=p>(</span><span class=n>inst</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=cm>/* This instruction writes r4 (and optionally moves
</span></span></span><span class=line><span class=cl><span class=cm>                         * its result to a temp), so nothing else can be
</span></span></span><span class=line><span class=cl><span class=cm>                         * stored in r4 across it.
</span></span></span><span class=line><span class=cl><span class=cm>                         */</span>
</span></span><span class=line><span class=cl>                        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>c</span><span class=o>-&gt;</span><span class=n>num_temps</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                                <span class=k>if</span> <span class=p>(</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>temp_start</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>ip</span> <span class=o>&amp;&amp;</span> <span class=n>c</span><span class=o>-&gt;</span><span class=n>temp_end</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>ip</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                                        <span class=n>class_bits</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&amp;=</span> <span class=o>~</span><span class=n>CLASS_BIT_R4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                        <span class=cm>/* If we&#39;re doing a conditional write of something
</span></span></span><span class=line><span class=cl><span class=cm>                         * writing R4 (math, tex results), then make sure that
</span></span></span><span class=line><span class=cl><span class=cm>                         * we store in a temp so that we actually
</span></span></span><span class=line><span class=cl><span class=cm>                         * conditionally move the result.
</span></span></span><span class=line><span class=cl><span class=cm>                         */</span>
</span></span><span class=line><span class=cl>                        <span class=k>if</span> <span class=p>(</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>cond</span> <span class=o>!=</span> <span class=n>QPU_COND_ALWAYS</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                                <span class=n>class_bits</span><span class=p>[</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>dst</span><span class=p>.</span><span class=n>index</span><span class=p>]</span> <span class=o>&amp;=</span> <span class=o>~</span><span class=n>CLASS_BIT_R4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=cm>/* R4 can&#39;t be written as a general purpose
</span></span></span><span class=line><span class=cl><span class=cm>                         * register. (it&#39;s TMU_NOSWAP as a write address).
</span></span></span><span class=line><span class=cl><span class=cm>                         */</span>
</span></span><span class=line><span class=cl>                        <span class=k>if</span> <span class=p>(</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>dst</span><span class=p>.</span><span class=n>file</span> <span class=o>==</span> <span class=n>QFILE_TEMP</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                                <span class=n>class_bits</span><span class=p>[</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>dst</span><span class=p>.</span><span class=n>index</span><span class=p>]</span> <span class=o>&amp;=</span> <span class=o>~</span><span class=n>CLASS_BIT_R4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>回顾一下R4，R4是一个只读的累加器，Spec中可以看到，这个累加器在大部分情况下用于读取外部单元给出的数据。之所以称作只读的，是因为QPU的ALU指定对于写入的operand没有像read operand那样的mux，而是使用32-37号寄存器编码累加器，即在A或者B bank中32-37寄存器被映射到累加器，而本应表示R4的36被映射到<code>TMU_NOSWAP</code>，这从实质上就杜绝了R4的写入。那么，<code>qir_writes_r4(inst)</code>本质上是检测这个指令会不会造成R4的间接写入：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=nf>qir_writes_r4</span><span class=p>(</span><span class=k>struct</span> <span class=n>qinst</span> <span class=o>*</span><span class=n>inst</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>switch</span> <span class=p>(</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>op</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>QOP_TEX_RESULT</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>QOP_TLB_COLOR_READ</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>QOP_RCP</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>QOP_RSQ</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>QOP_EXP2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>QOP_LOG2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>很明显，对于会造成R4隐式写入的指令，只要它位于某个temp变量的生命周期中，那么这个temp变量本身就不能被分配给R4寄存器。对于非R4隐式写入的指令，其目标temp寄存器明显不能分配为R4，因为R4是只读的。</p><p>随后就是根据指令的限制对指令的operand进行限制。最后根据得到的class_bit数组，对顶点标记其属于的class。</p><p>最后，遍历temp变量，根据生命周期添加图的边：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>c</span><span class=o>-&gt;</span><span class=n>num_temps</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>c</span><span class=o>-&gt;</span><span class=n>num_temps</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>temp_start</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=n>c</span><span class=o>-&gt;</span><span class=n>temp_end</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>                              <span class=n>c</span><span class=o>-&gt;</span><span class=n>temp_start</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=n>c</span><span class=o>-&gt;</span><span class=n>temp_end</span><span class=p>[</span><span class=n>i</span><span class=p>]))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                                <span class=nf>ra_add_node_interference</span><span class=p>(</span><span class=n>g</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                         <span class=n>temp_to_node</span><span class=p>[</span><span class=n>i</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                                                         <span class=n>temp_to_node</span><span class=p>[</span><span class=n>j</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>                        <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>最后，调用<code>ra_allocate</code>，并收集temp到物理寄存器的映射。</p><h1 id=指令构造器>指令构造器</h1><p>无论如何，shader最终都要编译成QPU能够认识的二进制指令然后执行。那么其中必不可少的一个功能就是生成一条指令的二进制表示，一个<code>uint64_t</code>类型的整数。其方式实现比较简单，可以轻松想想出来，即通过提供各种字段的enum，和字段的配置结构，一级一级的提供构造指令所用的函数。到最后，提供一套比较类似的接口，举例如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>uint64_t</span>
</span></span><span class=line><span class=cl><span class=nf>qpu_a_MOV</span><span class=p>(</span><span class=k>struct</span> <span class=n>qpu_reg</span> <span class=n>dst</span><span class=p>,</span> <span class=k>struct</span> <span class=n>qpu_reg</span> <span class=n>src</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>为了生成字段，首先要定义字段的位置，长度。<code>vc4_qpu_defines.h</code>中包含了相关的enum定义，简单先来看下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define QPU_MASK(high, low) ((((uint64_t)1&lt;&lt;((high)-(low)+1))-1)&lt;&lt;(low))
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=cm>/* Using the GNU statement expression extension */</span>
</span></span><span class=line><span class=cl><span class=cp>#define QPU_SET_FIELD(value, field)                                       \
</span></span></span><span class=line><span class=cl><span class=cp>        ({                                                                \
</span></span></span><span class=line><span class=cl><span class=cp>                uint64_t fieldval = (uint64_t)(value) &lt;&lt; field ## _SHIFT; \
</span></span></span><span class=line><span class=cl><span class=cp>                assert((fieldval &amp; ~ field ## _MASK) == 0);               \
</span></span></span><span class=line><span class=cl><span class=cp>                fieldval &amp; field ## _MASK;                                \
</span></span></span><span class=line><span class=cl><span class=cp>         })
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define QPU_GET_FIELD(word, field) ((uint32_t)(((word)  &amp; field ## _MASK) &gt;&gt; field ## _SHIFT))
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define QPU_UPDATE_FIELD(inst, value, field)                              \
</span></span></span><span class=line><span class=cl><span class=cp>        (((inst) &amp; ~(field ## _MASK)) | QPU_SET_FIELD(value, field))
</span></span></span></code></pre></td></tr></table></div></div><p>本质上，通过两个抽象确定字段在指令中的位置：<code>_MASK</code>，<code>_SHIFT</code>。然后<code>QPU_GET_FILED</code>，<code>QPU_SET_FILED</code>通过这两个宏将数值更新到字段上。可以通过如下类似的方式，更改一个指令的相应字段：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>        <span class=n>inst</span> <span class=o>|=</span> <span class=nf>QPU_SET_FIELD</span><span class=p>(</span><span class=n>QPU_SIG_NONE</span><span class=p>,</span> <span class=n>QPU_SIG</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>inst</span> <span class=o>|=</span> <span class=nf>QPU_SET_FIELD</span><span class=p>(</span><span class=n>QPU_A_OR</span><span class=p>,</span> <span class=n>QPU_OP_ADD</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>inst</span> <span class=o>|=</span> <span class=nf>QPU_SET_FIELD</span><span class=p>(</span><span class=n>QPU_R_NOP</span><span class=p>,</span> <span class=n>QPU_RADDR_A</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>inst</span> <span class=o>|=</span> <span class=nf>QPU_SET_FIELD</span><span class=p>(</span><span class=n>QPU_R_NOP</span><span class=p>,</span> <span class=n>QPU_RADDR_B</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>vc4使用<code>struct qpu_reg</code>表示一个寄存器，注意指令中的寄存器字段是需要mux填充的，也就是指令中有专门的一个mux字段，表明指令操作的是哪种类型的存储空间（累加器，寄存器集合A，寄存器集合B）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>qpu_reg</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>enum</span> <span class=n>qpu_mux</span> <span class=n>mux</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint8_t</span> <span class=n>addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>有多个构造函数可以方便的快速构造对应类型的寄存器表示，这里不列举了。但事实上这些helper本质上还是给更上一层的接口使用的，即直接生成指令表示的函数。以<code>qpu_NOP</code>举例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>uint64_t</span>
</span></span><span class=line><span class=cl><span class=nf>qpu_NOP</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint64_t</span> <span class=n>inst</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>inst</span> <span class=o>|=</span> <span class=nf>QPU_SET_FIELD</span><span class=p>(</span><span class=n>QPU_A_NOP</span><span class=p>,</span> <span class=n>QPU_OP_ADD</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>inst</span> <span class=o>|=</span> <span class=nf>QPU_SET_FIELD</span><span class=p>(</span><span class=n>QPU_M_NOP</span><span class=p>,</span> <span class=n>QPU_OP_MUL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Note: These field values are actually non-zero */</span>
</span></span><span class=line><span class=cl>        <span class=n>inst</span> <span class=o>|=</span> <span class=nf>QPU_SET_FIELD</span><span class=p>(</span><span class=n>QPU_W_NOP</span><span class=p>,</span> <span class=n>QPU_WADDR_ADD</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>inst</span> <span class=o>|=</span> <span class=nf>QPU_SET_FIELD</span><span class=p>(</span><span class=n>QPU_W_NOP</span><span class=p>,</span> <span class=n>QPU_WADDR_MUL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>inst</span> <span class=o>|=</span> <span class=nf>QPU_SET_FIELD</span><span class=p>(</span><span class=n>QPU_R_NOP</span><span class=p>,</span> <span class=n>QPU_RADDR_A</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>inst</span> <span class=o>|=</span> <span class=nf>QPU_SET_FIELD</span><span class=p>(</span><span class=n>QPU_R_NOP</span><span class=p>,</span> <span class=n>QPU_RADDR_B</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>inst</span> <span class=o>|=</span> <span class=nf>QPU_SET_FIELD</span><span class=p>(</span><span class=n>QPU_SIG_NONE</span><span class=p>,</span> <span class=n>QPU_SIG</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>inst</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>总之，接口的形式为类似<code>qpu_&lt;INSTR></code>的函数，其返回值为uint64_t，即真正构造出来的机器指令。而函数的参数则根据指令的不同而不同，一般为相应的寄存器参数。由于ALU指令大多有cond_add和sig字段，所以提供了<code>qpu_set_cond_add</code>和<code>qpu_set_sig</code>来设置相应的字段。</p><h1 id=code-emitter>Code Emitter</h1><p>Code emitter的本质工作是实现从QIR到二进制可执行QPU（shader）程序的转换。其实现位于<code>vc4_qpu_emit.c</code>文件中，主要接口为<code>vc4_generate_code</code>与<code>vc4_generate_code_block</code>。其实现基本逻辑就是遍历所有的QIR指令，然后做简单的一对一翻译，有时候会根据需要插入额外指令。</p><h2 id=queue>Queue</h2><p>这里的queue即指队列，也指一个接口。shader程序实际上就是一堆<code>uint64_t</code>指令的集合，vc4中，这些指令被放到一个队列（链表）中。<code>queue</code>接口的实现如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>queue</span><span class=p>(</span><span class=k>struct</span> <span class=n>qblock</span> <span class=o>*</span><span class=n>block</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>inst</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>queued_qpu_inst</span> <span class=o>*</span><span class=n>q</span> <span class=o>=</span> <span class=nf>rzalloc</span><span class=p>(</span><span class=n>block</span><span class=p>,</span> <span class=k>struct</span> <span class=n>queued_qpu_inst</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>q</span><span class=o>-&gt;</span><span class=n>inst</span> <span class=o>=</span> <span class=n>inst</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>list_addtail</span><span class=p>(</span><span class=o>&amp;</span><span class=n>q</span><span class=o>-&gt;</span><span class=n>link</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>block</span><span class=o>-&gt;</span><span class=n>qpu_inst_list</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>本质上就是创建一个链表元素，然后添加到链表尾部。除此之外，由于实现需要，还提供了两个接口，用于更改链表最后一个元素中指令的Condition字段：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>set_last_cond_add</span><span class=p>(</span><span class=k>struct</span> <span class=n>qblock</span> <span class=o>*</span><span class=n>block</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>cond</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=nf>last_inst</span><span class=p>(</span><span class=n>block</span><span class=p>)</span> <span class=o>=</span> <span class=nf>qpu_set_cond_add</span><span class=p>(</span><span class=o>*</span><span class=nf>last_inst</span><span class=p>(</span><span class=n>block</span><span class=p>),</span> <span class=n>cond</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>set_last_cond_mul</span><span class=p>(</span><span class=k>struct</span> <span class=n>qblock</span> <span class=o>*</span><span class=n>block</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>cond</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=nf>last_inst</span><span class=p>(</span><span class=n>block</span><span class=p>)</span> <span class=o>=</span> <span class=nf>qpu_set_cond_mul</span><span class=p>(</span><span class=o>*</span><span class=nf>last_inst</span><span class=p>(</span><span class=n>block</span><span class=p>),</span> <span class=n>cond</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=vc4_generate_code_block>vc4_generate_code_block</h2><p>函数原型如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>vc4_generate_code_block</span><span class=p>(</span><span class=k>struct</span> <span class=n>vc4_compile</span> <span class=o>*</span><span class=n>c</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                        <span class=k>struct</span> <span class=n>qblock</span> <span class=o>*</span><span class=n>block</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                        <span class=k>struct</span> <span class=n>qpu_reg</span> <span class=o>*</span><span class=n>temp_registers</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>首先明确code block实际上类似与编译器中的basic block的概念，即一个顺序执行（没有分支跳转）的最小代码单元，函数的第二个参数block即为这样一个basic block单元，由QIR组成。函数的第三个参数为前面分析过的寄存器分配器的输出，即物理寄存器到temp寄存器的一个分配。有了这些前置条件，即可开始分析代码。</p><p>我们知道一个SSA形式的指令有类似如下的样式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>dest = op (src0, src1, src2, ......)
</span></span></code></pre></td></tr></table></div></div><p>而我们要做的实质上就是将这种形式的QIR转换成QPU能够执行的指令。其中最简单的就是op的转换，QIR是为QPU设计的，其基本的<code>QOP_*</code> opcode本质上可以简单转换为QPU执行的opcode。随后就是src和dest的转换，他们的类型为QIR中的<code>struct qfile</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>qreg</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>enum</span> <span class=n>qfile</span> <span class=n>file</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint32_t</span> <span class=n>index</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>pack</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>本质上也是非常贴合QPU指令级的设计，我们以<code>QFILE_TEMP</code>和<code>QFILE_VARY</code>为例，简单分析。<code>QFILE_TEMP</code>为QIR中的临时寄存器表示，在前面的寄存器分配过程中，我们得到临时寄存器到物理寄存器的映射，并且函数参数也传入了映射结果，所以对于<code>QFILE_TEMP</code>的转换非常简单：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>                        <span class=k>case</span> <span class=nl>QFILE_TEMP</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                                <span class=n>src</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>temp_registers</span><span class=p>[</span><span class=n>index</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                                <span class=k>if</span> <span class=p>(</span><span class=n>qinst</span><span class=o>-&gt;</span><span class=n>src</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>pack</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                                        <span class=nf>assert</span><span class=p>(</span><span class=o>!</span><span class=n>unpack</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>                                               <span class=n>unpack</span> <span class=o>==</span> <span class=n>qinst</span><span class=o>-&gt;</span><span class=n>src</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>pack</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                                        <span class=n>unpack</span> <span class=o>=</span> <span class=nf>QPU_SET_FIELD</span><span class=p>(</span><span class=n>qinst</span><span class=o>-&gt;</span><span class=n>src</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>pack</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                               <span class=n>QPU_UNPACK</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                                        <span class=k>if</span> <span class=p>(</span><span class=n>src</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>mux</span> <span class=o>==</span> <span class=n>QPU_MUX_R4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                                                <span class=n>unpack</span> <span class=o>|=</span> <span class=n>QPU_PM</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                                <span class=p>}</span>
</span></span><span class=line><span class=cl>                                <span class=k>break</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>简单读取这个映射即可。对于<code>QFILE_VARY</code>来说更为简单，因为这个寄存器的值实际上是映射到寄存器bank B上的，只需要简单配置即可：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>                        <span class=k>case</span> <span class=nl>QFILE_VARY</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                                <span class=n>src</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nf>qpu_vary</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                                <span class=k>break</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>实际上比较复杂的是<code>QFILE_VPM</code>，后面单独来一小结分析。</p><p>经过上面的分析，整体逻辑还是非常简单的，后面仅挑比较费解的细节分析。</p><h2 id=vpm>VPM</h2><p><code>QFILE_VPM</code>的写入非常简单，而其读取比较复杂。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>                        <span class=k>case</span> <span class=nl>QFILE_VPM</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                                <span class=nf>setup_for_vpm_read</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>block</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                                <span class=nf>assert</span><span class=p>((</span><span class=kt>int</span><span class=p>)</span><span class=n>qinst</span><span class=o>-&gt;</span><span class=n>src</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>index</span> <span class=o>&gt;=</span>
</span></span><span class=line><span class=cl>                                       <span class=n>last_vpm_read_index</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                                <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=n>last_vpm_read_index</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                                <span class=n>last_vpm_read_index</span> <span class=o>=</span> <span class=n>qinst</span><span class=o>-&gt;</span><span class=n>src</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>index</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                                <span class=n>src</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nf>qpu_ra</span><span class=p>(</span><span class=n>QPU_R_VPM</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                                <span class=k>break</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>VPM是外部的硬件模块，其读取方式比较复杂，需要经过配置。简单来说，读取时要对FIFO进行配置（写入一个寄存器），随后通过读取另一个寄存器得到VPM从FIFO传出的值。</p><h2 id=vc4_generate_code>vc4_generate_code</h2><p>函数首先调用上面提到的寄存器分配器接口对寄存器进行分配操作：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>qpu_reg</span> <span class=o>*</span><span class=n>temp_registers</span> <span class=o>=</span> <span class=nf>vc4_register_allocate</span><span class=p>(</span><span class=n>vc4</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>temp_registers</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>然后，对于Coord和Vertex shader，先配置好VPM的输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>        <span class=k>switch</span> <span class=p>(</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>stage</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>QSTAGE_VERT</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>QSTAGE_COORD</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>c</span><span class=o>-&gt;</span><span class=n>num_inputs_remaining</span> <span class=o>=</span> <span class=n>c</span><span class=o>-&gt;</span><span class=n>num_inputs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=nf>queue</span><span class=p>(</span><span class=n>start_block</span><span class=p>,</span> <span class=nf>qpu_load_imm_ui</span><span class=p>(</span><span class=nf>qpu_vwsetup</span><span class=p>(),</span> <span class=mh>0x00001a00</span><span class=p>));</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>QSTAGE_FRAG</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>接下来遍历所有的blocks，然后调用<code>vc4_generate_code_block</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>        <span class=nf>qir_for_each_block</span><span class=p>(</span><span class=n>block</span><span class=p>,</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=nf>vc4_generate_code_block</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>block</span><span class=p>,</span> <span class=n>temp_registers</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>最后函数调用<code>qpu_schedule_instructions</code>，剩下的都是细节，主要与QPU硬件对二进制可执行程序的一些强制要求有关。</p><h1 id=指令调度器>指令调度器</h1><p>从vc4的硬件手册中我们了解到，一条QPU的ALU指令上实际上是同时向两个ALU下发指令的，即有两套opcode的相关字段，分别给QPU的ADD和MUL两个ALU进行指令下发。但是在QIR中可以看到，两个ALU的指令都是独立作为QIR指令的，并没有实现这个特性。事实上，从编译器的设计角度上来看，这部分功能是由指令调度器实现的。vc4的指令调度器实现比较简单，位于<code>vc4_qir_schedule.c</code>文件中，其主要功能为：</p><ul><li>重新排序指令，减小QPU的stall，提升整个程序的性能</li><li>合并两个ALU的operation成为一个独立的instruction</li><li>将block整合成一个程序，并设置好跳转target</li></ul><p>基本上，指令调度器是vc4的shader编译器的最后一个阶段了，在他将已经生成的basic block进行处理，得到最终的可执行程序。</p><h2 id=基本设计>基本设计</h2><p>同大部分编译器一样，vc4的指令调度器基于list scheduler，是目前市面上最常见的指令调度器实现。其基本设计是根据遍历basic block，根据指令依赖关系生成一个有向无环图（DAG），然后通过维护两个列表Active和Ready，从DAG的页节点开始，根据优先级和依赖关系悬着指令进行调度。后面会详细分析vc4使用的算法。</p><p>vc4的指令调度器使用如下结构体表示一次指令调度使用的所有信息：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>choose_scoreboard</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>dag</span> <span class=o>*</span><span class=n>dag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>tick</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>last_sfu_write_tick</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>last_uniforms_reset_tick</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint32_t</span> <span class=n>last_waddr_a</span><span class=p>,</span> <span class=n>last_waddr_b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=n>tlb_locked</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>可以看到，其中<code>dag</code>字段是有向无环图，而tick为算法中使用的cycle计数。vc4通过遍历所有的basic block，进行这个basic block上的指令调度。在<a href=#Queue>Code Emitter</a>中我们看到，调用指令构造器后得到的指令是存放在<code>block->qpu_inst_list</code>链表上的。而很明显这不是最终的shader程序存放的位置，从指令调度器的实现来看，我们发现最终的shader二进制程序存在在一个数组中，即<code>vc4_compile->qpu_inst</code>，并通过<code>qpu_serialize_one_inst</code>接口向数组中添加一个指令。</p><p>从指令调度器的主要入口<code>qpu_schedule_instructions</code>中可以看到，其主要逻辑为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>        <span class=kt>uint32_t</span> <span class=n>cycles</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>qir_for_each_block</span><span class=p>(</span><span class=n>block</span><span class=p>,</span> <span class=n>c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>block</span><span class=o>-&gt;</span><span class=n>start_qpu_ip</span> <span class=o>=</span> <span class=n>c</span><span class=o>-&gt;</span><span class=n>qpu_inst_count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>block</span><span class=o>-&gt;</span><span class=n>branch_qpu_ip</span> <span class=o>=</span> <span class=o>~</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=n>cycles</span> <span class=o>+=</span> <span class=nf>qpu_schedule_instructions_block</span><span class=p>(</span><span class=n>c</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                          <span class=o>&amp;</span><span class=n>scoreboard</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                          <span class=n>block</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                          <span class=n>uniform_contents</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                          <span class=n>uniform_data</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                          <span class=o>&amp;</span><span class=n>next_uniform</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=n>block</span><span class=o>-&gt;</span><span class=n>end_qpu_ip</span> <span class=o>=</span> <span class=n>c</span><span class=o>-&gt;</span><span class=n>qpu_inst_count</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>qpu_set_branch_targets</span><span class=p>(</span><span class=n>c</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>从这里可以看出，这个函数的主要逻辑是遍历所有的block，然后对block进行指令调度，然后将调度后的结果塞入<code>vc4_compile->qpu_inst</code>数组，并记录block在数组中的位置。随后，通过<code>qpu_set_branch_targets</code>函数，将每个basic block的分支跳转语句的目标位置改写，这在编译器的概念中叫relocation。</p><p><code>qpu_schedule_instructions_block</code>函数即是list scheduler的主要实现，关于list scheduler算法，这里不做具体介绍，假定都知道了，如果没有概念，建议看《Engineer A Compiler》，比龙书讲的清楚的多。实际上函数结构非常清晰：</p><ol><li>构建DAG，计算DAG节点的边和相应的延迟</li><li>遍历DAG，开始list scheduler算法，对指令进行调度</li></ol><h2 id=dag构建>DAG构建</h2><p>可以看到，vc4的list scheduler设计简单，没有进行register renaming的步骤，所以要将True Dependences和Antidependences都添加到DAG中。DAG的表示使用了Mesa中通用的helper，创建过程比较简单：</p><ul><li>首先遍历所有的指令创建DAG的顶点</li><li>计算True Dependences，作为有向图的边</li><li>计算Antidependences，作为有向图的边</li><li>计算硬件资源依赖</li><li>从下到上遍历图，计算主要路径的延迟，通过这个延迟当作选择顶点时的优先级，比较经典的做法</li></ul><p>依赖计算使用同一个算法跑两轮的形式，分别从头到尾，再从尾到头对指令序列进行处理，这两个函数分别为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>calculate_forward_deps</span><span class=p>(</span><span class=k>struct</span> <span class=n>vc4_compile</span> <span class=o>*</span><span class=n>c</span><span class=p>,</span> <span class=k>struct</span> <span class=n>dag</span> <span class=o>*</span><span class=n>dag</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                       <span class=k>struct</span> <span class=n>list_head</span> <span class=o>*</span><span class=n>schedule_list</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>schedule_state</span> <span class=n>state</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>state</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>state</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>state</span><span class=p>.</span><span class=n>dag</span> <span class=o>=</span> <span class=n>dag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>state</span><span class=p>.</span><span class=n>dir</span> <span class=o>=</span> <span class=n>F</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>list_for_each_entry</span><span class=p>(</span><span class=k>struct</span> <span class=n>schedule_node</span><span class=p>,</span> <span class=n>node</span><span class=p>,</span> <span class=n>schedule_list</span><span class=p>,</span> <span class=n>link</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=nf>calculate_deps</span><span class=p>(</span><span class=o>&amp;</span><span class=n>state</span><span class=p>,</span> <span class=n>node</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>calculate_reverse_deps</span><span class=p>(</span><span class=k>struct</span> <span class=n>vc4_compile</span> <span class=o>*</span><span class=n>c</span><span class=p>,</span> <span class=k>struct</span> <span class=n>dag</span> <span class=o>*</span><span class=n>dag</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                       <span class=k>struct</span> <span class=n>list_head</span> <span class=o>*</span><span class=n>schedule_list</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>schedule_state</span> <span class=n>state</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>state</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>state</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>state</span><span class=p>.</span><span class=n>dag</span> <span class=o>=</span> <span class=n>dag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>state</span><span class=p>.</span><span class=n>dir</span> <span class=o>=</span> <span class=n>R</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>list_for_each_entry_rev</span><span class=p>(</span><span class=k>struct</span> <span class=n>schedule_node</span><span class=p>,</span> <span class=n>node</span><span class=p>,</span> <span class=n>schedule_list</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                <span class=n>link</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>calculate_deps</span><span class=p>(</span><span class=o>&amp;</span><span class=n>state</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>schedule_node</span> <span class=o>*</span><span class=p>)</span><span class=n>node</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在<code> calculate_deps</code>函数中可以通过传入的<code>schedule_state</code>参数的<code>dir</code>字段对这一batch是从头到尾还是从尾到头进行判断。<code>schedule_state</code>变量的定义如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>schedule_state</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>dag</span> <span class=o>*</span><span class=n>dag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>schedule_node</span> <span class=o>*</span><span class=n>last_r</span><span class=p>[</span><span class=mi>6</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>schedule_node</span> <span class=o>*</span><span class=n>last_ra</span><span class=p>[</span><span class=mi>32</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>schedule_node</span> <span class=o>*</span><span class=n>last_rb</span><span class=p>[</span><span class=mi>32</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>schedule_node</span> <span class=o>*</span><span class=n>last_sf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>schedule_node</span> <span class=o>*</span><span class=n>last_vpm_read</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>schedule_node</span> <span class=o>*</span><span class=n>last_tmu_write</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>schedule_node</span> <span class=o>*</span><span class=n>last_tlb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>schedule_node</span> <span class=o>*</span><span class=n>last_vpm</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>schedule_node</span> <span class=o>*</span><span class=n>last_uniforms_reset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>enum</span> <span class=n>direction</span> <span class=n>dir</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Estimated cycle when the current instruction would start. */</span>
</span></span><span class=line><span class=cl>        <span class=kt>uint32_t</span> <span class=n>time</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>其中<code>last_*</code>类型的变量都是指针，指向某个上个进行特定操作的指令，比如读取特定的累加器，或者寄存器bank A。</p><p>这里再提一下为什么同一个算法从头到尾和从尾到头就能把依赖算清楚。首先明确由于是单独的basic block，所以不存在控制依赖的处理，所以仅仅剩数据依赖，而数据依赖分成以下三种情况：</p><ul><li>read after write （True Dependence）</li><li>write after read （Antidependence）</li><li>write after write （Output Dependence）</li></ul><p>由于前面看到并没有使用register renaming处理Antidependence，所以Antidependence也要算成依赖的一种。这时候就可以简化处理的，从头到尾遍历指令序列，处理read after write，write after write，这一算法在反过来从尾到头处理同一指令序列的时候，就跟从头到尾处理write after read和write after write一样了。</p><h3 id=raddr依赖计算>raddr依赖计算</h3><p><code>calculate_deps</code>中首先对raddr造成的依赖进行计算，raddr是ALU指令中对寄存器I/O的地址编码字段，分为bank A和bank B。可以看到<code>calculate_deps</code>中的实现如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>sig</span> <span class=o>!=</span> <span class=n>QPU_SIG_LOAD_IMM</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>process_raddr_deps</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>raddr_a</span><span class=p>,</span> <span class=nb>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>sig</span> <span class=o>!=</span> <span class=n>QPU_SIG_SMALL_IMM</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                    <span class=n>sig</span> <span class=o>!=</span> <span class=n>QPU_SIG_BRANCH</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                        <span class=nf>process_raddr_deps</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>raddr_b</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>其中第一个if判断排除load immediate指令，让ALU指令和Brach和Small Immediate指令通过，这三类指令有<code>raddr_a</code>。而只有ALU指令存在<code>raddr_b</code>字段，所以第二个if排除掉上述的两类指令。<code>process_raddr_deps</code>函数的实现很好理解，首先明确因为raddr是读取的operand，所以当前指令是在读取raddr所指向的位置。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>        <span class=k>switch</span> <span class=p>(</span><span class=n>raddr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>QPU_R_VARY</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=nf>add_write_dep</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>state</span><span class=o>-&gt;</span><span class=n>last_r</span><span class=p>[</span><span class=mi>5</span><span class=p>],</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>QPU_R_VPM</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=nf>add_write_dep</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>state</span><span class=o>-&gt;</span><span class=n>last_vpm_read</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>QPU_R_UNIF</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=nf>add_read_dep</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>state</span><span class=o>-&gt;</span><span class=n>last_uniforms_reset</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>三种情况分别为：</p><ul><li>读取VARY。从文档中看到读取VARY寄存器会导致R5被写入，所以读取VARY的操作和前面对R5的写入有冲突</li><li>读取VPM。VPM读取是连接FIFO的，对VPM的读取会改写VPM寄存器的值，所以事实上和上次的读取是有依赖的</li><li>读取UNIFORM。读取UNIFORM和会重置UNIFORM值的reset是有依赖关系的。</li></ul><p>对于普通的寄存器bank A和bank B的写入，他们与上一个对同一位置的寄存器写入有依赖关系：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>        <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>raddr</span> <span class=o>&lt;</span> <span class=mi>32</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=k>if</span> <span class=p>(</span><span class=n>is_a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                                <span class=nf>add_read_dep</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>state</span><span class=o>-&gt;</span><span class=n>last_ra</span><span class=p>[</span><span class=n>raddr</span><span class=p>],</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                        <span class=k>else</span>
</span></span><span class=line><span class=cl>                                <span class=nf>add_read_dep</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>state</span><span class=o>-&gt;</span><span class=n>last_rb</span><span class=p>[</span><span class=n>raddr</span><span class=p>],</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;unknown raddr %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>raddr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                        <span class=nf>abort</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=waddr依赖计算>waddr依赖计算</h3><p><code>calculate_deps</code>中对waddr导致的依赖计算如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>        <span class=nf>process_waddr_deps</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>waddr_add</span><span class=p>,</span> <span class=nb>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>process_waddr_deps</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>waddr_mul</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p><code>process_waddr_deps</code>函数中要注意ALU指令的WS字段可以转换ALU写入的寄存器bank，所以要通过该字段判断写入的寄存器bank：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>        <span class=kt>uint64_t</span> <span class=n>inst</span> <span class=o>=</span> <span class=n>n</span><span class=o>-&gt;</span><span class=n>inst</span><span class=o>-&gt;</span><span class=n>inst</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=n>is_a</span> <span class=o>=</span> <span class=n>is_add</span> <span class=o>^</span> <span class=p>((</span><span class=n>inst</span> <span class=o>&amp;</span> <span class=n>QPU_WS</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>由于从前面看到写入操作与对同一位置的写入操作冲突，所以这里仅仅判断写入位置，然后替换<code>schedule_state</code>里的指针，并添加一条冲突（图的边）即可。</p><h3 id=mux依赖计算>MUX依赖计算</h3><p>我们知道ALU指令source operand的位置是由MUX控制的，可以直接指向累加器或者寄存器bank。所以，可以根据MUX字段的值判断指令是否读取了累加器。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>add_op</span> <span class=o>!=</span> <span class=n>QPU_A_NOP</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>process_mux_deps</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>add_a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=nf>process_mux_deps</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>add_b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>mul_op</span> <span class=o>!=</span> <span class=n>QPU_M_NOP</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>process_mux_deps</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>mul_a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=nf>process_mux_deps</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>mul_b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>process_mux_deps</span><span class=p>(</span><span class=k>struct</span> <span class=n>schedule_state</span> <span class=o>*</span><span class=n>state</span><span class=p>,</span> <span class=k>struct</span> <span class=n>schedule_node</span> <span class=o>*</span><span class=n>n</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=kt>uint32_t</span> <span class=n>mux</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>mux</span> <span class=o>!=</span> <span class=n>QPU_MUX_A</span> <span class=o>&amp;&amp;</span> <span class=n>mux</span> <span class=o>!=</span> <span class=n>QPU_MUX_B</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=nf>add_read_dep</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>state</span><span class=o>-&gt;</span><span class=n>last_r</span><span class=p>[</span><span class=n>mux</span><span class=p>],</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=condition依赖计算>Condition依赖计算</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>        <span class=nf>process_cond_deps</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=nf>QPU_GET_FIELD</span><span class=p>(</span><span class=n>inst</span><span class=p>,</span> <span class=n>QPU_COND_ADD</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=nf>process_cond_deps</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=nf>QPU_GET_FIELD</span><span class=p>(</span><span class=n>inst</span><span class=p>,</span> <span class=n>QPU_COND_MUL</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>((</span><span class=n>inst</span> <span class=o>&amp;</span> <span class=n>QPU_SF</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>sig</span> <span class=o>!=</span> <span class=n>QPU_SIG_BRANCH</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=nf>add_write_dep</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>state</span><span class=o>-&gt;</span><span class=n>last_sf</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>实现比较简单，<code>process_cond_deps</code>中简单对所有设置了condition code的指令添加了读取依赖。</p><h3 id=延迟计算>延迟计算</h3><p>延迟计算使用的经典方法，即深度优先算法遍历整个图，计算单个指令到程序结尾的最小延迟。后面会根据最小延迟来作为优先级判断依据，优先使用最小延迟最大的节点进行调度。</p><h2 id=指令调度>指令调度</h2><p>TODO</p><h1 id=mesa接口>Mesa接口</h1><p>这里主要分析gallium3d相关的实现。</p></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>crab2313</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2023-01-10
<a href=https://github.com/crab2313/blog-doc/commit/cfd91093790d3e1fb16c6b7d402005910a1dc371 title="blog: update mesa-vc4-compiler">(cfd9109)</a></span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/mesa/>mesa</a>
<a href=/tags/gallium3d/>gallium3d</a>
<a href=/tags/vc4/>vc4</a></div><nav class=post-nav><a class=next href=/post/mesa-vc4/><span class="next-text nav-default">MESA源码分析：VC4驱动</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:crab2313@gmail.com class="iconfont icon-email" title=email></a>
<a href=https://github.com/crab2313 class="iconfont icon-github" title=github></a>
<a href=https://gitlab.com/crab2313 class="iconfont icon-gitlab" title=gitlab></a>
<a href=https://space.bilibili.com/1310103 class="iconfont icon-bilibili" title=bilibili></a>
<a href=/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2017 -
2023<span class=heart><i class="iconfont icon-heart"></i></span><span>crab2313</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script>
<script type=text/javascript>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script></body></html>