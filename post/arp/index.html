<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Linux内核中ARP协议的实现 - crab2313's blog</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="crab2313"><meta name=description content="本文对内核中ARP协议相关的事件进行分析。本文是原先分析文档的整理，后续会进行相应复习与补足。 初始化 1 2 3 4 5 6 7 8 9 10 11 void __init arp_init(void) { neigh_table_init(NEIGH_ARP_TABLE, &amp;amp;arp_tbl); dev_add_pack(&amp;amp;arp_packet_type); arp_proc_init(); #ifdef"><meta name=keywords content="blog,kernel"><meta name=generator content="Hugo 0.109.0 with theme even"><link rel=canonical href=/post/arp/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="Linux内核中ARP协议的实现"><meta property="og:description" content="本文对内核中ARP协议相关的事件进行分析。本文是原先分析文档的整理，后续会进行相应复习与补足。 初始化 1 2 3 4 5 6 7 8 9 10 11 void __init arp_init(void) { neigh_table_init(NEIGH_ARP_TABLE, &arp_tbl); dev_add_pack(&arp_packet_type); arp_proc_init(); #ifdef"><meta property="og:type" content="article"><meta property="og:url" content="/post/arp/"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-04-08T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-08T14:35:13+08:00"><meta itemprop=name content="Linux内核中ARP协议的实现"><meta itemprop=description content="本文对内核中ARP协议相关的事件进行分析。本文是原先分析文档的整理，后续会进行相应复习与补足。 初始化 1 2 3 4 5 6 7 8 9 10 11 void __init arp_init(void) { neigh_table_init(NEIGH_ARP_TABLE, &arp_tbl); dev_add_pack(&arp_packet_type); arp_proc_init(); #ifdef"><meta itemprop=datePublished content="2021-04-08T00:00:00+00:00"><meta itemprop=dateModified content="2021-04-08T14:35:13+08:00"><meta itemprop=wordCount content="4199"><meta itemprop=keywords content="kernel,net,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux内核中ARP协议的实现"><meta name=twitter:description content="本文对内核中ARP协议相关的事件进行分析。本文是原先分析文档的整理，后续会进行相应复习与补足。 初始化 1 2 3 4 5 6 7 8 9 10 11 void __init arp_init(void) { neigh_table_init(NEIGH_ARP_TABLE, &arp_tbl); dev_add_pack(&arp_packet_type); arp_proc_init(); #ifdef"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>crab2313's blog</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>crab2313's blog</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Linux内核中ARP协议的实现</h1><div class=post-meta><span class=post-time>2021-04-08</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#初始化>初始化</a></li><li><a href=#arp协议栈实现的neigh_ops>ARP协议栈实现的neigh_ops</a></li><li><a href=#arp_constructor函数>arp_constructor函数</a></li><li><a href=#arp_rcv函数>arp_rcv函数</a></li><li><a href=#arp_process函数>arp_process函数</a><ul><li><a href=#对arpop_request的处理>对ARPOP_REQUEST的处理</a></li><li><a href=#对arpop_reply的处理>对ARPOP_REPLY的处理</a></li></ul></li><li><a href=#arp_solicit函数>arp_solicit函数</a></li></ul></li></ul></nav></div></div><div class=post-content><p>本文对内核中ARP协议相关的事件进行分析。本文是原先分析文档的整理，后续会进行相应复习与补足。</p><h2 id=初始化>初始化</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=n>__init</span> <span class=nf>arp_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>neigh_table_init</span><span class=p>(</span><span class=n>NEIGH_ARP_TABLE</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>arp_tbl</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>dev_add_pack</span><span class=p>(</span><span class=o>&amp;</span><span class=n>arp_packet_type</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>arp_proc_init</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef CONFIG_SYSCTL
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=nf>neigh_sysctl_register</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>arp_tbl</span><span class=p>.</span><span class=n>parms</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=nf>register_netdevice_notifier</span><span class=p>(</span><span class=o>&amp;</span><span class=n>arp_netdev_notifier</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>首先是注册了一个neigh_table，这个是ARP的entry cache，ARP解析所有的缓存都会保存在这里。由于ARP协议是与IP协议同级，都是跑在Ethernet之上，所以需要使用dev_add_pack注册一个ethernet包的协议，如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=n>packet_type</span> <span class=n>arp_packet_type</span> <span class=n>__read_mostly</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>type</span> <span class=o>=</span> <span class=nf>cpu_to_be16</span><span class=p>(</span><span class=n>ETH_P_ARP</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>func</span> <span class=o>=</span> <span class=n>arp_rcv</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>因此，L2每次收到ARP包的时候，会调用<code>arp_rcv</code>函数处理。之后ARP协议注册了一个/proc/net/arp文件，如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>__init</span> <span class=nf>arp_proc_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nf>register_pernet_subsys</span><span class=p>(</span><span class=o>&amp;</span><span class=n>arp_net_ops</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=n>pernet_operations</span> <span class=n>arp_net_ops</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>init</span> <span class=o>=</span> <span class=n>arp_net_init</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>exit</span> <span class=o>=</span> <span class=n>arp_net_exit</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>__net_init</span> <span class=nf>arp_net_init</span><span class=p>(</span><span class=k>struct</span> <span class=n>net</span> <span class=o>*</span><span class=n>net</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>proc_create</span><span class=p>(</span><span class=s>&#34;arp&#34;</span><span class=p>,</span> <span class=n>S_IRUGO</span><span class=p>,</span> <span class=n>net</span><span class=o>-&gt;</span><span class=n>proc_net</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>arp_seq_fops</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=o>-</span><span class=n>ENOMEM</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=n>__net_exit</span> <span class=nf>arp_net_exit</span><span class=p>(</span><span class=k>struct</span> <span class=n>net</span> <span class=o>*</span><span class=n>net</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>remove_proc_entry</span><span class=p>(</span><span class=s>&#34;arp&#34;</span><span class=p>,</span> <span class=n>net</span><span class=o>-&gt;</span><span class=n>proc_net</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>可以看出作为一个非常基础的协议，ARP协议是namespace-aware的，也就是说对于每一个网络namespace，arp协议会注册该文件。直接读取这个文件我们可以得到本机的ARP缓存，与直接运行arp命令效果是一样的。随后，如果系统开启的SYSCTL的支持，ARP协议初始化函数会注册对应的/proc/sys/net/neigh/文件夹，该文件夹下每个的子文件夹都代表一个网络接口，通过网络接口文件夹下的文件可以在运行时调整ARP协议的各种行为。</p><p>最后，arp_init函数中调用<code>register_netdevice_notifier</code>注册一了一个当网络设备发生变动的时候就会调用的回调函数。</p><h2 id=arp协议栈实现的neigh_ops>ARP协议栈实现的neigh_ops</h2><p>由于我看的内核是4.12版本的，所以arp_broken_ops已经没有了，这说明新内核中已经完全将旧的驱动完全移植到了新的neighbour子系统中，所以不需要再用arp_broken_ops提供的兼容层。新的内核中只有三个ARP的ops，如下表：</p><table><thead><tr><th style=text-align:center>名称</th><th style=text-align:center>用途</th></tr></thead><tbody><tr><td style=text-align:center>arp_generic_ops</td><td style=text-align:center>最通用的neigh_ops</td></tr><tr><td style=text-align:center>arp_hh_ops</td><td style=text-align:center>用于net_device实现了L2缓存的情况</td></tr><tr><td style=text-align:center>arp_direct_ops</td><td style=text-align:center>用于net_device不需要使用L2Header的情况</td></tr></tbody></table><p>先将代码贴出来再分析：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>neigh_ops</span> <span class=n>arp_generic_ops</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>family</span> <span class=o>=</span>               <span class=n>AF_INET</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>solicit</span> <span class=o>=</span>              <span class=n>arp_solicit</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>error_report</span> <span class=o>=</span>         <span class=n>arp_error_report</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>output</span> <span class=o>=</span>               <span class=n>neigh_resolve_output</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>connected_output</span> <span class=o>=</span>     <span class=n>neigh_connected_output</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>neigh_ops</span> <span class=n>arp_hh_ops</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>family</span> <span class=o>=</span>               <span class=n>AF_INET</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>solicit</span> <span class=o>=</span>              <span class=n>arp_solicit</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>error_report</span> <span class=o>=</span>         <span class=n>arp_error_report</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>output</span> <span class=o>=</span>               <span class=n>neigh_resolve_output</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>connected_output</span> <span class=o>=</span>     <span class=n>neigh_resolve_output</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>neigh_ops</span> <span class=n>arp_direct_ops</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>family</span> <span class=o>=</span>               <span class=n>AF_INET</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>output</span> <span class=o>=</span>               <span class=n>neigh_direct_output</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>connected_output</span> <span class=o>=</span>     <span class=n>neigh_direct_output</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>先看arp_direct_ops，这个最特别。首先可以看到它没有.solicit和.error_report，这个是显而易见的，因为使用这个neigh_ops的neighbour entry不需要进行ARP解析。所以不管处于什么状态下，对应的output函数都是neigh_direct_output，这将让对应的直接交给设备发送出去。</p><p>arp_generic_ops和arp_hh_ops的唯一区别是它的.connected_output设置为了neigh_connected_output，这是因为如果net_device的驱动程序自己实现了L2缓存的话，neigh_resolve_output函数中调用的dev_hard_header函数可以从该缓存中获取对应的L2头部。</p><h2 id=arp_constructor函数>arp_constructor函数</h2><p>neighbour子系统在使用neigh_create创建一个struct neighbour的时候会调用保存在neigh_table中的.constructor函数指针初始化这个对象。对应于ARP协议，则为arp_constructor函数。</p><p>这个函数首先设置好这个entry的地址类型，如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>        <span class=n>__be32</span> <span class=n>addr</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=n>__be32</span> <span class=o>*</span><span class=p>)</span><span class=n>neigh</span><span class=o>-&gt;</span><span class=n>primary_key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>neigh</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>=</span> <span class=nf>inet_addr_type_dev_table</span><span class=p>(</span><span class=nf>dev_net</span><span class=p>(</span><span class=n>dev</span><span class=p>),</span> <span class=n>dev</span><span class=p>,</span> <span class=n>addr</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>随后开始设置其对应的初始化状态。如果网络接口设备没有设置dev->header_ops指针，亦即网络接口设备的驱动不会增加L2的Header，则将neigh->nud_state设置为NUB_NOARP，并将neigh->ops设置为arp_direct_ops，neigh->output设置为neigh_direct_output。</p><p>接下来处理几个特殊的IPv4地址类型：组播，广播，本地回环，并处理net_device的flag标记了NOARP的情况：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>neigh</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>==</span> <span class=n>RTN_MULTICAST</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>neigh</span><span class=o>-&gt;</span><span class=n>nud_state</span> <span class=o>=</span> <span class=n>NUD_NOARP</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                        <span class=nf>arp_mc_map</span><span class=p>(</span><span class=n>addr</span><span class=p>,</span> <span class=n>neigh</span><span class=o>-&gt;</span><span class=n>ha</span><span class=p>,</span> <span class=n>dev</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>dev</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>IFF_NOARP</span> <span class=o>|</span> <span class=n>IFF_LOOPBACK</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>neigh</span><span class=o>-&gt;</span><span class=n>nud_state</span> <span class=o>=</span> <span class=n>NUD_NOARP</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                        <span class=nf>memcpy</span><span class=p>(</span><span class=n>neigh</span><span class=o>-&gt;</span><span class=n>ha</span><span class=p>,</span> <span class=n>dev</span><span class=o>-&gt;</span><span class=n>dev_addr</span><span class=p>,</span> <span class=n>dev</span><span class=o>-&gt;</span><span class=n>addr_len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>neigh</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>==</span> <span class=n>RTN_BROADCAST</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>                           <span class=p>(</span><span class=n>dev</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>IFF_POINTOPOINT</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>neigh</span><span class=o>-&gt;</span><span class=n>nud_state</span> <span class=o>=</span> <span class=n>NUD_NOARP</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                        <span class=nf>memcpy</span><span class=p>(</span><span class=n>neigh</span><span class=o>-&gt;</span><span class=n>ha</span><span class=p>,</span> <span class=n>dev</span><span class=o>-&gt;</span><span class=n>broadcast</span><span class=p>,</span> <span class=n>dev</span><span class=o>-&gt;</span><span class=n>addr_len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>最后根据网络设备驱动时候实现了L2地址缓存来确定这个struct neigh到底使用哪个ops:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>dev</span><span class=o>-&gt;</span><span class=n>header_ops</span><span class=o>-&gt;</span><span class=n>cache</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                        <span class=n>neigh</span><span class=o>-&gt;</span><span class=n>ops</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>arp_hh_ops</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span>
</span></span><span class=line><span class=cl>                        <span class=n>neigh</span><span class=o>-&gt;</span><span class=n>ops</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>arp_generic_ops</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>neigh</span><span class=o>-&gt;</span><span class=n>nud_state</span> <span class=o>&amp;</span> <span class=n>NUD_VALID</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                        <span class=n>neigh</span><span class=o>-&gt;</span><span class=n>output</span> <span class=o>=</span> <span class=n>neigh</span><span class=o>-&gt;</span><span class=n>ops</span><span class=o>-&gt;</span><span class=n>connected_output</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span>
</span></span><span class=line><span class=cl>                        <span class=n>neigh</span><span class=o>-&gt;</span><span class=n>output</span> <span class=o>=</span> <span class=n>neigh</span><span class=o>-&gt;</span><span class=n>ops</span><span class=o>-&gt;</span><span class=n>output</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>顺带一提，__neigh_alloc函数中将neigh->nud_state设置成了NUD_NONE，并将neigh->output设置成了neigh_blackhole。</p><h2 id=arp_rcv函数>arp_rcv函数</h2><p>来看ARP协议是如何处理接收到的ARP包的。首先是做一些简单的检查，确定该ARP包是系统应该处理的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>        <span class=cm>/* do not tweak dropwatch on an ARP we will ignore */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>dev</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>IFF_NOARP</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>            <span class=n>skb</span><span class=o>-&gt;</span><span class=n>pkt_type</span> <span class=o>==</span> <span class=n>PACKET_OTHERHOST</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>            <span class=n>skb</span><span class=o>-&gt;</span><span class=n>pkt_type</span> <span class=o>==</span> <span class=n>PACKET_LOOPBACK</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>goto</span> <span class=n>consumeskb</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>可以看到，只要网络设备设置了NOARP，或者该sk_buff的pkg_type字段是PACKET_OTHERHOST | PACKET_LOOPBACK，ARP协议栈是不会处理的，而是将这个包简单丢弃，并不做任何记录。接下来是对这个sk_buff做一些通用的处理：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>        <span class=n>skb</span> <span class=o>=</span> <span class=nf>skb_share_check</span><span class=p>(</span><span class=n>skb</span><span class=p>,</span> <span class=n>GFP_ATOMIC</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>skb</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>goto</span> <span class=n>out_of_mem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* ARP header, plus 2 device addresses, plus 2 IP addresses.  */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>pskb_may_pull</span><span class=p>(</span><span class=n>skb</span><span class=p>,</span> <span class=nf>arp_hdr_len</span><span class=p>(</span><span class=n>dev</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>                <span class=k>goto</span> <span class=n>freeskb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>arp</span> <span class=o>=</span> <span class=nf>arp_hdr</span><span class=p>(</span><span class=n>skb</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>这样的处理甚至可以说是标准处理，首先通过skb_share_check确定这个包没有被其他人引用，如果有，那么就clone一个出来。这样做是因为后面的pskb_may_pull有可能改变sk_buff中的指针，导致不一致的情况出现。<code>pskb_may_pull</code>函数确保data与tail指针之间数据的长度至少有arp_hdr_len(dev)这么长。这里提一句，这么令人费解的操作是因为一个sk_buff的数据可以分为三段，第一段称为线性区（即data与tail指针之间的数据），第二段称为ummaped page区域，第三段为fragment list。我们可以看到后面直接使用arp_hdr(skb)获取了ARP Header，而arp_hdr的代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=k>struct</span> <span class=n>arphdr</span> <span class=o>*</span><span class=nf>arp_hdr</span><span class=p>(</span><span class=k>const</span> <span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=n>skb</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>(</span><span class=k>struct</span> <span class=n>arphdr</span> <span class=o>*</span><span class=p>)</span><span class=nf>skb_network_header</span><span class=p>(</span><span class=n>skb</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=nf>skb_network_header</span><span class=p>(</span><span class=k>const</span> <span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=n>skb</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>skb</span><span class=o>-&gt;</span><span class=n>head</span> <span class=o>+</span> <span class=n>skb</span><span class=o>-&gt;</span><span class=n>network_header</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>可以看到是直接通过指针进行类型转换的，因此如果线性区中的数据不够长的话，得到的arp_hdr返回的struct arphdr指向的数据就是不完整的，尾巴上少了一截。</p><p>随后开始检查ARP包中的数据是否合法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>arp</span><span class=o>-&gt;</span><span class=n>ar_hln</span> <span class=o>!=</span> <span class=n>dev</span><span class=o>-&gt;</span><span class=n>addr_len</span> <span class=o>||</span> <span class=n>arp</span><span class=o>-&gt;</span><span class=n>ar_pln</span> <span class=o>!=</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>goto</span> <span class=n>freeskb</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>这里检查了ARP包中Hardware Length是否与接收到这个包的网络接口的链路层地址是否一致。由于ARP协议是和IP协议绑定的，所以这里直接检查协议地址长度的长度是否为4（即IPv4的地址长度）。最后我们看到了一个新的Netfilter:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>        <span class=nf>memset</span><span class=p>(</span><span class=nf>NEIGH_CB</span><span class=p>(</span><span class=n>skb</span><span class=p>),</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>neighbour_cb</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nf>NF_HOOK</span><span class=p>(</span><span class=n>NFPROTO_ARP</span><span class=p>,</span> <span class=n>NF_ARP_IN</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                       <span class=nf>dev_net</span><span class=p>(</span><span class=n>dev</span><span class=p>),</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>skb</span><span class=p>,</span> <span class=n>dev</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                       <span class=n>arp_process</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=arp_process函数>arp_process函数</h2><p>arp_process函数首先检查了ARP Header中的HW字段是否与设备相匹配。随后可以看到Linux系统对于接收到的ARP包<em><strong>只处理ARPOP_REPLY和ARPOP_REQUEST</strong></em>。随后将ARP协议的数据从ARP包中取出来，得到如下几个变量：</p><table><thead><tr><th style=text-align:center>名称</th><th style=text-align:center>注释</th></tr></thead><tbody><tr><td style=text-align:center>sha</td><td style=text-align:center>source hardware address，即发送方的MAC地址</td></tr><tr><td style=text-align:center>tha</td><td style=text-align:center>target hardware address，即发送方的MAC地址</td></tr><tr><td style=text-align:center>sip</td><td style=text-align:center>source ip， 即发送方的IP地址</td></tr><tr><td style=text-align:center>tip</td><td style=text-align:center>target ip，即接收方的IP地址</td></tr></tbody></table><p>接下来可以看到ARP协议栈检查了tip的值，扔掉了目标地址为组播，广播和本地的ARP包，因为这些IP地址压根是不需要进行ARP解析的，所以处于安全性和性能的考虑直接将这些包丢掉。</p><h3 id=对arpop_request的处理>对ARPOP_REQUEST的处理</h3><p>这里Linux内核首先处理了一个特殊情况，<code>sip == 0</code>,其实就是检查sip变量的值是否为0.0.0.0。对于某些DHCP服务器或者客户端来说，可以使用以源IP地址为0.0.0.0的方式发送ARP Request，以此检测特定的IP地址已经被占用。之所以称之为特殊情况，是因为<em><strong>Linux内核默认不响应一个不在它路由表中的IP地址发来的ARPOP_REQUEST</strong></em>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>        <span class=cm>/* Special case: IPv4 duplicate address detection packet (RFC2131) */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>sip</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>arp</span><span class=o>-&gt;</span><span class=n>ar_op</span> <span class=o>==</span> <span class=nf>htons</span><span class=p>(</span><span class=n>ARPOP_REQUEST</span><span class=p>)</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                    <span class=nf>inet_addr_type_dev_table</span><span class=p>(</span><span class=n>net</span><span class=p>,</span> <span class=n>dev</span><span class=p>,</span> <span class=n>tip</span><span class=p>)</span> <span class=o>==</span> <span class=n>RTN_LOCAL</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                    <span class=o>!</span><span class=nf>arp_ignore</span><span class=p>(</span><span class=n>in_dev</span><span class=p>,</span> <span class=n>sip</span><span class=p>,</span> <span class=n>tip</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                        <span class=nf>arp_send_dst</span><span class=p>(</span><span class=n>ARPOP_REPLY</span><span class=p>,</span> <span class=n>ETH_P_ARP</span><span class=p>,</span> <span class=n>sip</span><span class=p>,</span> <span class=n>dev</span><span class=p>,</span> <span class=n>tip</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                     <span class=n>sha</span><span class=p>,</span> <span class=n>dev</span><span class=o>-&gt;</span><span class=n>dev_addr</span><span class=p>,</span> <span class=n>sha</span><span class=p>,</span> <span class=n>reply_dst</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>goto</span> <span class=n>out_consume_skb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>可以从代码中发现只有如下条件都满足的情况下，Linux内核才会响应一个ARPOP_REQUEST：</p><ol><li>内核知道如何与sip指向的IP地址的主机进行通信</li><li>tip是本机的一个IP地址，或者本机对该IP地址的ARP解析进行了代理</li><li>本机的管理员没有显式的阻止对该ARPOP_REQUEST的响应</li></ol><h3 id=对arpop_reply的处理>对ARPOP_REPLY的处理</h3><p>TODO THIS</p><h2 id=arp_solicit函数>arp_solicit函数</h2><p>所有arp_ops中的.solicit指针都是指向arp_solicit函数的。为了读懂这个函数，首先要明白arp_announce的概念和用途。Linux内核中网络协议栈有一个比较明显的特点：虽然系统管理员在设置IP地址的时候看起来像是为特定的网络接口设置的，但是<em><strong>在Linux内核眼中，IP地址是属于整个Host的</strong></em>。因此，在早期的Linux内核中，会出现将本应该属于特定subnet中的ARP请求发送到属于其他subnet系统的网络接口中。因此，arp_announce选项就是为了解决这个问题而出现的。</p><p>arp_annouce分为三个级别，如下表：</p><table><thead><tr><th style=text-align:center>级别</th><th style=text-align:center>说明</th></tr></thead><tbody><tr><td style=text-align:center>0</td><td style=text-align:center>默认可以使用所有接口上的所有IP地址</td></tr><tr><td style=text-align:center>1</td><td style=text-align:center>SADDR必须与需要解析的地址在同一个子网中</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>强制使用在目标主机子网上的IP地址</td></tr></tbody></table><p>arp_solicit函数的声明如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>arp_solicit</span><span class=p>(</span><span class=k>struct</span> <span class=n>neighbour</span> <span class=o>*</span><span class=n>neigh</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=n>skb</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>其中， neigh参数是需要进行解析的tbl_entry，skb参数是触发这次解析的包。arp_solicit函数最重要的任务就是确定ARP报文中对应字段的值。可以看到该函数开头通过arp_announce确定ARP报文的saddr：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>        <span class=k>switch</span> <span class=p>(</span><span class=nf>IN_DEV_ARP_ANNOUNCE</span><span class=p>(</span><span class=n>in_dev</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=mi>0</span><span class=o>:</span>         <span class=cm>/* By default announce any local IP */</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>skb</span> <span class=o>&amp;&amp;</span> <span class=nf>inet_addr_type_dev_table</span><span class=p>(</span><span class=nf>dev_net</span><span class=p>(</span><span class=n>dev</span><span class=p>),</span> <span class=n>dev</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                          <span class=nf>ip_hdr</span><span class=p>(</span><span class=n>skb</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>saddr</span><span class=p>)</span> <span class=o>==</span> <span class=n>RTN_LOCAL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                        <span class=n>saddr</span> <span class=o>=</span> <span class=nf>ip_hdr</span><span class=p>(</span><span class=n>skb</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>saddr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=mi>1</span><span class=o>:</span>         <span class=cm>/* Restrict announcements of saddr in same subnet */</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>skb</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>saddr</span> <span class=o>=</span> <span class=nf>ip_hdr</span><span class=p>(</span><span class=n>skb</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>saddr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=nf>inet_addr_type_dev_table</span><span class=p>(</span><span class=nf>dev_net</span><span class=p>(</span><span class=n>dev</span><span class=p>),</span> <span class=n>dev</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                             <span class=n>saddr</span><span class=p>)</span> <span class=o>==</span> <span class=n>RTN_LOCAL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=cm>/* saddr should be known to target */</span>
</span></span><span class=line><span class=cl>                        <span class=k>if</span> <span class=p>(</span><span class=nf>inet_addr_onlink</span><span class=p>(</span><span class=n>in_dev</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>saddr</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=n>saddr</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=mi>2</span><span class=o>:</span>         <span class=cm>/* Avoid secondary IPs, get a primary/preferred one */</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>saddr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>saddr</span> <span class=o>=</span> <span class=nf>inet_select_addr</span><span class=p>(</span><span class=n>dev</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>RT_SCOPE_LINK</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>case 0很好懂，case 1比case 0多了一个检查，即确定target与saddr是否直接相连，当前两个case不满足的时候，默认直接就开始使用arp_annouce=2的配置。</p></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>crab2313</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2021-04-08
<a href=https://github.com/crab2313/blog-doc/commit/9355da19834c1c2a2cf78bab1f2c327eb2ab6362 title="blog: post two old blog posts">(9355da1)</a></span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/kernel/>kernel</a>
<a href=/tags/net/>net</a></div><nav class=post-nav><a class=prev href=/post/in-place-huffman/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">In Place Huffman算法分析</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/drm-atomic-kms/><span class="next-text nav-default">DRM框架分析（四）：Atomic KMS</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:crab2313@gmail.com class="iconfont icon-email" title=email></a>
<a href=https://github.com/crab2313 class="iconfont icon-github" title=github></a>
<a href=https://gitlab.com/crab2313 class="iconfont icon-gitlab" title=gitlab></a>
<a href=https://space.bilibili.com/1310103 class="iconfont icon-bilibili" title=bilibili></a>
<a href=/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2017 -
2023<span class=heart><i class="iconfont icon-heart"></i></span><span>crab2313</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script>
<script type=text/javascript>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script></body></html>