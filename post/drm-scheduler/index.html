<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>DRM框架分析（五）：任务调度 - crab2313's blog</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="crab2313"><meta name=description content="本文分析的这个DRM调度器实际上是在2018年左右由AMD的部分代码演变出来的，即由AMD私用变成DRM子系统共用的了。目前有三四个驱动使用"><meta name=keywords content="blog,kernel"><meta name=generator content="Hugo 0.96.0 with theme even"><link rel=canonical href=/post/drm-scheduler/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="DRM框架分析（五）：任务调度"><meta property="og:description" content="本文分析的这个DRM调度器实际上是在2018年左右由AMD的部分代码演变出来的，即由AMD私用变成DRM子系统共用的了。目前有三四个驱动使用"><meta property="og:type" content="article"><meta property="og:url" content="/post/drm-scheduler/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-04-11T00:00:00+00:00"><meta property="article:modified_time" content="2022-04-14T17:04:41+08:00"><meta itemprop=name content="DRM框架分析（五）：任务调度"><meta itemprop=description content="本文分析的这个DRM调度器实际上是在2018年左右由AMD的部分代码演变出来的，即由AMD私用变成DRM子系统共用的了。目前有三四个驱动使用"><meta itemprop=datePublished content="2022-04-11T00:00:00+00:00"><meta itemprop=dateModified content="2022-04-14T17:04:41+08:00"><meta itemprop=wordCount content="4200"><meta itemprop=keywords content="kernel,drm,"><meta name=twitter:card content="summary"><meta name=twitter:title content="DRM框架分析（五）：任务调度"><meta name=twitter:description content="本文分析的这个DRM调度器实际上是在2018年左右由AMD的部分代码演变出来的，即由AMD私用变成DRM子系统共用的了。目前有三四个驱动使用"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>crab2313's blog</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>crab2313's blog</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>DRM框架分析（五）：任务调度</h1><div class=post-meta><span class=post-time>2022-04-11</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#队列管理>队列管理</a></li><li><a href=#调度实体>调度实体</a></li><li><a href=#调度策略>调度策略</a></li><li><a href=#timeout机制>timeout机制</a></li><li><a href=#fence机制>fence机制</a></li><li><a href=#drm_sched_main>drm_sched_main</a></li></ul></li></ul></nav></div></div><div class=post-content><p>本文分析的这个DRM调度器实际上是在2018年左右由AMD的部分代码演变出来的，即由AMD私用变成DRM子系统共用的了。目前有三四个驱动使用这个DRM调度器。首先明确这个调度器调度的是什么：Hardware Run Queue，或者Hardware Ring Buffer。简而言之，就是一些硬件Command Ring类似的单元实际上是有限的资源，在同一时刻只能执行固定个数的任务，需要通过软件的手段调度这个硬件资源，让相关的任务排队，并均匀分配。</p><p>在drm_sched模块中，有以下映射关系：</p><ul><li>Hardware Run Queue与调度器一一对应</li><li>每个调度器分为多个优先级run queue</li><li>每个run queue中对调度实体entity进行调度</li><li>每个调度实体包含一个job queue</li></ul><p>简单来说，DRM任务调度器接收调度实体，根据优先级按照轮转的方式将调度实体中的任务进行执行。这个过程发生在一个内核线程中，每一个调度器在初始化中都会创建自己的内核线程，内核线程的函数为<code>drm_sched_main</code>。从框架角度来看，框架使用<code>drm_sched_job</code>表示一个任务。</p><p>调度器由<code>drm_gpu_scheduler</code>结构提表示，上层驱动代码可以通过注册一个<code>drm_sched_backend_ops</code>特化一个调度器的行为，这个ops简单包括几个回调函数，因此调度器的实现是比较固定的。</p><h2 id=队列管理>队列管理</h2><p><code>drm_gpu_scheduler</code>中存在<code>hw_submission_limit</code>字段，用来设定对应hardware run queue中最大支持的任务数。在当前提交的任务数小于这个上限的时候认为这个调度器是就绪状态：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>bool</span> <span class=nf>drm_sched_ready</span><span class=p>(</span><span class=k>struct</span> <span class=n>drm_gpu_scheduler</span> <span class=o>*</span><span class=n>sched</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>atomic_read</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sched</span><span class=o>-&gt;</span><span class=n>hw_rq_count</span><span class=p>)</span> <span class=o>&lt;</span>
</span></span><span class=line><span class=cl>                <span class=n>sched</span><span class=o>-&gt;</span><span class=n>hw_submission_limit</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>从上面看到，<code>hw_rq_count</code>实际上就是已经提交给Hardware run queue的任务的数量。当任务提交之后，对应的<code>drm_sched_job</code>会从entity中卸下，然后放入<code>ring_mirror_list</code>中。当任务执行完毕之后，<code>drm_sched_process_job</code>会进行后续处理，signal对应的fence，然后将job从<code>ring_miror_list</code>中取下，并修改对应的计数器。</p><h2 id=调度实体>调度实体</h2><p>调度器中使用<code>drm_sched_entity</code>表示一个调度实体，本质上是一个容器，用于存放执行的最小单元：<code>drm_sched_job</code>。简单来说<code>drm_sched_entity</code>中有一个队列，由<code>drm_sched_job</code>组成，调度器保证这个队列中的job按照顺序执行。</p><p>这里注意，调度实体看似只是一个简单容器，但是实际上实现了硬件负载均衡功能。简单来说，比如有两个同样功能的hardware run queue，可以同时处理同一种任务，此时需要一个负载均衡机制，才不会出现一个run queue接近满员，而另一个run queue是空的状况。这个负载均衡机制的实现比较简单，<code>drm_sched_entity</code>在创建时可以指定多个<code>drm_sched_rq</code>，注意这几个队列不是来自同一个调度器，而是多个不同的调度器。<code>drm_sched_entity</code>在这个情况下有一个概念叫“当前的”队列，每当<code>drm_sched_job</code>创建时，都会调用<code> drm_sched_entity_select_rq</code>函数设置这个当前队列。设置规则，很简单，仅仅是遍历可用队列，然后找出当前任务最少的队列即可。</p><p>也就是说，为了实现负载均衡，一个调度实体实际上可以在两个调度器里左右横跳。</p><h2 id=调度策略>调度策略</h2><p>调度策略还是比较简单的，本质上就是一个基于优先级的轮询调度。前面看到一个调度器会根据优先级分成多个run queue，每一个run queue中有一个调度实体队列。<code>drm_sched_select_entity</code>函数负责在调度器中选择一个实体，这个选择实际上会基于run queue考虑。函数首先检索高优先级的run queue，再检索低优先级的run queue，一旦有run queue能提供一个调度实体，则返回这个调度实体。</p><p>对于run queue，<code>drm_sched_rq_select_entity</code>负责从run queue中找到可用调度实体。查找过程本质上是轮询一个循环队列，run queue会记录上一次给出的调度实体，然后从这个调度实体的下一个开始检测，依次调用<code>drm_sched_entity_is_ready</code>函数检测实体是否就绪。可以看到，实体就绪的两个必要的条件是：</p><ul><li>调度实体的job队列中存在job</li><li>调度实体的dependency字段为NULL</li></ul><p>当实体就绪时，则函数给出该实体作为结果。对于每一个调度实体，调度器从中取出一个job，调用调度器注册的<code>run_job</code>回调函数将其执行。而返回调度实体上的job实际上由<code>drm_sched_entity_pop_job</code>函数完成，注意返回一个job不是顺理成章直接完成的事，而是需要与dependency机制结合。</p><p>前面看到调度实体<code>drm_sched_entity</code>中存在<code>dependency</code>指针指向一个<code>dma_fence</code>，这个fence实际上就是当前调度实体即将运行的job的依赖。在<code>drm_sched_entity_pop_job</code>函数中，函数会调用调度器的<code>dependency</code>函数指针，要求使用框架的上层驱动提供这个job的<code>dependency</code>指针，即一个dma_fence。如果上层驱动返回了这个fence，并经过多次检查，fence合法后，则设置调度实体的dependency指针，并注册回调函数清除这个指针，同时<code>drm_sched_entity_pop_job</code>直接返回NULL。这么做简单来讲，就是运行job之前，调用上层驱动代码注册的回调函数计算并提供job的资源依赖fence，这个fence会阻止job的运行，直到fence被触发。这样也对应上面提到的<code>drm_sched_entity_is_ready</code>的第二个条件，即<code>dependency</code>字段非NULL的情况下调度实体是没有就绪的，因为相关事件依赖没有被满足。</p><p>因此，本质上调度策略比较像内核的实时调度策略，优先执行高优先级run queue，对于每一个run queue，轮换执行每一个调度实体的一个任务，直到实体的任务全部被执行完。</p><h2 id=timeout机制>timeout机制</h2><p><code>drm_gpu_scheduler</code>中定义了一个<code>delayed_work</code>，称作<code>work_tdr</code>。它对应的callback为<code>drm_sched_job_timeout</code>。大致上，<code>drm_gpu_scheduler</code>中会顶一个一个timeout字段，如果一个job超过这个时间没有执行完毕，则会执行callback。可以看到这个<code>delayed_work</code>的作用是在job hang住时，进行一个恢复或者通知。与之相关的API是<code>drm_sched_start_timeout</code>，这个函数会将这个<code>delayed_work</code>重置。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>drm_sched_start_timeout</span><span class=p>(</span><span class=k>struct</span> <span class=n>drm_gpu_scheduler</span> <span class=o>*</span><span class=n>sched</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>sched</span><span class=o>-&gt;</span><span class=n>timeout</span> <span class=o>!=</span> <span class=n>MAX_SCHEDULE_TIMEOUT</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>            <span class=o>!</span><span class=n>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sched</span><span class=o>-&gt;</span><span class=n>ring_mirror_list</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=n>schedule_delayed_work</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sched</span><span class=o>-&gt;</span><span class=n>work_tdr</span><span class=p>,</span> <span class=n>sched</span><span class=o>-&gt;</span><span class=n>timeout</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=fence机制>fence机制</h2><p>这里的fence基于dma-fence进行了特化，封装成了<code>drm_sched_fence</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>drm_sched_fence</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>dma_fence</span>                <span class=n>scheduled</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>dma_fence</span>                <span class=n>finished</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>dma_fence</span>                <span class=o>*</span><span class=n>parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>spinlock_t</span>                      <span class=n>lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>void</span>                            <span class=o>*</span><span class=n>owner</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>可以简单看到<code>drm_sched_fence</code>是三个概念的集合：</p><ul><li>scheduled，这个fence在job被调度（即运行run_job回调函数之前）时触发</li><li>finished，这个fence在真正的hardware job运行完成后触发</li><li>parent，这个fence实际上就是run_job的返回值，这里拿着一个指针，并注册一个callback，好在hardware job完成之时触发finished fence</li></ul><p>上面提到给parent注册回调函数实际上就是<code>drm_sched_process_job</code>，即在job完成后运行的回调函数。简单来说，<code>drm_gpu_scheduler</code>注册的<code>drm_sched_backend_ops->run_job</code>回调函数会返回的fence，这个fence会在hardware run queue执行完job后触发。得到这个fence之后，我们直接给这个fence注册<code>drm_sched_process_job</code>回调函数，然后在这个回调函数中直接触发名为<code>finished</code>的fence，并将job从<code>ring_mirror_list</code>中卸下。</p><h2 id=drm_sched_main>drm_sched_main</h2><p><code>drm_sched_main</code>实际上就是上面提到的内核线程的执行函数。</p><p>函数开头可以看到将这个内核线程的调度策略设置成了<code>SCHED_FIFO</code>，并将优先级设置成1。随后函数进入了任务处理循环，可以看到<code>drm_gpu_scheduler</code>中提前准备好了，一个wait queue，名为<code>wake_up_worker</code>。函数首先在这个wait queue上以如下条件进行等待：</p><ul><li>cleanup_job = drm_sched_get_cleanup_job(sched)) 不为NULL</li><li>!drm_sched_blocked(sched) && (entity = drm_sched_select_entity(sched)))</li><li>kthread_should_stop()</li></ul><p>在上面任意一个条件满足时，内核线程即唤醒，然后继续执行任务。如果cleanup_job不为NULL，则进行如下操作：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>cleanup_job</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>sched</span><span class=o>-&gt;</span><span class=n>ops</span><span class=o>-&gt;</span><span class=n>free_job</span><span class=p>(</span><span class=n>cleanup_job</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                        <span class=cm>/* queue timeout for next job */</span>
</span></span><span class=line><span class=cl>                        <span class=n>drm_sched_start_timeout</span><span class=p>(</span><span class=n>sched</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>随后函数检查entity是否为NULL，不为NULL则根据entity拿到下一个应该执行的job：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>                <span class=n>sched_job</span> <span class=o>=</span> <span class=n>drm_sched_entity_pop_job</span><span class=p>(</span><span class=n>entity</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>sched_job</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                        <span class=k>continue</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>随后函数执行以下语句：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>                <span class=n>atomic_inc</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sched</span><span class=o>-&gt;</span><span class=n>hw_rq_count</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>drm_sched_job_begin</span><span class=p>(</span><span class=n>sched_job</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>这两个操作分别是：</p><ul><li>增加<code>hw_rq_count</code>计数器，该计数器标志已经压入hardware run queue的任务的个数</li><li>将任务从调度实体的队列中拿下，并放到<code>ring_mirror_list</code>中，表示它正在被hardware run queue执行。同时，使能timeout定时器，防止job超时</li></ul><p>准备工作做完后，直接上层驱动代码注册的<code>run_job</code>回调函数，执行任务：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>                <span class=n>fence</span> <span class=o>=</span> <span class=n>sched</span><span class=o>-&gt;</span><span class=n>ops</span><span class=o>-&gt;</span><span class=n>run_job</span><span class=p>(</span><span class=n>sched_job</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>drm_sched_fence_scheduled</span><span class=p>(</span><span class=n>s_fence</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>注意这里的先后顺序，run_job仅仅是将任务压到hardware run queue，此时需要等待硬件执行，所以此时直接触发<code>scheduled</code>的fence而不是<code>finished</code>。注意<code>run_job</code>的返回值也是一个fence，这个fence被触发时，即表明hardware run queue上该job被硬件执行完毕。因此，函数需要在该fence上注册回调函数，当job在硬件上完成后，调用<code>drm_sched_process_job</code>函数，进行：</p><ul><li>计数器更新，hw_rq_count以及num_jobs</li><li>触发finished fence</li><li>唤醒内核线程工作（有job处理完毕表示hardware run queue有新空位了）</li></ul><p>最后的最后，函数唤醒<code>job_scheduled</code>等待队列，表示有新job推到hardware run queue上了。</p></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>crab2313</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2022-04-14
<a href=https://github.com/crab2313/blog-doc/commit/92bc306d0db9e33d93ca0f0a109f201033bdbb73 title="blog: hardware job scheduler analysis of DRM">(92bc306)</a></span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/kernel/>kernel</a>
<a href=/tags/drm/>drm</a></div><nav class=post-nav><a class=next href=/post/mesa-egl/><span class="next-text nav-default">MESA源码分析：EGL</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:crab2313@gmail.com class="iconfont icon-email" title=email></a>
<a href=https://github.com/crab2313 class="iconfont icon-github" title=github></a>
<a href=https://gitlab.com/crab2313 class="iconfont icon-gitlab" title=gitlab></a>
<a href=https://space.bilibili.com/1310103 class="iconfont icon-bilibili" title=bilibili></a>
<a href=/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2017 -
2022<span class=heart><i class="iconfont icon-heart"></i></span><span>crab2313</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js></script>
<script type=text/javascript>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin=anonymous></script></body></html>